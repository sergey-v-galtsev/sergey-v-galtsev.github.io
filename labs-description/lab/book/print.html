<!DOCTYPE HTML>
<html lang="ru" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Лабораторные работы</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="0-intro-1-nikka.html">Введение в лабораторные работы</a></li><li class="chapter-item expanded affix "><a href="0-intro-2-rust.html">Почему Rust</a></li><li class="chapter-item expanded affix "><a href="0-intro-3-dirs.html">Структура кода</a></li><li class="chapter-item expanded affix "><a href="0-intro-4-install.html">Компиляция и запуск тестов</a></li><li class="chapter-item expanded affix "><a href="0-intro-5-gdb.html">Запуск с отладчиком gdb</a></li><li class="chapter-item expanded affix "><a href="0-intro-6-log.html">Логирование и логи</a></li><li class="chapter-item expanded affix "><a href="0-intro-7-vscode.html">Настройка VSCode</a></li><li class="chapter-item expanded affix "><li class="part-title">Лабораторная работа №1</li><li class="chapter-item expanded "><a href="1-time-0-intro.html"><strong aria-hidden="true">1.</strong> Время</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1-time-1-rtc.html"><strong aria-hidden="true">1.1.</strong> Часы реального времени</a></li><li class="chapter-item expanded "><a href="1-time-2-tsc.html"><strong aria-hidden="true">1.2.</strong> Счётчик тактов процессора</a></li><li class="chapter-item expanded "><a href="1-time-3-correlation-point.html"><strong aria-hidden="true">1.3.</strong> Счётчики тиков</a></li><li class="chapter-item expanded "><a href="1-time-4-correlation-interval.html"><strong aria-hidden="true">1.4.</strong> Измерение частоты процессора и повышение разрешения часов</a></li><li class="chapter-item expanded "><a href="1-time-5-interrupts.html"><strong aria-hidden="true">1.5.</strong> Обработка прерываний RTC</a></li><li class="chapter-item expanded "><a href="1-time-6-info.html"><strong aria-hidden="true">1.6.</strong> Информация о системе</a></li><li class="chapter-item expanded "><a href="1-time-7-summary.html"><strong aria-hidden="true">1.7.</strong> Собираем всё вместе</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Лабораторная работа №2</li><li class="chapter-item expanded "><a href="2-mm-0-intro.html"><strong aria-hidden="true">2.</strong> Память</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2-mm-1-types.html"><strong aria-hidden="true">2.1.</strong> Типы</a></li><li class="chapter-item expanded "><a href="2-mm-2-mapping.html"><strong aria-hidden="true">2.2.</strong> Страничные отображения</a></li><li class="chapter-item expanded "><a href="2-mm-3-diagrams.html"><strong aria-hidden="true">2.3.</strong> Диаграммы преобразований</a></li><li class="chapter-item expanded "><a href="2-mm-4-plan.html"><strong aria-hidden="true">2.4.</strong> План</a></li><li class="chapter-item expanded "><a href="2-mm-5-boot-frame-allocator.html"><strong aria-hidden="true">2.5.</strong> Временный аллокатор фреймов</a></li><li class="chapter-item expanded "><a href="2-mm-6-address-space.html"><strong aria-hidden="true">2.6.</strong> Виртуальное адресное пространство</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2-mm-6-address-space-1-allocation.html"><strong aria-hidden="true">2.6.1.</strong> Аллокатор виртуальных страниц адресного пространства</a></li><li class="chapter-item expanded "><a href="2-mm-6-address-space-2-translate.html"><strong aria-hidden="true">2.6.2.</strong> Отображение виртуальных страниц в физические фреймы</a></li><li class="chapter-item expanded "><a href="2-mm-6-address-space-3-map.html"><strong aria-hidden="true">2.6.3.</strong> Высокоуровневый интерфейс управления адресным пространством</a></li></ol></li><li class="chapter-item expanded "><a href="2-mm-7-main-frame-allocator.html"><strong aria-hidden="true">2.7.</strong> Основной аллокатор фреймов</a></li><li class="chapter-item expanded "><a href="2-mm-8-tests.html"><strong aria-hidden="true">2.8.</strong> Проверьте себя</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Лабораторная работа №3</li><li class="chapter-item expanded "><a href="3-process-0-intro.html"><strong aria-hidden="true">3.</strong> Процессы</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3-process-1-elf.html"><strong aria-hidden="true">3.1.</strong> Загрузка процесса в память</a></li><li class="chapter-item expanded "><a href="3-process-2-permission-checks.html"><strong aria-hidden="true">3.2.</strong> Проверки доступа процесса к памяти</a></li><li class="chapter-item expanded "><a href="3-process-3-user-mode.html"><strong aria-hidden="true">3.3.</strong> Переход в режим пользователя</a></li><li class="chapter-item expanded "><a href="3-process-4-syscall.html"><strong aria-hidden="true">3.4.</strong> Поддержка системных вызовов</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Лабораторная работа №4</li><li class="chapter-item expanded "><a href="4-concurrency-0-intro.html"><strong aria-hidden="true">4.</strong> Конкурентное выполнение задач</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4-concurrency-1-memory-allocator.html"><strong aria-hidden="true">4.1.</strong> Аллокатор памяти общего назначения</a></li><li class="chapter-item expanded "><a href="4-concurrency-1-smp-0-intro.html"><strong aria-hidden="true">4.2.</strong> Поддержка нескольких процессоров (SMP)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4-concurrency-1-smp-1-local-apic.html"><strong aria-hidden="true">4.2.1.</strong> Работа с local APIC</a></li><li class="chapter-item expanded "><a href="4-concurrency-1-smp-2-cpus.html"><strong aria-hidden="true">4.2.2.</strong> Состояние каждого процессора</a></li><li class="chapter-item expanded "><a href="4-concurrency-1-smp-3-ap-init.html"><strong aria-hidden="true">4.2.3.</strong> Загрузка Application Processor</a></li></ol></li><li class="chapter-item expanded "><a href="4-concurrency-2-table.html"><strong aria-hidden="true">4.3.</strong> Таблица процессов</a></li><li class="chapter-item expanded "><a href="4-concurrency-3-preemption.html"><strong aria-hidden="true">4.4.</strong> Вытесняющая многозадачность</a></li><li class="chapter-item expanded "><a href="4-concurrency-4-scheduler.html"><strong aria-hidden="true">4.5.</strong> Планировщик</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Лабораторная работа №5</li><li class="chapter-item expanded "><a href="5-um-0-intro.html"><strong aria-hidden="true">5.</strong> Продвинутая работа с памятью в пространстве пользователя</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5-um-1-ring-buffer.html"><strong aria-hidden="true">5.1.</strong> Разделяемая память</a></li><li class="chapter-item expanded "><a href="5-um-2-memory.html"><strong aria-hidden="true">5.2.</strong> Системные вызовы для работы с виртуальной памятью</a></li><li class="chapter-item expanded "><a href="5-um-3-eager-fork.html"><strong aria-hidden="true">5.3.</strong> Eager fork</a></li><li class="chapter-item expanded "><a href="5-um-4-trap-handler.html"><strong aria-hidden="true">5.4.</strong> Обработка исключений в режиме пользователя</a></li><li class="chapter-item expanded "><a href="5-um-5-cow-fork.html"><strong aria-hidden="true">5.5.</strong> Copy-on-write fork</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Лабораторная работа №6</li><li class="chapter-item expanded "><a href="6-fs-0-intro.html"><strong aria-hidden="true">6.</strong> Файловая система</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="6-fs-1-block-cache.html"><strong aria-hidden="true">6.1.</strong> Блочный кеш</a></li><li class="chapter-item expanded "><a href="6-fs-2-block-bitmap.html"><strong aria-hidden="true">6.2.</strong> Битмап занятых блоков</a></li><li class="chapter-item expanded "><a href="6-fs-3-inode.html"><strong aria-hidden="true">6.3.</strong> Index node (inode)</a></li><li class="chapter-item expanded "><a href="6-fs-4-directory.html"><strong aria-hidden="true">6.4.</strong> Операции с директориями</a></li><li class="chapter-item expanded "><a href="6-fs-5-open.html"><strong aria-hidden="true">6.5.</strong> Поиск файла по пути</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Лабораторные работы</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Что-такое-лабораторки-на-nikka"><a class="header" href="#Что-такое-лабораторки-на-nikka">Что такое лабораторки на Nikka</a></h2>
<p>В лабораторках вы будете реализовывать части операционной системы
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/">Nikka</a>.
Nikka похожа на <a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/">JOS</a>, разработанную в MIT специально для курса
<a href="https://pdos.csail.mit.edu/6.828/2018/index.html">6.828: Operating System Engineering</a>.
В отличие от JOS, написанной на C, Nikka написана на <a href="https://www.rust-lang.org/">Rust</a>.
Некоторые вещи в Nikka были реализованы после знакомства с блогом
<a href="https://os.phil-opp.com/">Writing an OS in Rust, Philipp Oppermann’s blog</a>.</p>
<p>Лабораторки отличаются от обычных задач тем, что многие из них связаны между собой.
И, пока вы не сделаете одну, не сможете приступить к следующим.
Поэтому их очень важно делать, и делать вовремя.
Кроме того, их важно делать тщательно, хорошо понимая что происходит, как именно стоит реализовать требуемую функциональность, и как устроен код вокруг.
Если вы просто подгоните код под тесты или же допустите ошибку, которую тесты пропустят, то в следующих лабораторках это может проявиться.
А отлаживать ошибки потом будет сложнее.
Также учитывайте, что прекращение работы над кодом, как только тесты начнут проходить — частный случай подгонки под тесты.</p>
<p>Зато за тесты, ломающие референсный код, даются дополнительные баллы.
Так же как и за тесты, которые выявляют серьёзные ошибки в вашем собственном решении.
Естественно, если существующие тесты эти ошибки не ловят.</p>
<p>Ситуацию осложняет то, что Nikka некоторыми идеями отличается от других учебных ОС, например от
<a href="https://en.wikipedia.org/wiki/Xv6">xv6</a>.
А также от Unix вообще.
В частности, реализацию вызова
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/fork.html"><code>fork()</code></a>
вы будете делать в пользовательском коде, а не в коде ядра.
Ядро же для этого предоставит возможности, которых нет в обычном Unix.
Поэтому в коде Nikka придётся разбираться с учётом того, что она частично похожа на Unix,
но местами отличается.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Почему-rust"><a class="header" href="#Почему-rust">Почему Rust</a></h2>
<p>Исторически для разработки ОС использовался язык C.
Он характеризуется</p>
<ul>
<li>поддержкой большого количества платформ;</li>
<li>минималистичным рантаймом;</li>
<li>возможностью работы с оборудованием напрямую;</li>
<li>относительной высокоуровневостью, по сравнению с ассемблером.</li>
</ul>
<p>Rust имеет те же свойства, но в дополнении предоставляет:</p>
<ul>
<li>По-настоящему строгую типизацию, без неявных приведений типов.</li>
<li>Значительно большее количество проверок работы с памятью и работы в многопоточной среде.</li>
<li>Более предсказуемое поведение при наличии ошибок в программах, — Rust стремится уйти от Undefined Behaviour и облегчить задачу обнаружения причины ошибок.</li>
<li>Развитую систему типов. Например, элегантно реализуются функции, которые могут вернуть либо обычный результат, либо признак возникновения исключительной ситуации.</li>
<li>Высокоуровневые абстракции, которые помогают избегать ошибок в коде.</li>
<li><a href="https://doc.rust-lang.ru/book/ch10-02-traits.html">Типажи</a>, а также <a href="https://doc.rust-lang.ru/book/ch10-01-syntax.html">обобщённые типы и функции</a>.</li>
<li>Удобную систему <a href="https://doc.rust-lang.ru/book/ch07-02-defining-modules-to-control-scope-and-privacy.html">модулей</a> вместо инклюдов.</li>
<li>Встроенную систему сборки, подключения внешних библиотек (<a href="https://doc.rust-lang.ru/book/ch07-01-packages-and-crates.html">пакетов</a>) и тестирования.</li>
</ul>
<p>Благодаря этому стали <a href="https://en.wikipedia.org/wiki/Redox_(operating_system)">появляться</a> ОС на Rust, в том числе <a href="https://github.com/sslab-gatech/cs3210-rustos-public">учебные</a>.</p>
<p>Для ознакомления с Rust рекомендуется посмотреть записи первых четырёх занятий по нему из курса
<a href="https://lk.yandexdataschool.ru/courses/2021-autumn/7.939-rust/classes/">Современное системное программирование на Rust</a>
прошлого года:</p>
<ul>
<li><a href="https://lk.yandexdataschool.ru/courses/2021-autumn/7.939-rust/classes/7746/">Семинар 1. Rust crash course</a>.</li>
<li><a href="https://lk.yandexdataschool.ru/courses/2021-autumn/7.939-rust/classes/7891/">Лекция 2. Lifetimes, ownership &amp; borrow checking</a>.</li>
<li><a href="https://lk.yandexdataschool.ru/courses/2021-autumn/7.939-rust/classes/7932/">Лекция 3. Enums &amp; pattern matching. Traits</a>.</li>
<li><a href="https://lk.yandexdataschool.ru/courses/2021-autumn/7.939-rust/classes/8070/">Лекция 4. Обработка ошибок</a>.</li>
</ul>
<p>Также рекомендуется пройти <a href="https://github.com/rust-lang/rustlings/">упражнения</a>.
Глубоких знаний языка потребоваться не должно, особенно если вы знакомы с C++.</p>
<p>Мы будем пользоваться <a href="https://doc.rust-lang.ru/book/appendix-07-nightly-rust.html">nightly</a> Rust <a href="https://doc.rust-lang.org/edition-guide/rust-2021/index.html">редакции 2021</a>.</p>
<p>Так как ядро — это <a href="https://docs.rust-embedded.org/book/intro/no-std.html"><code>no_std</code></a> код,
не вся <a href="https://doc.rust-lang.org/nightly/std/index.html">стандартная библиотека <code>std</code></a> будет нам доступна.
Но будет доступна её
<a href="https://doc.rust-lang.org/nightly/core/index.html"><code>core</code></a>
часть.
После реализации аллокатора нам также будет доступна
<a href="https://doc.rust-lang.org/nightly/alloc/index.html"><code>alloc</code></a>
часть стандартной библиотеки.
Так что, например <a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html"><code>alloc::vec::Vec</code></a> будет нам доступен.</p>
<p>Учтите, что многие объекты из
<a href="https://doc.rust-lang.org/nightly/alloc/index.html"><code>alloc</code></a> и
<a href="https://doc.rust-lang.org/nightly/core/index.html"><code>core</code></a> реэкспортируются в
<a href="https://doc.rust-lang.org/nightly/std/index.html"><code>std</code></a>
и широко известны под своими <code>std::...</code> именами.
Поэтому если вы в поиске нашли какую-нибудь ссылку на <code>std::abc::def</code>, это ещё не значит, что он не доступен.
Просто проверьте его наличие в
<a href="https://doc.rust-lang.org/nightly/core/index.html"><code>core</code></a>
под именем <code>core::abc::def</code> и в
<a href="https://doc.rust-lang.org/nightly/alloc/index.html"><code>alloc</code></a>
под именем <code>alloc::abc::def</code>.</p>
<p>Полезные ресурсы по Rust:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a> — основная книга по языку, <a href="https://doc.rust-lang.ru/book/">перевод</a>.</li>
<li><a href="https://doc.rust-lang.org/reference/">The Rust Reference</a> — подробная документация по языку.</li>
<li><a href="https://doc.rust-lang.org/nomicon/index.html">The Rustonomicon</a> — руководство по написанию <code>unsafe</code> кода, <a href="https://github.com/rust-lang-ru/rustonomicon/blob/master/src/SUMMARY.md">перевод</a>.</li>
<li><a href="https://doc.rust-lang.org/stable/embedded-book/">The Embedded Rust Book</a> — руководство по написанию <code>no_std</code> кода.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Структура-кода"><a class="header" href="#Структура-кода">Структура кода</a></h2>
<p>Код Nikka разбит на несколько каталогов:</p>
<ul>
<li>lab — это описание лабораторных работ, <a href="index.html?search=Page">поддерживает поиск</a>.</li>
<li>doc — автоматически сгенерированная <a href="../../doc/kernel/index.html">документация</a>, в том числе по используемым библиотекам, <a href="../../doc/kernel/index.html?search=Page">поддерживает поиск</a>.</li>
<li><a href="../../doc/kernel/index.html">kernel</a> — ядро, то есть код, который запускается в привилегированном режиме.</li>
<li>user — процессы пользователя, то есть в первом приближении непривилегированный код.
<ul>
<li><a href="../../doc/lib/index.html">user/lib</a> — общая для пользовательских процессов библиотека.</li>
</ul>
</li>
<li><a href="../../doc/ku/index.html">ku</a> — общая для <strong>k</strong>ernel и <strong>u</strong>ser библиотека.</li>
<li>Несколько библиотек для поддержки оборудования, код которых менять не потребуется:
<ul>
<li>pic8259 — драйвер устаревшего контроллера прерываний;</li>
<li>serial — драйвер COM-порта;</li>
<li>text — драйвер для работы с экраном в текстовом режиме.</li>
</ul>
</li>
</ul>
<p>Также используется несколько внешних библиотек
Наиболее часто:</p>
<ul>
<li><a href="../../doc/tracing/index.html">tracing</a> для структурированного логирования.</li>
<li><a href="../../doc/x86/index.html">x86</a> и её развитый форк <a href="../../doc/x86_64/index.html">x86_64</a> для низкоуровневой работы с архитектурой <a href="https://en.wikipedia.org/wiki/X86-64">x86-64</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Инсталляция-компиляция-и-запуск-тестов"><a class="header" href="#Инсталляция-компиляция-и-запуск-тестов">Инсталляция, компиляция и запуск тестов</a></h2>
<p>Скорее всего вы уже настроили свой репозиторий, клонировав
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public">публичный репозиторий Nikka</a>
и подключив к нему персональный приватный репозиторий для отправки решений.
Как это сделать написано на странице курса.</p>
<p>Нам потребуются компилятор Rust и некоторые дополнительные утилиты.
Для удобства, их инсталляция записана в Makefile.
Поэтому можно просто запустить <code>make install</code> в корневом каталоге Nikka:</p>
<pre><code class="language-console">$ make install
</code></pre>
<p>Она должна будет уставить rustup, компилятор, cargo и все требуемые утилиты.</p>
<p>Можно вместо этого запустить тесты:</p>
<pre><code class="language-console">$ make test
</code></pre>
<p>Эта команда сама запустит инсталляцию, если она ещё не была выполнена.
После чего соберёт Nikka и запустит тесты.
Тесты ожидаемо упадут, так как задачи лабораторок ещё не выполнены.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Запуск-в-том-числе-с-отладчиком-gdb"><a class="header" href="#Запуск-в-том-числе-с-отладчиком-gdb">Запуск, в том числе с отладчиком gdb</a></h2>
<p>Если что-то пошло не так, для отладки можно запустить</p>
<pre><code class="language-console">$ make run-gdb
</code></pre>
<p>Запустится эмулятор qemu, который будет ждать подключения <code>gdb</code>.
В другой консоли запустите <code>gdb</code> командой</p>
<pre><code class="language-console">$ make gdb
</code></pre>
<p><code>gdb</code> подключится к <code>qemu</code>.
Теперь можно, например, поставить <code>breakpoint</code>:</p>
<pre><code class="language-console">...
0x000000000000fff0 in ?? ()
(gdb) br kernel_main
Breakpoint 1 at 0x21141f: file src/main.rs, line 36.
</code></pre>
<p>и запустить Nikka</p>
<pre><code class="language-console">(gdb) c
Continuing.

Thread 1 hit Breakpoint 1, kernel::kernel_main (boot_info=0x10000000000) at src/main.rs:36
36    kernel::init(boot_info);
</code></pre>
<p>Запустить <code>qemu</code> без <code>gdb</code> можно командой</p>
<pre><code class="language-console">$ make run
</code></pre>
<p>А для прогона тестов</p>
<pre><code class="language-console">$ make test
</code></pre>
<h3 id="Отладка-пользовательских-процессов"><a class="header" href="#Отладка-пользовательских-процессов">Отладка пользовательских процессов</a></h3>
<p>При необходимости отлаживать пользовательский процесс,
нужно сделать несколько дополнительных вещей:</p>
<ul>
<li>Отредактировать файл <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/gdbinit"><code>gdbinit</code></a>, заменив в нём команду загрузки бинарника ядра <code>file target/kernel/debug/kernel</code> на команду загрузки нужного пользовательского бинарника, например <code>file target/kernel/user/cow_fork</code>.</li>
<li>Можно также добавить в <code>gdbinit</code> дополнительные команды, например</li>
</ul>
<pre><code class="language-gdb">breakpoint lib::syscall::trap_handler_invoker
ignore 1 10
continue
</code></pre>
<p>добавит точку останова на заданную функцию и пропустит первые 10 попаданий на неё. То есть приглашение gdb будет показано на 11-е попадание в точку останова.</p>
<ul>
<li>Запустить <code>make test-gdb</code> в одной консоли и несколько раз <code>make gdb</code> в другой консоли, пока не запустится нужный тестовый процесс.</li>
</ul>
<h3 id="Дизассеблирование"><a class="header" href="#Дизассеблирование">Дизассеблирование</a></h3>
<p>Для получения информации о бинарниках и для их дизассемблирования можно использовать <code>objdump</code> в сочетании с <code>rustfilt</code>.
Например:</p>
<pre><code class="language-console">$ objdump --all-headers target/kernel/debug/kernel | rustfilt
$ objdump --disassemble --disassembler-options=intel target/kernel/debug/kernel | rustfilt
$ objdump --all-headers target/kernel/user/cow_fork | rustfilt
$ objdump --disassemble --disassembler-options=intel target/kernel/user/cow_fork | rustfilt
</code></pre>
<p>Для запуска <code>rustfilt</code> и других бинарников Rust полезно добавить <code>$HOME/.cargo/bin/</code> в свой <code>$PATH</code>:</p>
<pre><code class="language-console">$ tail -n1 ~/.bashrc
export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Логирование-и-логи"><a class="header" href="#Логирование-и-логи">Логирование и логи</a></h2>
<p>При обычном запуске — <code>make run</code> — логи записываются в файл <code>kernel/serial.out</code>:</p>
<pre><code class="language-console">$ make run
...
&lt;Ctrl-C&gt;
$ head -n20 kernel/serial.out
...
15:08:28 0 I RTC init; acknowledged_settings = USE_24_HOUR_FORMAT | USE_BINARY_FORMAT | UPDATE_ENDED_INTERRUPT
15:08:28 0 I time init
15:08:28 0 I Nikka booted; now = 2022-08-28 15:08:28 UTC; tsc = Tsc(10571359859)
15:08:28 0 I GDT init
15:08:28 0 I interrupts init
15:08:28 0 I phys2virt = Page(402653184 @ 0v18000000000)
15:08:28 0 I init; frame_allocator = &quot;boot frame allocator&quot;; block = [9.664 MiB, 49.875 MiB), size 40.211 MiB; free_frame_count = 10294
15:08:28 0 I page allocator init; free_page_count = 33822867456; block = [2.000 TiB, 128.000 TiB), size 126.000 TiB
15:08:28 0 I init; address_space = &quot;base&quot; @ 0p1000
15:08:28 0 I drop; address_space = &quot;invalid&quot; @ 0p0
15:08:28 0 I available memory; total = 49.875 MiB; usable = 41.715 MiB; total_frames = 12768; usable_frames = 10679
15:08:28 0 D frame info mapped; duration = 52.040 Mtsc
15:08:28 0 D frame info init; duration = 82.218 Mtsc
15:08:28 0 D move free frames; dst = &quot;main frame allocator&quot;; src = &quot;boot frame allocator&quot;; free_frame_count = 10216
15:08:28 0 I drop; frame_allocator = &quot;boot frame allocator&quot;; block = [9.664 MiB, 9.664 MiB), size 0 B; leaked_frame_count = 0
15:08:28 0 D moved all free frames; duration = 180.033 Mtsc
15:08:28 0 I init; frame_allocator = &quot;main frame allocator&quot;; free_frame_count = 10601; duration = 322.017 Mtsc
15:08:28 0 I memory init; duration = 461.240 Mtsc
15:08:28 0 I acpi_info = AcpiInfo { local_apic_address: Phys(0pFEE00000), bsp_id: 0, ap_ids: [1, 2, 3] }
15:08:28 0 I Local APIC init; cpu = 0; cpu_count = 4; local_apic_address = 0pFEE00000
</code></pre>
<p>При запуске тестов — <code>make test</code> или <code>(cd kernel; cargo test ...)</code>, —
а также при запуске без эмулируемого монитора — <code>make nox</code> или <code>(cd kernel; cargo run)</code>, —
логи пишутся в консоль.
Для запуска через <code>cargo</code> это можно поменять в файле <code>kernel/Cargo.toml</code>:</p>
<pre><code class="language-toml">[package.metadata.bootimage]
    # Отвечает за `cargo run`.
    run-args = [
        ...
        # Для перенаправления лога в файл `kernel/serial.out` поменяйте опцию `-serial`:
        # &quot;-serial&quot;, &quot;file:serial.out&quot;,
        &quot;-serial&quot;, &quot;stdio&quot;,
        # Опция `-display none` отключает окно с монитором эмулируемого компьютера.
        &quot;-display&quot;, &quot;none&quot;,
    ]

    # Отвечает за `cargo test ...`.
    test-args = [
        ...
        &quot;-serial&quot;, &quot;stdio&quot;,
        &quot;-display&quot;, &quot;none&quot;,
    ]
</code></pre>
<p>Здесь же можно поменять другие опции эмулятора <code>qemu</code>, если это понадобится.
Для <code>make ...</code> это делается в <code>Makefile</code>.</p>
<p>Для логирования используйте макросы <code>error</code>, <code>warn</code>, <code>info</code>, <code>debug</code> и <code>trace</code> из файла <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/log.rs"><code>kernel/src/log.rs</code></a>.
Это реэкспорты макросов библиотеки <a href="https://docs.rs/tracing/">tracing</a>.</p>
<p>Например, вызов</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>info!(free_page_count = page_allocator.block.count(), block = %page_allocator.block, &quot;page allocator init&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>приводит к печати</p>
<pre><code class="language-console">15:08:28 0 I page allocator init; free_page_count = 33822867456; block = [2.000 TiB, 128.000 TiB), size 126.000 TiB
</code></pre>
<p>Здесь:</p>
<ul>
<li><code>15:08:28</code> — время сообщения.</li>
<li><code>0</code> — номер процессора, на котором работал код.</li>
<li><code>I</code> — признак уровня логирования <code>INFO</code>.</li>
<li><code>page allocator init</code> — текст сообщения, за которым идут значения залогированных полей, разделённые знаком <code>;</code>.</li>
</ul>
<p>Запись</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>info!(..., free_page_count = page_allocator.block.count(), ...);
<span class="boring">}
</span></code></pre></pre>
<p>означает, что <code>free_page_count</code> — имя поля в структурированной части сообщения, а <code>page_allocator.block.count()</code> — значение этого поля.
Если в коде есть переменная <code>free_page_count</code> с нужным значением, <code>= ...</code> можно опустить:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>info!(..., free_page_count, ...);
<span class="boring">}
</span></code></pre></pre>
<p>Если вы забудете указать имя поля при печати сложного выражения, а не просто переменной, возникнет синтаксическая ошибка</p>
<pre><code class="language-console">error: expected expression, found `%`
  --&gt; src/tests/memory.rs:21:12
   |
21 |     debug!(%frames[0]);
   |            ^ expected expression
</code></pre>
<p>Просто добавьте имя поля:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>debug!(frame = %frames[0]);
<span class="boring">}
</span></code></pre></pre>
<p>Библиотека <a href="https://docs.rs/tracing/">tracing</a>
поддерживает печать встроенных типов напрямую.
А вот для пользовательских типов нужно указать <code>%</code> или <code>?</code>, как в</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trace!(page_allocator = %self, ..., ?block, ...);
<span class="boring">}
</span></code></pre></pre>
<p><code>%</code> означает печать типа через <a href="https://doc.rust-lang.ru/book/ch10-02-traits.html">типаж</a> <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html"><code>core::fmt::Display</code></a>, а <code>?</code> — через типаж <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html"><code>core::fmt::Debug</code></a>.
Если забыть указать <code>%</code> или <code>?</code> — возникнет ошибка, говорящая, что для типа не реализован типаж <a href="../../doc/tracing/trait.Value.html"><code>tracing::Value</code></a>:</p>
<pre><code class="language-console">error[E0277]: the trait bound `PageAllocator: Value` is not satisfied
  --&gt; src/memory/page_allocator.rs:82:17
   |
82 |                 trace!(page_allocator = self, size, page_count, ?block, &quot;allocate pages&quot;);
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Value` is not implemented for `PageAllocator`
   |
   = note: required because of the requirements on the impl of `Value` for `&amp;mut PageAllocator`
   = note: required for the cast to the object type `dyn Value`
   = note: this error originates in the macro `$crate::valueset` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0277`.
</code></pre>
<p>Если же тип не реализует запрошенный через <code>%</code> или <code>?</code> типаж, возникнет похожая ошибка, но уже про типаж <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html"><code>Display</code></a> или <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html"><code>Debug</code></a>:</p>
<pre><code class="language-console">error[E0277]: `PageAllocator` doesn't implement `Display`
  --&gt; src/memory/page_allocator.rs:82:17
   |
82 |                 trace!(page_allocator = %self, size, page_count, ?block, &quot;allocate pages&quot;);
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `PageAllocator` cannot be formatted with the default formatter
   |
   = help: the trait `Display` is not implemented for `PageAllocator`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
   = note: required because of the requirements on the impl of `Display` for `&amp;mut PageAllocator`
   = note: 1 redundant requirements hidden
   = note: required because of the requirements on the impl of `Display` for `&amp;&amp;mut PageAllocator`
   = note: required because of the requirements on the impl of `Value` for `DisplayValue&lt;&amp;&amp;mut PageAllocator&gt;`
   = note: required for the cast to the object type `dyn Value`
   = note: this error originates in the macro `$crate::valueset` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0277`.
</code></pre>
<p>Самый простой способ это починить, — использовать <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html"><code>Debug</code></a> с автоматической реализацией через макрос <code>derive</code> в месте объявления типа, например:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct PageAllocator {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Это потребует реализацию <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html"><code>Debug</code></a> от всех полей структуры, которую при необходимости можно добавить аналогичным способом в местах объявления типов полей.</p>
<p><a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html"><code>Display</code></a>
тоже можно реализовать с помощью атрибута <code>#[derive(Display)]</code> из внешней библиотеки
<a href="https://docs.rs/derive_more/0.99.16/derive_more/">derive_more</a>,
при этом можно указать
<a href="https://jeltef.github.io/derive_more/derive_more/display.html">формат печати</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use derive_more::Display;
...
#[derive(Display)]
#[display(fmt = &quot;{:04}-{:02}-{:02} {:02}:{:02}:{:02}&quot;, year, month, day, hour, minute, second)]
struct Date {
    year: u16,
    month: u8,
    day: u8,
    hour: u8,
    minute: u8,
    second: u8,
}
<span class="boring">}
</span></code></pre></pre>
<p>Также можно реализовать <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html"><code>Debug</code></a> или <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html"><code>Display</code></a> вручную, например:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl fmt::Display for Size {
    fn fmt(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match NumberPrefix::binary(self.size() as f64) {
            NumberPrefix::Standalone(_) =&gt; {
                write!(formatter, &quot;{} B&quot;, self.size())
            }
            NumberPrefix::Prefixed(prefix, value) =&gt; {
                write!(formatter, &quot;{:.3} {}B&quot;, value, prefix.symbol())
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Эта реализация объясняет почему размеры в записи лога имели суффиксы <code>TiB</code>: <code>... block = [2.000 TiB, 128.000 TiB), size 126.000 TiB</code>.</p>
<p>Поменять глобальный уровень логирования можно в самом конце файла <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/log.rs"><code>kernel/src/log.rs</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static LOG_COLLECTOR: ... = LogCollector::new(..., Level::INFO);
<span class="boring">}
</span></code></pre></pre>
<p>Другие примеры использования можно посмотреть в документации tracing, например <a href="../../doc/tracing/macro.info.html#examples">для <code>info!()</code></a>.
Рядом есть и <a href="../../doc/tracing/index.html#using-the-macros">более подробная документация по синтаксису макросов логирования</a>.</p>
<blockquote>
<h3 id="Характеристики-логирования"><a class="header" href="#Характеристики-логирования">Характеристики логирования</a></h3>
<p>Логирование в Nikka:</p>
<ul>
<li>унифицированное между <a href="https://en.wikipedia.org/wiki/User_space_and_kernel_space">ядром и кодом пользователя</a>;</li>
<li>структурированное;</li>
<li>с гарантированной доставкой;</li>
<li>асинхронное для кода режима пользователя.</li>
</ul>
<h4 id="Унифицированное-между-ядром-и-кодом-пользователя"><a class="header" href="#Унифицированное-между-ядром-и-кодом-пользователя">Унифицированное между ядром и кодом пользователя</a></h4>
<p>И в ядре и в пространстве пользователя доступны одни и те же макросы для логирования из библиотеки
<a href="https://docs.rs/tracing/">tracing</a>.
В ядре за их работу отвечает модуль
<a href="../../doc/kernel/log/index.html"><code>kernel::log</code></a> в директории <code>kernel/src/log</code>.
А в пространстве пользователя — модуль
<a href="../../doc/ku/log/index.html"><code>ku::log</code></a> в директории <code>ku/src/log</code>.</p>
<h4 id="Структурированное"><a class="header" href="#Структурированное">Структурированное</a></h4>
<p>Логирование структурированное.
То есть записывается не строчка произвольного формата с интерполированными внутрь неё
значениями переменных.
А отдельно строковое сообщение, и отдельно каждая переменная.
В уже рассматривавшемся примере</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>info!(..., free_page_count, ...);
<span class="boring">}
</span></code></pre></pre>
<p>логирование не знает смысл поля <code>free_page_count</code>, но оно знает его имя и тип.
Даже если сообщение пришло от процесса пользователя, а не из ядра.</p>
<p>Этим такое логирование отличается от системных вызовов в Unix–подобных системах.
Системные вызовы
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/pwrite.html">семейства <code>write</code></a>
при записи в консоль и системный вызов для логирования в общесистемный лог
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/syslog.html"><code>syslog</code></a>
работают с неструктурированной информацией.
В результате чтобы что-то найти в логе программы или в системном логе,
нужно искать по неструктурированному тексту сложными регулярками
и иногда даже парсить его отдельной утилитой.
Например, представьте себе регулярку, задающую диапазон времени,
начинающийся за несколько секунд до полуночи и заканчивающийся через несколько секунд после неё.</p>
<h4 id="С-гарантированной-доставкой"><a class="header" href="#С-гарантированной-доставкой">С гарантированной доставкой</a></h4>
<p>Программы обычно не пишут в консоль напрямую системными вызовами,
а используют библиотечные функции.
Эти функции буферизируют запись в
<a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_output_(stdout)"><code>stdout</code></a>
и не буферизируют запись в
<a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)"><code>stderr</code></a>.</p>
<p>Соображения здесь такие:</p>
<ul>
<li>Программа потенциально много пишет в <code>stdout</code>, поэтому на каждый вызов записывающей функции делать системный вызов слишком накладно. Так как системные вызовы работают гораздо медленнее вызовов обычных функций — они требуют дополнительной работы по сохранению и переключению контекста исполнения. Эффективнее накопить большой объём данных в памяти и записать его за один системный вызов. Для принудительного сброса буфера такие библиотеки обычно предоставляют <a href="https://doc.rust-lang.org/std/io/struct.Stdout.html#method.flush">отдельную функцию</a>. При корректном завершении программы, буфер сбрасывается автоматически из деструктора. А вот при аварийном завершении его содержимое может быть потеряно.</li>
<li>Хорошая программа пишет в <code>stderr</code> только сообщения об ошибках. А их должно быть мало по сравнению с обрабатываемыми программой данными. Поэтому в <code>stderr</code> можно позволить себе писать неэффективно. Зато, если вдруг программа упадёт, сообщения об ошибках будут надёжно записаны в консоль. И есть надежда, что они объяснят падение программы. Если бы запись в <code>stderr</code> была буферизованная, то последние сообщения об ошибках остались бы только в памяти падающей программы, и ни ядро, ни человек их бы уже не увидели.</li>
</ul>
<p>В Nikka при логировании выбран подход, который совмещает эффективность и гарантированную доставку сообщений.
Для этого буфер под логирования не скрыт в недрах прикладной библиотеки, а известен ядру.
И при падении программы ядро берёт на себя обязанность доставить все сохранившиеся в этом буфере лог–записи.</p>
<h4 id="Асинхронное-для-кода-режима-пользователя"><a class="header" href="#Асинхронное-для-кода-режима-пользователя">Асинхронное для кода режима пользователя</a></h4>
<p>Более того, за счёт того что ядро знает буфер логирования приложения,
оно доставляет сообщения из него при каждом переключении в режим ядра.
Это позволяет приложению писать в лог вообще без системных вызовов.
Доставка сообщений при этом выполняется асинхронно с исполнением кода самого приложения.
В Unix–подобных системах собственно запись накопленного буфера
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/pwrite.html">системными вызовами семейства <code>write</code></a>
и запись в общесистемный лог
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/syslog.html"><code>syslog</code></a>
требует синхронного ожидания, пока ядро не обработает эту запись.</p>
<p>Асинхронность доставки сообщения нарушается только в момент исчерпания буфера.
Если модуль
<a href="../../doc/ku/log/index.html"><code>ku::log</code></a>
не сможет сохранить в буфер очередную запись из-за того что буфер переполнился,
он отдаст управление ядру системным вызовом
<a href="../../doc/lib/syscall/fn.sched_yield.html"><code>lib::syscall::sched_yield()</code></a>.
И попробует сохранить запись в буфер ещё раз по возвращению управления процессу из ядра,
считая что ядро полностью обработало и очистило буфер.
Если же запись просто слишком большая и не помещается даже в пустой буфер,
<a href="../../doc/ku/log/index.html"><code>ku::log</code></a>
запишет часть такой записи и залогирует своё, служебное, сообщение.
В нём будет предупреждение, что пользовательская запись была частично утрачена.</p>
<blockquote>
<h4 id="Оборотная-сторона"><a class="header" href="#Оборотная-сторона">Оборотная сторона</a></h4>
<p>Подумайте, к каким проблемам приводит такая организация логирования.</p>
</blockquote>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Настройка-vscode"><a class="header" href="#Настройка-vscode">Настройка VSCode</a></h2>
<p>Для работы в VSCode нужно установить два плагина.</p>
<ol>
<li><a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">rust-analyzer</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">CodeLLDB</a></li>
</ol>
<p>После этого нужно открыть репозиторий <code>File -&gt; Open Folder</code>.</p>
<p>VSCode поддерживает отладку ядра. Чтобы запустить отладку, нужно поставить breakpoint в интерфейсе редактора кода, перейти в <code>Run and Debug</code> (иконка с жуком слева), выбрать конфигурацию запуска и нажать на иконку <code>Start Debugging</code>.</p>
<p><img src="./0-intro-7-breakpoint.png" alt="break" />
<img src="./0-intro-7-debug.png" alt="debug" />
<img src="./0-intro-7-config.png" alt="config" />
<img src="./0-intro-7-run.png" alt="run" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Время"><a class="header" href="#Время">Время</a></h2>
<p>В этой лабораторке нужно будет реализовать работу со временем в операционной системе Nikka.
Лабораторка вводная, предназначена для ознакомления с системой и предварительной оценки своих сил.
Кода потребуется написать немного.
Кроме того, этот код не будет необходим для выполнения последующих лабораторок.
Все задачи в этот раз необязательные и независимы между собой.
Но, если вы их выполните, в дальнейшем вам будет доступно системное время.
Что как минимум приятно при изучении логов.</p>
<p>В этом описании вы встретите много разных специфичных вещей.
<a href="https://en.wikipedia.org/wiki/Interrupt">Прерывания</a>,
<a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter"><code>RDTSC</code></a>,
<a href="https://doc.rust-lang.org/nightly/core/sync/atomic/index.html">атомарные переменные</a>,
<a href="https://en.wikipedia.org/wiki/Non-blocking_algorithm">неблокирующая синхронизация</a>,
спецификации аппаратного обеспечения, и т.д.
Не пугайтесь, предварительных знаний не должно потребоваться.
Они упоминаются на тот случай,
если вы уже хорошо знаете базовую часть материала или же захотите углубиться в какую-либо из таких областей.
Это может оказаться очень увлекательно!
Большие блоки интересного, но не обязательного материала выделены цветом, точно так же как цитаты:</p>
<blockquote>
<p>Time is an illusion. Lunchtime doubly so.</p>
<ul>
<li>Douglas Adams, The Hitchhiker’s Guide to the Galaxy</li>
</ul>
</blockquote>
<p>В современном компьютере есть несколько источников времени с разными характеристиками.
Мы познакомимся с парой из них и сделаем комбинированное по их характеристикам <a href="https://en.wikipedia.org/wiki/System_time">системное время</a>.
А именно, из часов, показывающих время в реальном мире и имеющих низкое — секундное — разрешение,
и источника времени с высоким разрешением, но не привязанного ко времени в реальном мире,
построим часы, показывающие время в реальном мире с высоким разрешением.</p>
<h3 id="Код-работы-со-временем-в-nikka-собран-в-модули"><a class="header" href="#Код-работы-со-временем-в-nikka-собран-в-модули">Код работы со временем в Nikka собран в модули</a></h3>
<ul>
<li>
<p><a href="../../doc/kernel/time/index.html"><code>kernel::time</code></a> в директории <code>kernel/src/time</code>. Здесь находится часть работы со временем, которая происходит только в ядре.</p>
<ul>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/time/mod.rs"><code>kernel/src/time/mod.rs</code></a> — корневая часть модуля <a href="../../doc/kernel/time/index.html"><code>kernel::time</code></a>.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/time/pit8254.rs"><code>kernel/src/time/pit8254.rs</code></a> — драйвер устаревшего таймера <a href="https://en.wikipedia.org/wiki/Intel_8253">Intel 8253/8254</a> (<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">programmable interval timer, PIT</a>). Не представляет большого интереса, так как в последующих лабораторках <a href="../../lab/book/4-concurrency-1-smp-1-local-apic.html#%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-1--%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B-%D1%81-localapic">мы настроим</a> более современный <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller#APIC_timer">таймер в APIC</a>.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/time/rtc.rs"><code>kernel/src/time/rtc.rs</code></a> — драйвер <a href="https://en.wikipedia.org/wiki/Real-time_clock">часов реального времени</a>. Они обычно условно независимы по питанию, так как снабжены <a href="https://en.wikipedia.org/wiki/Nonvolatile_BIOS_memory#CMOS_battery">батарейкой</a>. Отслеживают дату и время в реальном мире с точностью до секунды.</li>
</ul>
</li>
<li>
<p><a href="../../doc/ku/time/index.html"><code>ku::time</code></a> в директории <code>ku/src/time</code>. Здесь собраны базовые примитивы для работы со временем, которые нужны и в ядре, и в пространстве пользователя.</p>
<ul>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/time/mod.rs"><code>ku/src/time/mod.rs</code></a> — корневая часть модуля <a href="../../doc/ku/time/index.html"><code>ku::time</code></a>. Содержит:
<ul>
<li>Функцию <a href="../../doc/ku/time/fn.timer.html"><code>ku::time::timer()</code></a> для получения монотонного процессорного времени, которое измеряется его тактами.</li>
<li>Функции <a href="../../doc/ku/time/fn.datetime.html"><code>ku::time::datetime()</code></a> и <a href="../../doc/ku/time/fn.datetime_ms.html"><code>ku::time::datetime_ms()</code></a>, которые переводят значение счётчика тактов процессора в системное время с разрешением в наносекунды и миллисекунды соответственно.</li>
<li>Функции <a href="../../doc/ku/time/fn.now.html"><code>ku::time::now()</code></a> и <a href="../../doc/ku/time/fn.now_ms.html"><code>ku::time::now_ms()</code></a>, которые сообщают системное время в текущий момент с разрешением в наносекунды и миллисекунды соответственно.</li>
</ul>
</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/time/correlation_point.rs"><code>ku/src/time/correlation_point.rs</code></a> — вспомогательные структуры <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>ku::time::correlation_point::AtomicCorrelationPoint</code></a> и <a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html"><code>ku::time::correlation_point::CorrelationPoint</code></a> для привязки тактов процессора к другому источнику времени, в один момент времени.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/time/correlation_interval.rs"><code>ku/src/time/correlation_interval.rs</code></a> — вспомогательные структуры <a href="../../doc/ku/time/correlation_interval/struct.AtomicCorrelationInterval.html"><code>ku::time::correlation_interval::AtomicCorrelationInterval</code></a> и <a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html"><code>ku::time::correlation_interval::CorrelationInterval</code></a> для соотнесения частоты процессора с частотой другого источника времени по двум моментам времени.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/time/hz.rs"><code>ku/src/time/hz.rs</code></a> — вспомогательная структура <a href="../../doc/ku/time/hz/struct.Hz.html"><code>ku::time::hz::Hz</code></a> для форматирования <a href="https://en.wikipedia.org/wiki/Hertz">частоты</a> при логировании.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/time/rtc.rs"><code>ku/src/time/rtc.rs</code></a> — <a href="https://en.wikipedia.org/wiki/Singleton_pattern">синглтон</a> <a href="../../doc/ku/time/rtc/struct.Rtc.html"><code>ku::time::rtc::Rtc</code></a>, позволяющий узнать показания часов реального времени как из ядра, так и из <a href="https://en.wikipedia.org/wiki/User_space_and_kernel_space">пространства пользователя</a>.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/time/tsc.rs"><code>ku/src/time/tsc.rs</code></a> — структура <a href="../../doc/ku/time/tsc/struct.Tsc.html"><code>ku::time::tsc::Tsc</code></a> для хранения показаний счётчика тактов процессора, который является одним из источников времени в компьютере. А также структура <a href="../../doc/ku/time/tsc/struct.TscDuration.html"><code>ku::time::tsc::TscDuration</code></a> для хранения интервалов времени в тактах процессора.</li>
</ul>
</li>
</ul>
<h3 id="Ориентировочный-объём-работ-этой-лабораторки"><a class="header" href="#Ориентировочный-объём-работ-этой-лабораторки">Ориентировочный объём работ этой лабораторки</a></h3>
<p>Засеките время, которое вы потратите на каждую из задач этой лабораторки.
Тогда с помощью этой статистики, и аналогичных статистик в последующих лабораторках,
вы сможете оценить порядок времени, который вам понадобится на решение задач в них.
В процессе решения задач в следующих лабораторках также стоит засекать время,
чтобы контролировать ошибку такой оценки и корректировать её с учётом новых данных.</p>
<pre><code class="language-console"> kernel/src/time/rtc.rs              |   65 ++++++++++++++++++++++++++++++++----
 ku/src/time/correlation_interval.rs |   26 +++++++++++++-
 ku/src/time/correlation_point.rs    |   40 +++++++++++++++++-----
 3 files changed, 115 insertions(+), 16 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Часы-реального-времени"><a class="header" href="#Часы-реального-времени">Часы реального времени</a></h2>
<p>Краткое описание возможностей микросхемы RTC и её низкоуровневого интерфейса можно посмотреть в статьях
<a href="https://wiki.osdev.org/RTC">RTC</a> и <a href="https://wiki.osdev.org/CMOS">CMOS</a>
на сайте <a href="https://wiki.osdev.org/">OSDev.org</a>.
Подробное описание есть в
<a href="https://pdf1.alldatasheet.com/datasheet-pdf/view/122156/MOTOROLA/MC146818.html">спецификации микросхемы Motorola MC146818</a>.
Современные микросхемы RTC поддерживают совместимость с ней.</p>
<p>Прежде всего напишем драйвер для работы с микросхемой
<a href="https://en.wikipedia.org/wiki/Real-time_clock">часов реального времени (Real-time clock, RTC)</a>.
Основная работа с RTC собрана в модуле
<a href="../../doc/kernel/time/rtc/index.html"><code>kernel::time::rtc</code></a>,
который находится в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/time/rtc.rs"><code>kernel/src/time/rtc.rs</code></a>.</p>
<h3 id="Порты-вводавывода"><a class="header" href="#Порты-вводавывода">Порты ввода–вывода</a></h3>
<p>Взаимодействие процессора с устройствами называется <a href="https://en.wikipedia.org/wiki/Input/output">вводом–выводом</a> (input/output, I/O, IO).
В <a href="https://en.wikipedia.org/wiki/X86-64">x86-64</a> этот процесс
осуществляется одним из двух механизмов, в зависимости от устройства:</p>
<ul>
<li>Через <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%80%D1%82_%D0%B2%D0%B2%D0%BE%D0%B4%D0%B0-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B0">порты ввода–вывода</a> (<a href="https://wiki.osdev.org/I/O_Ports">I/O port</a>, <a href="https://wiki.osdev.org/Port_IO">Port I/O</a>).</li>
<li>Через специально выделенные диапазоны адресов памяти. Это называется <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">ввод–вывод через память</a>. При этом собственно микросхемы памяти не задействуются, то есть термин немного не точен. Адреса ввода–вывода перехватываются другими устройствами, подключённым к <a href="https://en.wikipedia.org/wiki/System_bus">системной шине</a>.</li>
</ul>
<p>Порты в x86-64 в основном используются для старых устройств,
новые чаще используют ввод–вывод через память.
В частности, микросхема RTC появилась в архитектуре x86-64 давно и использует порты ввода–вывода.
Поэтому с ними мы немного столкнёмся в этой лабораторке.
Не нужно пугаться от того как страшненько выглядит интерфейс ввода–вывода через порты —
это просто наслоения легаси, экономии всего в ранних моделях компьютеров, и обратной совместимости с ними.</p>
<p>А вот новый контроллер прерываний
<a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">APIC</a>
появился относительно недавно, вместе с многопроцессорностью.
Он использует ввод–вывод через память, с которым мы тоже поработаем.
Но в <a href="4-concurrency-1-smp-1-local-apic.html">будущей лабораторке</a>.</p>
<p>Порты ввода–вывода в x86-64 составляют пространство с 16–битными номерами от <code>0x0000</code> до <code>0xFFFF</code>.
Они могут быть одно-, двух- и четырёхбайтовыми.
Это определяется командой процессора, которая используется при чтении или записи.
И дополнительно ограничивается натуральным выравниванием номеров.
Например, порт <code>0x0001</code> может быть только однобайтовым.
А порт <code>0x0002</code> может быть либо однобайтовым, либо двухбайтовым в зависимости от используемой инструкции обращения к нему.
Во втором случае он объединяет однобайтовые порты <code>0x0002</code> и <code>0x0003</code>.
То есть,  порты похожи на байты памяти, только другое пространство номеров и другие инструкции доступа.</p>
<p>В старые добрые времена часто экономили номера портов.
Для этого ограничивали количество портов, через которые можно получить доступ к устройству.
И одни и те же порты отвечали за разные функции, в зависимости от обстоятельств.
Например, на чтение порт мог работать совсем не так, как на запись.
То есть, формат записываемых в порт данных мог отличаться от формата считываемых — один и тот же бит имел разный смысл.</p>
<p>Другой подход состоял в мультиплексировании.
То есть, один порт использовался для выбора, что будут означать данные читаемые или записываемые в другой порт.
Так, с помощью всего двух портов, можно было эмулировать набор нескольких.
В микросхеме RTC применена разновидность этого подхода.
А именно, в самой микросхеме есть целый блок собственной памяти, часть которой выделена под её управляющие регистры:</p>
<ul>
<li>10 байт под данные даты, времени и будильника.</li>
<li>4 байта под управляющие регистры микросхемы.</li>
<li>Ещё <a href="https://wiki.osdev.org/CMOS">50 байт энергонезависимой памяти</a>, которые <a href="https://en.wikipedia.org/wiki/BIOS">BIOS</a> использует под нужды не связанные с RTC.</li>
</ul>
<p>Доступ к этому блоку внутренней памяти микросхемы RTC осуществляется всего через два однобайтовых порта.
Первым шагом в порт номер
<a href="../../doc/kernel/time/rtc/constant.ADDRESS_PORT.html"><code>kernel::time::rtc::ADDRESS_PORT = 0x0070</code></a>
записывается номер байта внутренней памяти микросхемы RTC.
Вторым шагом либо из порта номер
<a href="../../doc/kernel/time/rtc/constant.DATA_PORT.html"><code>kernel::time::rtc::DATA_PORT = 0x0071</code></a>
читается значение, которое находится в этом байте внутренней памяти микросхемы RTC.
Либо в этот порт записывается значение, которое нужно сохранить в память RTC.</p>
<p>Это делают функции
<a href="../../doc/kernel/time/rtc/fn.rtc_read.html"><code>kernel::time::rtc::rtc_read()</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn rtc_read(address: u8) -&gt; u8 {
    unsafe {
        io::outb(ADDRESS_PORT, address);
        io::inb(DATA_PORT)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>И
<a href="../../doc/kernel/time/rtc/fn.rtc_read.html"><code>kernel::time::rtc::rtc_write()</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn rtc_write(address: u8, data: u8) {
    unsafe {
        io::outb(ADDRESS_PORT, address);
        io::outb(DATA_PORT, data);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Для чтения и записи собственно в порты ввода–вывода они используют однобайтовые инструкции <code>INB</code> и <code>OUTB</code>,
обёрнутые в функции
<a href="../../doc/x86/io/fn.inb.html"><code>x86::io::inb()</code></a> и
<a href="../../doc/x86/io/fn.outb.html"><code>x86::io::outb()</code></a>
внешней библиотеки <a href="../../doc/x86/index.html"><code>x86</code></a>.</p>
<p>Байты номер <code>0xA</code>, <code>0xB</code>, <code>0xC</code> и <code>0xD</code> в памяти микросхемы отведены под её
<a href="https://en.wikipedia.org/wiki/Device_register">регистры управления</a>.
Смысл их битов вынесен в соответствующие наборы флагов
<a href="../../doc/kernel/time/rtc/struct.RegisterA.html"><code>kernel::time::rtc::RegisterA</code></a>,
<a href="../../doc/kernel/time/rtc/struct.RegisterB.html"><code>kernel::time::rtc::RegisterB</code></a>,
<a href="../../doc/kernel/time/rtc/struct.RegisterC.html"><code>kernel::time::rtc::RegisterC</code></a> и
<a href="../../doc/kernel/time/rtc/struct.RegisterD.html"><code>kernel::time::rtc::RegisterD</code></a>.</p>
<h3 id="Прерывания"><a class="header" href="#Прерывания">Прерывания</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Interrupt">Прерывание</a> — это событие, которое останавливает текущую активность
процессора и заставляет его переключиться на выполнение специального кода обработки возникшего прерывания.
Прерывания происходят:</p>
<ul>
<li>Либо асинхронно, в произвольный момент с точки зрения текущего исполняющегося кода. Обычно — когда оборудование требует от процессора внимания.</li>
<li>Либо синхронно, на фиксированной инструкции исполняющегося кода. Обычно, если возникла особая ситуация при выполнении текущего кода.
<ul>
<li>Это может быть ошибка в программе. Например, деление на ноль или <a href="https://en.wikipedia.org/wiki/Page_fault">недопустимое обращение к памяти (Page Fault)</a>.</li>
<li>А может быть предусмотренное действие. Например, чтобы из режима пользователя переключиться в режим ядра для выполнения <a href="https://en.wikipedia.org/wiki/System_call">системного вызова</a>, такого как чтение файла.</li>
</ul>
</li>
</ul>
<p>За настройки прерываний отвечает функция
<a href="../../doc/kernel/interrupts/fn.init.html"><code>kernel::interrupts::init()</code></a>
в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/interrupts.rs"><code>kernel/src/interrupts.rs</code></a>.
Она инициализирует таблицу обработчиков прерываний
<a href="../../doc/kernel/interrupts/struct.IDT.html"><code>kernel::interrupts::IDT</code></a>
находящимися в том же файле функциями.
Для RTC выделен номер прерывания
<a href="../../doc/kernel/interrupts/constant.RTC.html"><code>kernel::interrupts::RTC</code></a>,
а его обработчик — функция
<a href="../../doc/kernel/interrupts/fn.rtc.html"><code>kernel::interrupts::rtc()</code></a>.</p>
<p>Она помечена как <a href="https://github.com/rust-lang/rust/issues/40180"><code>extern &quot;x86-interrupt&quot;</code></a>,
поэтому Rust знает что это обработчик прерывания.
То есть, — код, который может запуститься в произвольный момент
времени и прервать исполняющийся в этот момент обычный код.
Поэтому компилятор сохраняет все нужные регистры на стек при входе в функцию
<a href="../../doc/kernel/interrupts/fn.rtc.html"><code>kernel::interrupts::rtc()</code></a>.
Есть надежда, что он достаточно умён, и сохранит на стек только те регистры,
которые реально используются кодом обработчика прерываний.
А не вообще все регистры процессора, как сделали бы мы, если бы сохраняли регистры вручную.</p>
<h3 id="Инициализация-микросхемы-часов-реального-времени"><a class="header" href="#Инициализация-микросхемы-часов-реального-времени">Инициализация микросхемы часов реального времени</a></h3>
<p>Функция
<a href="../../doc/kernel/time/rtc/fn.init.html"><code>kernel::time::rtc::init()</code></a>
выполняет инициализацию микросхемы:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>interrupts::without_interrupts(|| {
    defer! {
        rtc_read(!DISABLE_NMI | REGISTER_B);
    }

    old_settings = RegisterB::from_bits(rtc_read(DISABLE_NMI | REGISTER_B)).unwrap();
    new_settings =
        (old_settings &amp; !RegisterB::DAYLIGHT_SAVING) | RegisterB::UPDATE_ENDED_INTERRUPT;
    rtc_write(DISABLE_NMI | REGISTER_B, new_settings.bits());
    acknowledged_settings = RegisterB::from_bits(rtc_read(DISABLE_NMI | REGISTER_B)).unwrap();

    SETTINGS.store(acknowledged_settings.bits(), Ordering::Relaxed);
});
<span class="boring">}
</span></code></pre></pre>
<p>То есть, она</p>
<ul>
<li>Выключает все <a href="https://en.wikipedia.org/wiki/Interrupt">прерывания</a>, в том числе <a href="https://en.wikipedia.org/wiki/Non-maskable_interrupt">немаскируемые</a>, на время конфигурирования микросхемы. Иначе она может остаться в <a href="https://wiki.osdev.org/RTC#Avoiding_NMI_and_Other_Interrupts_While_Programming">некоррекном состоянии</a>.</li>
<li>Выключает переход на летнее время — <code>!</code><a href="../../doc/kernel/time/rtc/struct.RegisterB.html#associatedconstant.DAYLIGHT_SAVING"><code>RegisterB::DAYLIGHT_SAVING</code></a>.</li>
<li>Включает <a href="https://en.wikipedia.org/wiki/Interrupt">прерывание</a>, посылаемое процессору микросхемой после обновления показаний времени при тике, — <a href="../../doc/kernel/time/rtc/struct.RegisterB.html#associatedconstant.UPDATE_ENDED_INTERRUPT"><code>RegisterB::UPDATE_ENDED_INTERRUPT</code></a>.</li>
<li>Остальные настройки оставляет без изменений.</li>
</ul>
<p>Далее <a href="../../doc/kernel/time/rtc/fn.init.html"><code>rtc::init()</code></a>:</p>
<ul>
<li>Сохраняет конфигурацию микросхемы в глобальной переменной <a href="../../doc/kernel/time/rtc/static.SETTINGS.html"><code>kernel::time::rtc::SETTINGS</code></a>.</li>
<li>Проверяет что микросхема подтвердила изменение конфигурации.</li>
<li>Читает текущие показания времени из микросхемы.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>SETTINGS.store(acknowledged_settings.bits(), Ordering::Relaxed);

if acknowledged_settings == new_settings {
    let rtc = SYSTEM_INFO.rtc();
    rtc.store_prev(CorrelationPoint::invalid(
        timestamp().unwrap_or(0) * TICKS_PER_SECOND,
    ));

    enable_next_interrupt();

    if is_time_valid() {
        info!(?acknowledged_settings, &quot;RTC init&quot;);
    } else {
        error!(&quot;RTC reports low battery, its time and date values are incorrect&quot;);
    }
} else {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Количество тиков в секунду —
<a href="../../doc/ku/time/rtc/constant.TICKS_PER_SECOND.html"><code>ku::time::rtc::TICKS_PER_SECOND</code></a> —
для RTC равно 1.
Про то, что такое
<a href="../../doc/ku/info/static.SYSTEM_INFO.html"><code>ku::info::SYSTEM_INFO</code></a> и
<a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html"><code>ku::time::correlation_point::CorrelationPoint</code></a>
узнаем чуть позже.</p>
<p>Микросхема RTC выдаёт текущее время, разбитое на компоненты — год, месяц, день, час, минута, секунда.
Оно переводится в
<a href="https://en.wikipedia.org/wiki/Unix_time">секунды с момента начала Unix–эпохи</a>
функцией
<a href="../../doc/kernel/time/rtc/fn.timestamp.html"><code>kernel::time::rtc::timestamp()</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn timestamp() -&gt; Option&lt;i64&gt; {
    Date::read().map(|date| DateTime::&lt;Utc&gt;::from_utc(date.into(), Utc).timestamp())
}
<span class="boring">}
</span></code></pre></pre>
<p>В ней используется внешняя библиотека
<a href="../../doc/chrono/index.html"><code>chrono</code></a>,
которая реализует работу со временем и календарём.</p>
<p>При этом код считает, что микросхема RTC хранит
<a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time">всемирное координированное время (Coordinated Universal Time, UTC)</a>.
Это так в тестах, которые запускают Nikka в эмуляторе <a href="https://en.wikipedia.org/wiki/QEMU"><code>qemu</code></a>.
По умолчанию в <a href="https://en.wikipedia.org/wiki/QEMU"><code>qemu</code></a> используется UTC.</p>
<p>Функция <a href="../../doc/kernel/time/rtc/fn.enable_next_interrupt.html"><code>enable_next_interrupt()</code></a>
говорит микросхеме RTC, что процессор обработал
<a href="https://en.wikipedia.org/wiki/Interrupt">прерывание</a> от неё.
Пока процессор этого не сделает, микросхема не пошлёт следующее прерывание,
считая что процессор ещё занят обработкой предыдущего.
То есть, если забыть это сделать, то “время остановится”.
Такой сигнал оборудованию от процессора иногда называется
<a href="https://en.wikipedia.org/wiki/End_of_interrupt">end of interrupt (EOI)</a>.
Он встречается не только для RTC, но и для другого оборудования.
Например, контроллер прерываний можно сконфигурировать так,
чтобы он тоже ждал от процессора подтверждения каждого прерывания.
Посылать EOI соответствующему оборудованию нужно из каждого прерывания.
Мы также посылаем его один раз при инициализации микросхемы RTC —
на всякий случай стоит перевести микросхему в определённое состояние.
Кроме того, возможно она уже успела послать прерывание до того как ядро инициализировало их обработку.
Тогда мы его потеряли, но должны разблокировать последующие.
В частном случае микросхемы RTC, отправка ей EOI и чтение её регистра статуса прерывания функцией
<a href="../../doc/kernel/time/rtc/fn.interrupt_status.html"><code>interrupt_status()</code></a>, —
это одно и то же действие:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn enable_next_interrupt() {
    interrupt_status();
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="Задача-1--чтение-реального-времени-из-микросхемы-rtc"><a class="header" href="#Задача-1--чтение-реального-времени-из-микросхемы-rtc">Задача 1 — чтение реального времени из микросхемы RTC</a></h3>
<h4 id="Неконсистентное-чтение-даты-и-времени-из-микросхемы-rtc"><a class="header" href="#Неконсистентное-чтение-даты-и-времени-из-микросхемы-rtc">Неконсистентное чтение даты и времени из микросхемы RTC</a></h4>
<p>Реализуйте статический <a href="../../doc/kernel/time/rtc/struct.Date.html#method.read_inconsistent">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Date::read_inconsistent() -&gt; Date
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/time/rtc.rs"><code>kernel/src/time/rtc.rs</code></a>,
который считывает из микросхемы RTC показания даты и времени и возвращает их в виде
<a href="../../doc/kernel/time/rtc/struct.Date.html">структуры</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, Default, Display, Eq, PartialEq)]
#[display(
    fmt = &quot;{:04}-{:02}-{:02} {:02}:{:02}:{:02}&quot;,
    year,
    month,
    day,
    hour,
    minute,
    second
)]
struct Date {
    year: u16,
    month: u8,
    day: u8,
    hour: u8,
    minute: u8,
    second: u8,
}
<span class="boring">}
</span></code></pre></pre>
<p>Метод называется <code>...inconsistent()</code>, потому что может вернуть некорректное значение
<a href="../../doc/kernel/time/rtc/struct.Date.html"><code>Date</code></a>,
если во время его работы произошёл тик RTC и микросхема конкурентно
обновляла содержимое соответствующих полей в своей памяти.</p>
<p>Реализуйте и используйте вспомогательный <a href="../../doc/kernel/time/rtc/fn.parse_value.html">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn kernel::time::rtc::parse_value(
    x: u8,
    format: RegisterB,
) -&gt; u8
<span class="boring">}
</span></code></pre></pre>
<p>Он переводит значение <code>x</code> из формата, в котором микросхема хранит время в двоичный.
Дело в том, что время может храниться как в обычном
<a href="https://en.wikipedia.org/wiki/Binary_number">двоичном коде</a>,
если в <code>format</code> установлен флаг
<a href="../../doc/kernel/time/rtc/struct.RegisterB.html#associatedconstant.USE_BINARY_FORMAT"><code>RegisterB::USE_BINARY_FORMAT</code></a>.
Так и в <a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">двоично–десятичном</a>, если этот флаг не установлен.</p>
<p>Реализуйте и используйте вспомогательный <a href="../../doc/kernel/time/rtc/fn.parse_hour.html">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn kernel::time::rtc::parse_hour(
    hour: u8,
    format: RegisterB,
) -&gt; u8
<span class="boring">}
</span></code></pre></pre>
<p>Он переводит значение текущего часа <code>hour</code> из формата, в котором микросхема хранит время в двоичный 24-часовой.
Кроме <a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">двоично–десятичного</a> варианта, тут возможен ещё и
<a href="https://en.wikipedia.org/wiki/12-hour_clock">12-часовой формат</a>.
Если в <code>format</code> установлен бит
<a href="../../doc/kernel/time/rtc/struct.RegisterB.html#associatedconstant.USE_24_HOUR_FORMAT"><code>RegisterB::USE_24_HOUR_FORMAT</code></a>,
то формат времени <a href="https://en.wikipedia.org/wiki/24-hour_clock">24-часовой</a>.
Обратите внимание на
<a href="https://en.wikipedia.org/wiki/12-hour_clock#Confusion_at_noon_and_midnight">путаницу в значениях 12am и 12pm</a>
для <a href="https://en.wikipedia.org/wiki/12-hour_clock">12-часового формата</a>.
Наш вариант — “digital watches”.
<a href="https://wiki.osdev.org/CMOS#Format_of_Bytes">Подробнее про формат времени в RTC</a>.</p>
<p>Вам могут пригодиться:</p>
<ul>
<li>Конфигурация микросхемы в глобальной переменной <a href="../../doc/kernel/time/rtc/static.SETTINGS.html"><code>kernel::time::rtc::SETTINGS</code></a>. Из неё можно узнать формат в котором она хранит время.</li>
<li>Функция <a href="../../doc/kernel/time/rtc/fn.rtc_read.html"><code>kernel::time::rtc::rtc_read(address)</code></a>, которая читает из микросхемы один байт <a href="https://doc.rust-lang.org/nightly/core/primitive.u8.html"><code>u8</code></a>, расположенный по адресу <code>address</code> в памяти микросхемы RTC. Адрес <code>address</code> не имеет отношения к основной памяти компьютера, он адресует внутреннюю память микросхемы RTC.</li>
<li><a href="http://www.bioscentral.com/misc/cmosmap.htm">Таблица адресов памяти RTC</a> или её <a href="https://wiki.osdev.org/CMOS#Getting_Current_Date_and_Time_from_RTC">подходящий фрагмент</a>. Либо вы можете найти эту таблицу в первоисточнике — <a href="https://pdf1.alldatasheet.com/datasheet-pdf/view/122156/MOTOROLA/MC146818.html">спецификации микросхемы Motorola MC146818</a>.</li>
<li>Метод <a href="https://doc.rust-lang.org/nightly/core/primitive.u16.html#impl-From%3Cu8%3E-for-u16"><code>u16::from(u8)</code></a> для перевода значения типа <a href="https://doc.rust-lang.org/nightly/core/primitive.u8.html"><code>u8</code></a> в значение типа <a href="https://doc.rust-lang.org/nightly/core/primitive.u16.html"><code>u16</code></a>.</li>
</ul>
<blockquote>
<h5 id="Путаница-в-значениях-12am-и-12pm"><a class="header" href="#Путаница-в-значениях-12am-и-12pm"><a href="https://en.wikipedia.org/wiki/12-hour_clock#Confusion_at_noon_and_midnight">Путаница в значениях 12am и 12pm</a></a></h5>
<p>Функция <a href="../../doc/kernel/time/rtc/fn.parse_hour.html"><code>parse_hour()</code></a>
проверяется тестом <code>different_rtc_formats()</code> в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/1-time-1-rtc.rs"><code>kernel/tests/1-time-1-rtc.rs</code></a>.
Можно вручную убедиться, что тест
<a href="https://en.wikipedia.org/wiki/12-hour_clock#Confusion_at_noon_and_midnight">не путает 12am и 12pm</a>,
а также проверить что вы реализовали <a href="https://en.wikipedia.org/wiki/12-hour_clock">12-ти часовой</a> формат правильно.
Для этого включите 12-ти часовой формат в
<a href="../../doc/kernel/time/rtc/fn.init.html"><code>rtc::init()</code></a>
и установите время, например на <code>11:59:55 am</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>interrupts::without_interrupts(|| {
    // ...

    new_settings =
        (old_settings &amp; !RegisterB::DAYLIGHT_SAVING &amp; !RegisterB::USE_24_HOUR_FORMAT) |
        RegisterB::UPDATE_ENDED_INTERRUPT;

    rtc_write(DISABLE_NMI | REGISTER_B, (new_settings | RegisterB::SET_CLOCK).bits());

    if new_settings.contains(RegisterB::USE_BINARY_FORMAT) {
        rtc_write(4, 11);
        rtc_write(2, 59);
        rtc_write(0, 55);
    } else {
        rtc_write(4, 1 * 16 + 1);
        rtc_write(2, 5 * 16 + 9);
        rtc_write(0, 5 * 16 + 5);
    }

    rtc_write(DISABLE_NMI | REGISTER_B, new_settings.bits());
    acknowledged_settings = RegisterB::from_bits(rtc_read(DISABLE_NMI | REGISTER_B)).unwrap();

    // ...
});
<span class="boring">}
</span></code></pre></pre>
<p>После этого запустите</p>
<pre><code class="language-console">$ (cd kernel; cargo run)
</code></pre>
<p>В логе время печатается в
<a href="https://en.wikipedia.org/wiki/24-hour_clock">24-часовом</a>
формате, вне зависимости от настроек RTC.
В нём вы увидите как <code>11:59:59</code> сменяется на <code>12:00:00</code>:</p>
<pre><code class="language-console">$ cat kernel/serial.out
...
11:59:59.985 0 D time_precision = 933.673 ns
11:59:59.989 0 D interrupt stats; number = 32; mnemonic = #TI; count = 85
11:59:59.993 0 D interrupt stats; number = 40; mnemonic = #RT; count = 4
12:00:00.001 0 D CPU frequency measured by PIT; frequency = 3.471 GHz
12:00:00.005 0 D CPU frequency measured by RTC; frequency = 3.437 GHz
12:00:00.009 0 D time_precision = 814.689 ns
...
</code></pre>
<p>Если же установить время на <code>11:59:55 pm</code>, то в логе <code>23:59:59</code> сменяется на <code>00:00:00</code>:</p>
<pre><code class="language-console">$ cat kernel/serial.out
...
23:59:59.969 0 D time_precision = 1.375 us
23:59:59.973 0 D interrupt stats; number = 32; mnemonic = #TI; count = 84
23:59:59.979 0 D interrupt stats; number = 40; mnemonic = #RT; count = 4
00:00:00.001 0 D CPU frequency measured by PIT; frequency = 3.471 GHz
00:00:00.005 0 D CPU frequency measured by RTC; frequency = 3.428 GHz
00:00:00.009 0 D time_precision = 1.222 us
...
</code></pre>
<p>При неверной реализации функции
<a href="../../doc/kernel/time/rtc/fn.parse_hour.html"><code>parse_hour()</code></a>
показания времени в логе после перехода через полдень или полночь будут вести себя гораздо интереснее.</p>
<blockquote>
<p>В качестве дополнительного упражнения, посмотрите как 12-часовой формат реализован в Linux.</p>
</blockquote>
</blockquote>
<h4 id="Консистентное-чтение-даты-и-времени-из-микросхемы-rtc"><a class="header" href="#Консистентное-чтение-даты-и-времени-из-микросхемы-rtc">Консистентное чтение даты и времени из микросхемы RTC</a></h4>
<p>Реализуйте статический <a href="../../doc/kernel/time/rtc/struct.Date.html#method.read">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Date::read() -&gt; Option&lt;Date&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Он
<a href="https://wiki.osdev.org/CMOS#RTC_Update_In_Progress">пытается несколько раз прочитать данные из микросхемы RTC</a>
уже реализованным вами методом
<a href="../../doc/kernel/time/rtc/struct.Date.html#method.read_inconsistent"><code>Date::read_inconsistent()</code></a>.
Перед каждым чтением он в цикле ждёт, пока в регистре <code>A</code> микросхемы RTC флаг
<a href="../../doc/kernel/time/rtc/struct.RegisterA.html#associatedconstant.UPDATE_IN_PROGRESS"><code>kernel::time::rtc::RegisterA::UPDATE_IN_PROGRESS</code></a>
установлен, то есть пока микросхема обновляет данные в своей памяти.</p>
<p>Если</p>
<ul>
<li>Два чтения подряд вернут одинаковое значение структуры <a href="../../doc/kernel/time/rtc/struct.Date.html"><code>Date</code></a>.</li>
<li>Перед чтениями флаг <a href="../../doc/kernel/time/rtc/struct.RegisterA.html#associatedconstant.UPDATE_IN_PROGRESS"><code>RegisterA::UPDATE_IN_PROGRESS</code></a> был сброшен.</li>
<li>Предполагаем, что микросхема обновляет поля всегда в одном порядке.</li>
<li>Чтение одного <a href="https://doc.rust-lang.org/nightly/core/primitive.u8.html"><code>u8</code></a> из её памяти атомарно.</li>
</ul>
<p>То можно считать совпавшее значение структуры
<a href="../../doc/kernel/time/rtc/struct.Date.html"><code>Date</code></a>
консистентным и вернуть его,
<a href="https://doc.rust-lang.ru/book/ch06-01-defining-an-enum.html#%D0%9F%D0%B5%D1%80%D0%B5%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-option-%D0%B8-%D0%B5%D0%B3%D0%BE-%D0%BF%D1%80%D0%B5%D0%B8%D0%BC%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B0-%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-null-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC%D0%B8">обернув</a> в
<a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#variant.Some"><code>core::option::Option::Some</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>return Some(date);
<span class="boring">}
</span></code></pre></pre>
<p>Если же за несколько попыток прочитать дважды одинаковые значения
<a href="../../doc/kernel/time/rtc/struct.Date.html"><code>Date</code></a>
не получилось,
стоит сдаться и вернуть
<a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#variant.None"><code>core::option::Option::None</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>return None;
<span class="boring">}
</span></code></pre></pre>
<p>Вам могут пригодиться:</p>
<ul>
<li>Метод <a href="../../doc/kernel/time/rtc/struct.Date.html#method.default"><code>Date::default()</code></a>, который возвращает <a href="../../doc/kernel/time/rtc/struct.Date.html"><code>Date</code></a>, заполненную нулями. Что не соответствует разумной дате настоящего времени.</li>
<li>Функция <a href="https://doc.rust-lang.org/nightly/core/hint/fn.spin_loop.html"><code>core::hint::spin_loop()</code></a>, которая сообщает процессору, что он находится в цикле ожидания внешнего события. И может, например, снизить частоту и энергопотребление.</li>
<li>Операторы равенства <code>==</code> и неравенства <code>!=</code> для <a href="../../doc/kernel/time/rtc/struct.Date.html"><code>Date</code></a>.</li>
</ul>
<p>В этом методе нужно писать код очень внимательно, так как он не покрывается тестами.
А использование в будущем лога с неконсистентной датой при отладке может привести к потере времени.</p>
<blockquote>
<p>Полные пути <code>core::option::Option::</code> можно не указывать, так как <code>Option</code>, <code>None</code>, <code>Some</code> и другие стандартные вещи
импортируются по умолчанию прелюдией
<a href="https://doc.rust-lang.org/nightly/core/prelude/index.html"><code>core::prelude</code></a>.
У нас <a href="https://doc.rust-lang.org/edition-guide/rust-2021/index.html">редакция 2021</a>,
соответствующая прелюдия —
<a href="https://doc.rust-lang.org/nightly/core/prelude/rust_2021/index.html"><code>core::prelude::rust_2021</code></a>.
А она перекладывает основную работу на
<a href="https://doc.rust-lang.org/nightly/core/prelude/v1/index.html"><code>core::prelude::v1</code></a>,
где и импортируются <code>Option</code>, <code>None</code>, <code>Some</code> и многое другое.</p>
<p>Метод <a href="../../doc/kernel/time/rtc/struct.Date.html#method.default"><code>Date::default()</code></a> определён в
<a href="https://doc.rust-lang.ru/book/ch10-02-traits.html">типаже</a>
<a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default"><code>core::default::Default</code></a>,
который реализован для <a href="../../doc/kernel/time/rtc/struct.Date.html"><code>Date</code></a> автоматически за счёт атрибута
<a href="https://doc.rust-lang.ru/book/appendix-03-derivable-traits.html"><code>derive</code></a> —
<a href="https://doc.rust-lang.ru/book/appendix-03-derivable-traits.html#default-%D0%B4%D0%BB%D1%8F-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B9-%D0%BF%D0%BE-%D1%83%D0%BC%D0%BE%D0%BB%D1%87%D0%B0%D0%BD%D0%B8%D1%8E"><code>#[derive(Default)]</code></a>.
Всю соответствующую работу выполняет макрос
<a href="https://doc.rust-lang.org/nightly/core/prelude/v1/macro.derive.html"><code>core::prelude::v1::derive</code></a>.</p>
<p>Операторы равенства и неравенства для <a href="../../doc/kernel/time/rtc/struct.Date.html"><code>Date</code></a> определены в
<a href="https://doc.rust-lang.ru/book/ch10-02-traits.html">типажах</a>
<a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html"><code>core::cmp::PartialEq</code></a> и
<a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html"><code>core::cmp::Eq</code></a>,
которые реализованы для <a href="../../doc/kernel/time/rtc/struct.Date.html"><code>Date</code></a> автоматически за счёт атрибута
<a href="https://doc.rust-lang.ru/book/appendix-03-derivable-traits.html#partialeq-%D0%B8-eq-%D0%B4%D0%BB%D1%8F-%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-%D1%80%D0%B0%D0%B2%D0%B5%D0%BD%D1%81%D1%82%D0%B2%D0%B0"><code>#[derive(..., Eq, PartialEq)]</code></a>.
Типаж <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html"><code>core::cmp::PartialEq</code></a> определяет методы
<a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq"><code>PartialEq::eq()</code></a> и
<a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne"><code>PartialEq::ne()</code></a>
для проверки на равенство или неравенство соответственно.
Rust рассахаривает операторы <code>==</code> и <code>!=</code> в обращения к этим методам.
А дополнительный типаж
<a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html"><code>core::cmp::Eq</code></a>
сигнализирует, что операции <code>PartialEq</code> для
<a href="../../doc/kernel/time/rtc/struct.Date.html"><code>Date</code></a> задают
<a href="https://en.wikipedia.org/wiki/Equivalence_relation">отношение эквивалентности</a>, то есть
<a href="https://en.wikipedia.org/wiki/Reflexive_relation">рефлексивное</a>,
<a href="https://en.wikipedia.org/wiki/Symmetric_relation">симметричное</a> и
<a href="https://en.wikipedia.org/wiki/Transitive_relation">транзитивное</a>.</p>
</blockquote>
<h3 id="Запуск-тестов"><a class="header" href="#Запуск-тестов">Запуск тестов</a></h3>
<p>Тесты можно запустить командой <code>cargo test --test 1-time-1-rtc</code> в директории <code>kernel</code> репозитория.
Вы увидите сборку, запуск эмулятора <a href="https://en.wikipedia.org/wiki/QEMU"><code>qemu</code></a>, логи инициализации ядра и логи тестов:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 1-time-1-rtc)
...
Running: `qemu-system-x86_64 -drive format=raw,file=/home/sergey/shad-os/target/kernel/debug/deps/bootimage-time-8696ef78d2ec023a.bin -no-reboot -m size=50M -smp cpus=4 -device isa-debug-exit,iobase=0xF4,iosize=0x04 -serial stdio -display none`
00:00:00 0 I RTC init; acknowledged_settings = USE_24_HOUR_FORMAT | USE_BINARY_FORMAT | UPDATE_ENDED_INTERRUPT
00:00:00 0 I time init
00:00:00 0 I Nikka booted; now = 1970-01-01 00:00:00 UTC; tsc = Tsc(5345850832)
00:00:00 0 I GDT init
00:00:00 0 I interrupts init
running 4 tests

time::rtc_read_inconsistent---------------------------------
00:00:00 0 D start = 1970-01-01 00:00:00 UTC
panicked at 'the RTC date does not pass the sanity check', kernel/tests/time.rs:43:5
--------------------------------------------------- [failed]
00:00:00 0 I exit qemu; exit_code = FAILURE
error: test failed, to rerun pass '--test time'
</code></pre>
<p>Если запустить тест из корня репозитория, то вы столкнётесь ошибкой:</p>
<pre><code class="language-console">error: language item required, but not found: `eh_personality`
  |
  = note: this can occur when a binary crate with `#![no_std]` is compiled for a target where `eh_personality` is defined in the standard library
  = help: you may be able to compile for a target that doesn't need `eh_personality`, specify a target with `--target` or in `.cargo/config`
</code></pre>
<p>Это ожидаемо, запускайте тест из директории <code>kernel</code>.</p>
<p>До решения задачи тест <code>fn rtc_read_inconsistent()</code> из файла
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/time.rs"><code>kernel/tests/time.rs</code></a>
падает:</p>
<pre><code class="language-console">time::rtc_read_inconsistent---------------------------------
00:00:00 0 D start = 1970-01-01 00:00:00 UTC
panicked at 'the RTC date does not pass the sanity check', kernel/tests/time.rs:43:5
--------------------------------------------------- [failed]
</code></pre>
<p>А после выполнения задачи он должен проходить:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 1-time-1-rtc)
...
time::rtc_read_inconsistent---------------------------------
10:25:26 0 D start = 2022-09-17 10:25:26 UTC
10:25:27 0 D now = 2022-09-17 10:25:27 UTC
10:25:28 0 D now = 2022-09-17 10:25:28 UTC
10:25:29 0 D now = 2022-09-17 10:25:29 UTC
10:25:30 0 D now = 2022-09-17 10:25:30 UTC
10:25:31 0 D now = 2022-09-17 10:25:31 UTC
10:25:32 0 D now = 2022-09-17 10:25:32 UTC
10:25:33 0 D now = 2022-09-17 10:25:33 UTC
10:25:34 0 D now = 2022-09-17 10:25:34 UTC
10:25:35 0 D now = 2022-09-17 10:25:35 UTC
time::rtc_read_inconsistent------------------------ [passed]
</code></pre>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/time/rtc.rs |   65 ++++++++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 59 insertions(+), 6 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Счётчик-тактов-процессора"><a class="header" href="#Счётчик-тактов-процессора">Счётчик тактов процессора</a></h2>
<p>Из всех имеющихся в стандартном компьютере часов, самым большим разрешением
обладает тактовый генератор процессора.
В Nikka работа с ним собрана в модуль
<a href="../../doc/ku/time/tsc/index.html"><code>ku::time::tsc</code></a>
в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/time/tsc.rs"><code>ku/src/time/tsc.rs</code></a>.
Сопоставлять другие источники времени будем с ним.</p>
<p>Функция <a href="../../doc/ku/time/tsc/fn.tsc.html"><code>fn ku::time::tsc::tsc() -&gt; i64</code></a>
возвращает
<a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">номер текущего такта процессора</a>
в некоторый момент времени своего исполнения.</p>
<blockquote>
<p>Относительно оптимальным решением для этого было бы использовать инструкцию
<a href="https://www.felixcloutier.com/x86/rdtscp"><code>RDTSCP</code></a>,
позвать которую в Rust можно как
<a href="https://doc.rust-lang.org/nightly/core/arch/x86_64/fn.__rdtscp.html"><code>core::arch::x86_64::__rdtscp()</code></a>.
К сожалению, она доступна только на довольно новых процессорах,
поэтому Nikka использует более старую инструкцию
<a href="https://www.felixcloutier.com/x86/rdtsc"><code>RDTSC</code></a>,
в сочетании с <a href="https://www.felixcloutier.com/x86/lfence"><code>LFENCE</code></a>,
через функции
<a href="https://doc.rust-lang.org/nightly/core/arch/x86_64/fn._rdtsc.html"><code>core::arch::x86_64::_rdtsc()</code></a>
и
<a href="https://doc.rust-lang.org/nightly/core/arch/x86_64/fn._mm_lfence.html"><code>core::arch::x86_64::_mm_lfence()</code></a>.
Кроме того, она рассчитывает, что результат <code>RDTSC</code> поместится в
<a href="https://doc.rust-lang.org/nightly/core/primitive.i64.html"><code>i64</code></a>,
что удобно, например, для взятия разности при вычислении интервала времени.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline(always)]
pub fn tsc() -&gt; i64 {
    unsafe {
        x86_64::_mm_lfence();
        x86_64::_rdtsc().try_into().expect(&quot;i64 overflow when storing TSC is expected only after tens of years of uptime&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>В статье
<a href="https://www.intel.com/content/dam/www/public/us/en/documents/white-papers/ia-32-ia-64-benchmark-code-execution-paper.pdf">How to Benchmark Code Execution Times on Intel® IA-32 and IA-64 Instruction Set Architectures</a>
есть продвинутые рекомендации по использованию инструкций <code>RDTSC</code> и <code>RDTSCP</code> для измерений интервалов времени.
Кроме того, с использованием инструкций <code>RDTSC</code> и <code>RDTSCP</code> связаны и другие тонкости, например:</p>
<ul>
<li>Инвариантность в зависимости от нагрузки на процессор и его режима энергосбережения. На старых процессорах при изменении его частоты работы меняется и частота счётчика тактов, то есть она не инвариантна.</li>
<li>Согласованность счётчиков тактов между разными процессорами системы.</li>
<li>Вообще говоря, прикладные программы не могут рассчитывать на доступность этих инструкций. Так как ядро может запретить их использование в непривилегированном режиме.</li>
<li>Ядро не спроста может хотеть запретить эти инструкции. Существует множество атак на криптографические алгоритмы, базирующихся на том, что атакующему доступно точное измерение времени работы атакуемого криптографического приложения.</li>
</ul>
<p>Для упрощения, Nikka игнорирует эти сложности.</p>
</blockquote>
<h3 id="Момент-времени-kutimetsctsc"><a class="header" href="#Момент-времени-kutimetsctsc">Момент времени <a href="../../doc/ku/time/tsc/struct.Tsc.html"><code>ku::time::tsc::Tsc</code></a></a></h3>
<p>Структура <a href="../../doc/ku/time/tsc/struct.Tsc.html"><code>Tsc</code></a>
описывает момент времени, храня значение счётчика тактов процессора.
Она похожа на стандартную, но недоступную нам в <code>#[no_std]</code>–окружении
структуру
<a href="https://doc.rust-lang.org/std/time/struct.Instant.html"><code>std::time::Instant</code></a>.
Обе описывают <a href="https://blog.codeminer42.com/the-monotonic-clock-and-why-you-should-care-about-it/">монотонно возрастающее время</a>.
То есть время, не ходящее “назад” ни при переводе часов на летнее время, ни при корректировке неточно идущих часов.
Но такое время может никак не соответствовать <a href="https://en.wikipedia.org/wiki/Civil_time">реальному времени</a>.</p>
<h3 id="Интервал-времени-kutimetsctscduration"><a class="header" href="#Интервал-времени-kutimetsctscduration">Интервал времени <a href="../../doc/ku/time/tsc/struct.TscDuration.html"><code>ku::time::tsc::TscDuration</code></a></a></h3>
<p>Структура <a href="../../doc/ku/time/tsc/struct.TscDuration.html"><code>TscDuration</code></a> описывает
интервал между двумя моментами времени
<a href="../../doc/ku/time/tsc/struct.Tsc.html"><code>Tsc</code></a>.
Она наивно предполагает, что используемый ею счётчик тактов процессора как минимум инвариантен и согласован между процессорами.</p>
<p>Структура <a href="../../doc/ku/time/tsc/struct.TscDuration.html"><code>TscDuration</code></a>
может быть напечатана. Например,</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let timer = time::timer();
let frame_allocator = MainFrameAllocator::new(memory_map);
info!(
    frame_allocator = &quot;main&quot;,
    free_frame_count = frame_allocator.count(),
    duration = %timer.elapsed(),
    &quot;init&quot;,
);
<span class="boring">}
</span></code></pre></pre>
<p>пишет в лог <code>duration = 322.017 Mtsc</code>:</p>
<pre><code>15:08:28 0 I init; frame_allocator = &quot;main frame allocator&quot;; free_frame_count = 10601; duration = 322.017 Mtsc
</code></pre>
<p>где Mtsc — миллионы тактов процессора.
Наша ближайшая задача, —
научиться выражать продолжительность в гораздо более удобных для человека единицах измерения, привязанных к реальному миру.</p>
<blockquote>
<h3 id="Монотонное-время"><a class="header" href="#Монотонное-время">Монотонное время</a></h3>
<p>Обратите внимание, что интервалы времени корректно измерять только по монотонному времени.
Иначе в момент корректировки неточно идущих часов или при ступенчатом добавлении високосной секунды,
интервал будет неверен.
Аналогично, сравнивать моменты времени на больше или меньше тоже можно только по монотонным часам.
Из-за ошибочного использования в этих случаях реального времени порой происходят крупные сбои, например
<a href="https://blog.cloudflare.com/how-and-why-the-leap-second-affected-cloudflare-dns/">сбой в Cloudflare</a>.</p>
<p>Как вариант, можно хранить в типе, отвечающем за точку во времени, одновременно и показания часов реального времени,
и показания монотонных часов в тот же момент.
Тогда при оперировании с одной временной точкой, можно показывать человеку привычное ему реальное время.
А вот при вычислении интервалов времени между двумя точками, а также для сравнения точек на больше и меньше,
использовать монотонные компоненты этих точек.
В Go <a href="https://go.googlesource.com/proposal/+/master/design/12914-monotonic.md">сделали именно так</a>.
Это стоит немного дополнительной памяти для хранения монотонных компонент.</p>
<p>К сожалению, уже есть довольно много неаккуратно написанного кода, полагающегося на монотонность системного времени.
Один из элегантных методов обхода возникающих из-за этого проблем при резком подводе часов реального времени,
особенно назад, состоит в размазывании большой одномоментной дельты на маленькие,
вносимые в течение длительного времени.
Системный вызов <a href="https://linux.die.net/man/3/adjtime">adjtime</a> корректирует неточно идущие локальные часы именно так.
Аналогично <a href="https://googleblog.blogspot.com/2011/09/time-technology-and-leaping-seconds.html">поступает и Google с високосными секундами</a>.</p>
<p>Строго говоря, <a href="https://www.felixcloutier.com/x86/rdtsc"><code>RDTSC</code></a> не является монотонным источником времени.
Так как этот счётчик можно менять, в том числе назад.
См. стр. <a href="https://xem.github.io/minix86/manual/intel-x86-and-64-manual-vol3/o_fe12b1e2a880e0ce-615.html">615</a> и
<a href="https://xem.github.io/minix86/manual/intel-x86-and-64-manual-vol3/o_fe12b1e2a880e0ce-615.html">616</a>
в руководстве от Intel:</p>
<blockquote>
<p>17.15.3  Time-Stamp Counter Adjustment</p>
<p>Software can modify the value of the time-stamp counter (TSC) of a logical processor by using the WRMSR instruction
to write to the IA32_TIME_STAMP_COUNTER MSR (address 10H). Because such a write applies only to that
logical processor, software seeking to synchronize the TSC values of multiple logical processors must perform these
writes on each logical processor.</p>
</blockquote>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Счётчики-тиков-различных-источников-времени"><a class="header" href="#Счётчики-тиков-различных-источников-времени">Счётчики тиков различных источников времени</a></h2>
<p>Структура
<a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html"><code>ku::time::correlation_point::CorrelationPoint</code></a>
из файла <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/time/correlation_point.rs"><code>ku/src/time/correlation_point.rs</code></a>
предназначена для привязки тактов процессора к другим часам в один момент времени.
Она содержит поля:</p>
<ul>
<li><a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html#structfield.tsc"><code>CorrelationPoint::tsc</code></a> со значением счётчика тактов процессора.</li>
<li><a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html#structfield.count"><code>CorrelationPoint::count</code></a> со значением счётчика тиков другого источника времени в тот же момент.</li>
</ul>
<p>Если значение
<a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html#structfield.tsc"><code>CorrelationPoint::tsc</code></a>
равно нулю, то структура в целом считается невалидной —
<a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html#method.invalid"><code>CorrelationPoint::invalid()</code></a>.
Это означает, что
<a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html#structfield.count"><code>CorrelationPoint::count</code></a>
не привязан ни к какому значению
<a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html#structfield.tsc"><code>CorrelationPoint::tsc</code></a>.
И значение структуры относится не к самому тику, а к промежутку после тика
<a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html#structfield.count"><code>CorrelationPoint::count</code></a>
и до следующего.
При этом значение
<a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html#structfield.count"><code>CorrelationPoint::count</code></a>
может быть использовано как текущее время с низким разрешением — частотой соответствующих часов.</p>
<p>Посмотрите код реализации структуры
<a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html"><code>ku::time::correlation_point::CorrelationPoint</code></a>,
он достаточно прост.</p>
<p>Более интересная структура
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>ku::time::correlation_point::AtomicCorrelationPoint</code></a>
из файла <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/time/correlation_point.rs"><code>ku/src/time/correlation_point.rs</code></a> предназначена для конкурентного доступа к значениям
<a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html"><code>CorrelationPoint</code></a>.
То есть <a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html"><code>CorrelationPoint</code></a> и
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a>
соотносятся также как примитивный тип
<a href="https://doc.rust-lang.org/nightly/core/primitive.i64.html"><code>i64</code></a>
и атомарный
<a href="https://doc.rust-lang.org/nightly/core/sync/atomic/struct.AtomicI64.html"><code>core::sync::atomic::AtomicI64</code></a>.</p>
<p>Атомарность нужна для того, чтобы конкурентно</p>
<ul>
<li>в обработчике прерывания обновлять счётчики <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a>;</li>
<li>а в обычном коде читать эти счётчики, чтобы “посмотреть на часы”.</li>
</ul>
<p>В <a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html"><code>CorrelationPoint</code></a> два числа типа
<a href="https://doc.rust-lang.org/nightly/core/primitive.i64.html"><code>i64</code></a>,
а в
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a> два соответствующих им
<a href="https://doc.rust-lang.org/nightly/core/sync/atomic/struct.AtomicI64.html"><code>AtomicI64</code></a>.
Нам нужно читать и записывать эти два значения согласованно, поэтому и возникают небольшие сложности.</p>
<p>Можно было бы завести блокировку на доступ к полям
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a>,
но это потребовало бы захватывать её из прерывания.
Это практически гарантированно приведёт к проблемам:</p>
<ul>
<li>Захват этой блокировки должен ещё и запрещать прерывания. Иначе возможна <a href="https://en.wikipedia.org/wiki/Deadlock">взаимоблокировка</a>, подумайте почему. А Nikka предпочитает не отключать прерывания на потенциально длительное время удержания какой-нибудь блокировки.</li>
<li>Иногда прерывание будет ждать другой код, пока он не отпустит эту блокировку. Обычно прерывания являются более приоритетной деятельностью, поэтому возникнет нежелательная <a href="https://en.wikipedia.org/wiki/Priority_inversion">инверсия приоритетов</a>.</li>
<li>Писать мы хотим из прерывания в режиме ядра, а читать — из режима пользователя. При этом с одной стороны, ядро должно обеспечить консистентность чтения коду пользователя. А с другой — оно не должно допустить чтобы злонамеренный код из пользовательского режима мог заблокировать ядро, в том числе навечно.</li>
</ul>
<p>Вообще, захват блокировок из прерываний — очень плохая идея.</p>
<p>Поэтому реализуем
<a href="https://en.wikipedia.org/wiki/Non-blocking_algorithm">неблокирующую синхронизацию</a>
для согласованного доступа к полям
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a>.
Которая будет отдавать предпочтение писателю, так как это обработчик прерывания в ядре, —
он всегда сможет завершить работу по обновлению структуры за фиксированное и достаточно небольшое количество тактов.
И никогда не будет ждать читателей, которые могут быть запущены как в режиме ядра, так и в режиме пользователя.
А вот читатели будут максимально пессимизированы —
они будут вынуждены ждать пока писатель завершит свою работу, если им не повезло запуститься конкурентно с писателем.
Впрочем, для них это не будет страшно, так как:</p>
<ul>
<li>Писатель запускается редко, один раз в секунду для микросхемы RTC. Или двадцать раз в секунду для микросхемы PIT <a href="https://en.wikipedia.org/wiki/Intel_8253">Intel 8253/8254</a> — это сконфигурированная в Nikka частота, её можно поменять. Эти два писателя пишут в разные экземпляры структуры, поэтому они никогда не конфликтуют между собой.</li>
<li>Писатель отрабатывает очень быстро, всего за несколько инструкций процессора.</li>
</ul>
<p>В качестве инструмента такой неблокирующей синхронизации предлагается использовать упрощённый
<a href="https://en.wikipedia.org/wiki/Seqlock">sequence lock</a>.
В нашем случае его идея в следующем.
Мы храним в поле
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#structfield.sequence_number"><code>AtomicCorrelationPoint::sequence_number</code></a>
удвоенный номер операции обновления.
А в его младшем бите хранится признак, что сейчас структура
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a>
находится в неконсистентном состоянии из-за текущей активности писателя.
То есть:</p>
<ul>
<li>Нечётное значение в <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#structfield.sequence_number"><code>AtomicCorrelationPoint::sequence_number</code></a> означает, что писатель начал обновлять структуру <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a>, но ещё не закончил. Если читатель обнаруживает структуру в таком состоянии, он должен подождать пока писатель закончит обновление.</li>
<li>Чётное значение в <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#structfield.sequence_number"><code>AtomicCorrelationPoint::sequence_number</code></a> означает, что значение структуры <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a> консистентно и читатель может его использовать.</li>
</ul>
<p>В нашем случае писатель один, что дополнительно упрощает дело.
Алгоритм его действий:</p>
<ul>
<li>Раз он один, значит до начала им обновления структуры <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a>, её значение заведомо консистентно. А <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#structfield.sequence_number"><code>AtomicCorrelationPoint::sequence_number</code></a> содержит чётное число.</li>
<li>Писатель атомарно инкрементирует поле <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#structfield.sequence_number"><code>AtomicCorrelationPoint::sequence_number</code></a>. Оно становится нечётным, символизируя что идёт обновление.</li>
<li>После этого писатель заполняет поля <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#structfield.count"><code>AtomicCorrelationPoint::count</code></a> и <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#structfield.tsc"><code>AtomicCorrelationPoint::tsc</code></a>.</li>
<li>Последним действием писатель атомарно инкрементирует поле <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#structfield.sequence_number"><code>AtomicCorrelationPoint::sequence_number</code></a>. Это действие сигнализирует всем читателям, что обновление завершено и структура находится в консистентном состоянии.</li>
</ul>
<p>Алгоритм действий читателя чуть сложнее:</p>
<ul>
<li>Читатель атомарно загружает значения поля <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#structfield.sequence_number"><code>AtomicCorrelationPoint::sequence_number</code></a>.</li>
<li>Далее он читает значение полей <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#structfield.count"><code>AtomicCorrelationPoint::count</code></a> и <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#structfield.tsc"><code>AtomicCorrelationPoint::tsc</code></a>.</li>
<li>После чего он повторно атомарно загружает значение поля <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#structfield.sequence_number"><code>AtomicCorrelationPoint::sequence_number</code></a>.</li>
<li>Если при обеих загрузках значения поля <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#structfield.sequence_number"><code>AtomicCorrelationPoint::sequence_number</code></a> совпадают и являются чётными, то структура <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a> была прочитана в консистентном состоянии. Читатель возвращает значение получившейся структуры <a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html"><code>CorrelationPoint</code></a> в вызывающую функцию.</li>
<li>Если же это не так, читатель повторяет все действия с самого начала.</li>
</ul>
<p>Перекос сложности в сторону читателя и наличие в нём цикла ожидания, чего нет в писателе, —
проявление большего приоритета писателя.</p>
<blockquote>
<p>Обобщённая реализация <a href="https://en.wikipedia.org/wiki/Seqlock">sequence lock</a>
с несколькими писателями и произвольной защищаемой структурой данных была бы сложнее.
Например, можете посмотреть на:</p>
<ul>
<li><a href="https://pitdicker.github.io/Writing-a-seqlock-in-Rust/">Writing a seqlock in Rust.</a></li>
<li><a href="https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf">Can Seqlocks Get Along With Programming Language Memory Models?</a></li>
<li><a href="https://docs.rs/seqlock/0.1.2/seqlock/">Crate seqlock.</a></li>
</ul>
</blockquote>
<h3 id="Задача-2--реализация-atomiccorrelationpoint"><a class="header" href="#Задача-2--реализация-atomiccorrelationpoint">Задача 2 — реализация <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a></a></h3>
<p>Реализуйте описанные алгоритмы чтения и записи.
Читает из структуры
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a>
её <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#method.load">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn AtomicCorrelationPoint::load(&amp;self) -&gt; CorrelationPoint
<span class="boring">}
</span></code></pre></pre>
<p>Точнее вам достаточно реализовать вспомогательный <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#method.try_load">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn AtomicCorrelationPoint::try_load(&amp;self) -&gt; Option&lt;CorrelationPoint&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Он пытается прочитать значение только один раз.
И возвращает его, завернув в
<a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#variant.Some"><code>core::option::Option::Some</code></a>,
если оно было прочитано консистентно.</p>
<p>Пишут в
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a>
два других метода.
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#method.store">Метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn AtomicCorrelationPoint::store(&amp;self, counter: CorrelationPoint)
<span class="boring">}
</span></code></pre></pre>
<p>записывает заданное <code>counter</code> значение. А
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#method.inc">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn AtomicCorrelationPoint::inc(&amp;self, tsc: i64)
<span class="boring">}
</span></code></pre></pre>
<p>инкрементирует поле
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#structfield.count"><code>AtomicCorrelationPoint::count</code></a>
и записывает в поле
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#structfield.tsc"><code>AtomicCorrelationPoint::tsc</code></a>
значение аргумента <code>tsc</code>.</p>
<p>Методом
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#method.store"><code>AtomicCorrelationPoint::store()</code></a>
пользуется обработчик прерываний RTC.
С его помощью он сохраняет текущее значение секунд, прошедших с начала Unix–эпохи.
А методом
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#method.inc"><code>AtomicCorrelationPoint::inc()</code></a> —
обработчик прерываний PIT.
Он сохраняет просто счётчик своих тиков, который никак не привязан к реальному времени.
Поэтому ему достаточно инкрементировать логическое значение своего счётчика при каждом прерывании.</p>
<p>Используйте поле
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#structfield.sequence_number"><code>AtomicCorrelationPoint::sequence_number</code></a>
как атомарную переменную, синхронизующую между собой
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#method.load"><code>load()</code></a> и
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#method.store"><code>store()</code></a>/<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#method.inc"><code>inc()</code></a>.
То есть, правильно расставьте сами атомарные операции доступа к обоим полям и
<a href="https://doc.rust-lang.org/nightly/core/sync/atomic/enum.Ordering.html"><code>core::sync::atomic::Ordering</code></a>
в них.
К сожалению, тест не может проверить корректность расстановки
<a href="https://doc.rust-lang.org/nightly/core/sync/atomic/enum.Ordering.html"><code>Ordering</code></a>.
Поэтому ей стоит уделить повышенное внимание.</p>
<p>Обратите внимание, что
<a href="https://doc.rust-lang.org/nightly/core/sync/atomic/enum.Ordering.html#variant.SeqCst"><code>Ordering::SeqCst</code></a>
использовать не рекомендуется.
Так как мнение “использовать
<a href="https://doc.rust-lang.org/nightly/core/sync/atomic/enum.Ordering.html#variant.SeqCst"><code>Ordering::SeqCst</code></a>
гарантированно безопасно” неверно.
Режим
<a href="https://doc.rust-lang.org/nightly/core/sync/atomic/enum.Ordering.html#variant.SeqCst"><code>Ordering::SeqCst</code></a>
позволяет делать довольно специфические вещи, которые реально нужны довольно редко.
<a href="https://github.com/rust-lang/nomicon/issues/166">А вот гарантий корректности не даёт, это заблуждение</a>.</p>
<p>Если в алгоритме синхронизации вам понадобилось написать что-нибудь вроде</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let end_sequence_number = sequence_number.load(Ordering::Release);
<span class="boring">}
</span></code></pre></pre>
<p>Компилятор выдаст ошибку:</p>
<pre><code class="language-console">error: atomic loads cannot have `Release` or `AcqRel` ordering
  --&gt; kernel/tests/1-time-2-correlation-point.rs:38:52
   |
38 |     let end_sequence_number = sequence_number.load(Ordering::Release);
   |                                                    ^^^^^^^^^^^^^^^^^
   |
   = note: `#[deny(invalid_atomic_ordering)]` on by default
   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`
</code></pre>
<p>А если её подавить с помощью <code>#[allow(invalid_atomic_ordering)]</code>, то уже при запуске будет
<a href="https://doc.rust-lang.org/nightly/core/sync/atomic/struct.AtomicI64.html#panics">паника</a>:</p>
<pre><code>1_time_2_correlation_point::wrong_ordering------------------
panicked at 'there is no such thing as a release load', .../src/rust/library/core/src/sync/atomic.rs:2964:24
--------------------------------------------------- [failed]
</code></pre>
<p>Если в этом месте поменять
<a href="https://doc.rust-lang.org/nightly/core/sync/atomic/enum.Ordering.html#variant.Release"><code>Ordering::Release</code></a>
на
<a href="https://doc.rust-lang.org/nightly/core/sync/atomic/enum.Ordering.html#variant.SeqCst"><code>Ordering::SeqCst</code></a>,
не меняя остальную часть алгоритма синхронизации,
то компиляция пройдёт и паники не будет.
Но код скорее всего будет <strong>некорректен</strong>, — простая замена на
<a href="https://doc.rust-lang.org/nightly/core/sync/atomic/enum.Ordering.html#variant.SeqCst"><code>Ordering::SeqCst</code></a>
не исправит сам алгоритм синхронизации.
То есть, использование
<a href="https://doc.rust-lang.org/nightly/core/sync/atomic/enum.Ordering.html#variant.SeqCst"><code>Ordering::SeqCst</code></a>
скроет ошибку в алгоритме синхронизации, о наличии которой заботливо предупреждали компилятор и паника.
К такому же эффекту приведёт смена
<a href="https://doc.rust-lang.org/nightly/core/sync/atomic/enum.Ordering.html#variant.Release"><code>Ordering::Release</code></a>
на
<a href="https://doc.rust-lang.org/nightly/core/sync/atomic/enum.Ordering.html#variant.Relaxed"><code>Ordering::Relaxed</code></a>.
Но <a href="https://doc.rust-lang.org/nightly/core/sync/atomic/enum.Ordering.html#variant.Relaxed"><code>Ordering::Relaxed</code></a>
хотя бы бросается в глаза в коде.</p>
<p>Также учтите, что нам точно не нужен
<a href="https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf">приём “read-dont-modify-write”</a>.
Его может хотеться использовать в читателе.
Но читатель потенциально будет выполняться в режиме пользователя.
А значит, не сможет выполнять запись в общесистемную структуру
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a>,
хранящую показания RTC.
Так как она доступна в режиме пользователя только на чтение.
Другими словами, если вы используете “read-dont-modify-write”, то в будущих лабораторках вылезет ошибка.
Не говоря уж о совершенно лишнем захвате кеш–линии в эксклюзивное использование при чтении
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a>.</p>
<p>Вы можете опираться на тот факт, что писатель один и методы записи —
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#method.store"><code>AtomicCorrelationPoint::store()</code></a> и
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#method.inc"><code>AtomicCorrelationPoint::inc()</code></a> —
гарантированно не вызываются конкурентно ни каждый сам с собой, ни друг с другом.</p>
<h3 id="Запуск-тестов-1"><a class="header" href="#Запуск-тестов-1">Запуск тестов</a></h3>
<p>Тесты можно запустить командой <code>cargo test --test 1-time-2-correlation-point</code> в директории <code>kernel</code> репозитория.</p>
<p>После выполнения задачи должны проходить тесты <code>correlation_point_reader()</code> и <code>correlation_point_writer()</code>
в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/time.rs"><code>kernel/tests/time.rs</code></a>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 1-time-2-correlation-point)
...
time::correlation_point_reader------------------------------
10:35:25 0 D same = 0; different = 1; point = CorrelationPoint { count: 1000, tsc: 1000 }
10:35:26 0 D same = 1082; different = 542; point = CorrelationPoint { count: 1082000, tsc: 1082000 }
10:35:27 0 D same = 2166; different = 1084; point = CorrelationPoint { count: 2166000, tsc: 2166000 }
10:35:28 0 D same = 3253; different = 1627; point = CorrelationPoint { count: 3253000, tsc: 3253000 }
10:35:29 0 D same = 4340; different = 2170; point = CorrelationPoint { count: 4338000, tsc: 4338000 }
10:35:30 0 D same = 5422; different = 2712; point = CorrelationPoint { count: 5422000, tsc: 5422000 }
10:35:31 0 D same = 6506; different = 3254; point = CorrelationPoint { count: 6506000, tsc: 6506000 }
10:35:32 0 D same = 7594; different = 3798; point = CorrelationPoint { count: 7594000, tsc: 7594000 }
10:35:33 0 D same = 8678; different = 4340; point = CorrelationPoint { count: 8678000, tsc: 8678000 }
10:35:34 0 D same = 9762; different = 4882; point = CorrelationPoint { count: 9762000, tsc: 9762000 }
10:35:35 0 D same = 10848; different = 5425; point = CorrelationPoint { count: 10849000, tsc: 10849000 }
10:35:36 0 D same = 11936; different = 5968; point = CorrelationPoint { count: 11934000, tsc: 11934000 }
10:35:37 0 D same = 13022; different = 6512; point = CorrelationPoint { count: 13022000, tsc: 13022000 }
10:35:38 0 D same = 14108; different = 7055; point = CorrelationPoint { count: 14109000, tsc: 14109000 }
10:35:39 0 D same = 15184; different = 7593; point = CorrelationPoint { count: 15185000, tsc: 15185000 }
10:35:40 0 D same = 16270; different = 8135; point = CorrelationPoint { count: 16269000, tsc: 16269000 }
10:35:41 0 D same = 17356; different = 8679; point = CorrelationPoint { count: 17357000, tsc: 17357000 }
10:35:42 0 D same = 18438; different = 9220; point = CorrelationPoint { count: 18438000, tsc: 18438000 }
10:35:43 0 D same = 19520; different = 9761; point = CorrelationPoint { count: 19521000, tsc: 19521000 }
time::correlation_point_reader--------------------- [passed]

time::correlation_point_writer------------------------------
10:35:43 0 D iteration = 0; failure_count = 0; success_count = 0; point = CorrelationPoint { count: 0, tsc: 0 }
10:35:44 0 D iteration = 840; failure_count = 90828; success_count = 220580; point = CorrelationPoint { count: 840, tsc: 840 }
10:35:45 0 D iteration = 2396; failure_count = 258876; success_count = 628295; point = CorrelationPoint { count: 2396, tsc: 2396 }
10:35:46 0 D iteration = 3958; failure_count = 427572; success_count = 1037519; point = CorrelationPoint { count: 3958, tsc: 3958 }
10:35:47 0 D iteration = 5345; failure_count = 570102; success_count = 1472279; point = CorrelationPoint { count: 5345, tsc: 5345 }
10:35:48 0 D iteration = 6383; failure_count = 660408; success_count = 1958120; point = CorrelationPoint { count: 6383, tsc: 6383 }
10:35:49 0 D iteration = 7433; failure_count = 751845; success_count = 2449799; point = CorrelationPoint { count: 7434, tsc: 7434 }
10:35:50 0 D iteration = 8485; failure_count = 843282; success_count = 2941927; point = CorrelationPoint { count: 8485, tsc: 8485 }
10:35:51 0 D iteration = 9529; failure_count = 934110; success_count = 3430565; point = CorrelationPoint { count: 9529, tsc: 9529 }
10:35:51 0 D iteration = 10000; failure_count = 975087; success_count = 3650638
time::correlation_point_writer--------------------- [passed]
</code></pre>
<blockquote>
<h3 id="Как-устроен-тест"><a class="header" href="#Как-устроен-тест">Как устроен тест</a></h3>
<p>Для того чтобы проверить корректность реализации
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a>
было бы здорово запустить стресс–тест с писателем и читателем на разных процессорах.
И желательно на процессорах со
<a href="https://en.wikipedia.org/wiki/Memory_ordering#In_symmetric_multiprocessing_(SMP)_microprocessor_systems">слабой моделью памяти</a>,
в которых возможно больше интересных эффектов, чем в архитектуре
<a href="https://en.wikipedia.org/wiki/X86-64">x86-64</a>.
А в случае архитектуры
<a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA</a>,
в которой процессоры организованы в сложную иерархию,
стоило бы запустить этот тест несколько раз на наборе неэквивалентных с точки зрения архитектуры пар процессоров —
читатель и писатель в одном NUMA–домене, в разных NUMA–доменах и т.д.</p>
<p>Но в Nikka поддержана только
архитектура <a href="https://en.wikipedia.org/wiki/X86-64">x86-64</a>.
А поддержку нескольких процессоров мы сделаем только в
<a href="../../lab/book/4-concurrency-1-smp-0-intro.html">будущей лабе</a>.
И пока нам не доступна возможность запустить стресс–тест даже на двух процессорах в симметричной системе.</p>
<p>Но можно вспомнить про то, что
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a>
реализуется конкурентной ради прерываний,
которые являются одной из конкурентных активностей в компьютере.
Тогда в голову приходит вариант запустить стресс–тест,
в котором писатель будет работать в прерывании, а читатель — в обычном коде, прерываемом периодически этим прерыванием.
Собственно
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a>
предназначен именно для такого сценария использования, в котором прерывание поступает от источника времени — RTC или PIT.
Тики RTC, происходящие раз в секунду, точно не подходят для стресс–теста.
Можно было бы сконфигурировать PIT на его максимальную частоту — 1.193(18) MHz, но это всё ещё не очень много.</p>
<p>Зато есть интересный режим работы процессора —
<a href="https://en.wikipedia.org/wiki/Stepping_(debugging)">режим трассировки</a>.
От предназначен для пошаговой отладки программ.
В этом режиме процессор генерирует прерывание с номером
<a href="../../doc/kernel/interrupts/constant.DEBUG.html"><code>kernel::interrupts::DEBUG</code></a>
на каждой исполняемой им инструкции программы.
Задаётся такой режим работы включением
<a href="https://en.wikipedia.org/wiki/Trap_flag">флага трассировки</a> в
<a href="https://en.wikipedia.org/wiki/FLAGS_register">регистре флагов</a> процессора.</p>
<p>То есть, идея состоит в том, чтобы запустить читателя “под пошаговой отладкой”.
А писателя использовать вместо отладчика.
Тогда между каждыми двумя инструкциями кода читателя будет запускаться код писателя.
Правда, так как читатель работает в цикле ожидания корректности структуры
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a>,
если писатель будет обновлять её на каждом прерывании — между каждыми двумя инструкциями читателя,
то читатель никогда не дождётся своего условия выхода из цикла и зависнет.
Поэтому писатель должен будет на значительное количество итераций такой
пошаговой отладки прекращать обновление
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a>.</p>
<p>В коде теста это выглядит так:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test_case]
fn correlation_point_reader() {
    interrupts::test_scaffolding::set_debug_handler(writer);

    reader();

    static POINT: AtomicCorrelationPoint = AtomicCorrelationPoint::new();

    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Функция <code>interrupts::test_scaffolding::set_debug_handler()</code> устанавливает заданный обработчик
прерывания
<a href="../../doc/kernel/interrupts/constant.DEBUG.html"><code>kernel::interrupts::DEBUG</code></a>,
который содержит процедуру писателя <code>writer()</code>.
Дальше запускается читатель <code>reader()</code>.
Конкурировать они будут за переменную <code>POINT</code>. Она сделана статической для удобства доступа из
обработчика прерываний, которому мы не можем передать произвольный набор аргументов.
По той же причине его внутренне состояние, которое нужно сохранять между вызовами обработчика,
тоже записывается в статические переменные.
Переменные, которые использует, в том числе, обработчик прерывания, дополнительно сделаны атомарными,
так как формально к ним есть конкурентный доступ.
Плюс Rust не даст работать с изменяемой статической переменной без <code>unsafe</code>,
как раз, чтобы защищать от непредумышленных гонок.
А вот атомарные типы
<a href="https://doc.rust-lang.org/nightly/core/sync/atomic/struct.AtomicUsize.html#impl-Sync-for-AtomicUsize">помечены</a>
типажём
<a href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html"><code>core::marker::Sync</code></a>,
<a href="https://doc.rust-lang.org/nomicon/send-and-sync.html">что означает</a>
корректность их конкурентного использования.
К сожалению, это приводит к страшно выглядящему коду.</p>
<p>Писатель имеет внутренний счётчик запусков <code>VALUE</code>, который и определяет, что делать:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;x86-interrupt&quot; fn writer(_: InterruptContext) {
    static VALUE: AtomicUsize = AtomicUsize::new(0);

    let value = VALUE.fetch_add(1, Ordering::Relaxed);

    match (value / 1_000) % 4 {
        0 =&gt; POINT.store(time::test_scaffolding::equal_point(value as i64 + 1)),
        2 =&gt; POINT.inc(POINT.load().count() + 1),
        _ =&gt; {},
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Сигнатуру <code>extern &quot;x86-interrupt&quot; fn writer(_: InterruptContext)</code>
<a href="../../lab/book/1-time-5-interrupts.html">обсудим чуть позже</a>.</p>
<p>Каждую тысячу своих запусков писатель переключается между режимами:</p>
<ul>
<li>Записи в <code>POINT</code> через вызов <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#method.store"><code>AtomicCorrelationPoint::store()</code></a>.</li>
<li>Бездействия, чтобы дать шанс читателю увидеть <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#method.store"><code>AtomicCorrelationPoint::store()</code></a> в одном и том же состоянии на протяжении всего цикла своей работы.</li>
<li>Записи в <code>POINT</code> через вызов <a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#method.inc"><code>AtomicCorrelationPoint::inc()</code></a>.</li>
<li>Очередного бездействия.</li>
</ul>
<p>При этом писатель и читатель придерживаются соглашения, что консистентными состояниями
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a>
являются только состояния с одинаковыми значениями полей
<a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html#structfield.tsc"><code>CorrelationPoint::tsc</code></a> и
<a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html#structfield.count"><code>CorrelationPoint::count</code></a>.
Поэтому в циклах обновления писатель меняет оба поля на одинаковые значения, отличающиеся от значений при предыдущей записи.
В частности функция
<code>time::test_scaffolding::equal_point()</code>
создаёт
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a>
с одинаковыми
<a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html#structfield.tsc"><code>CorrelationPoint::tsc</code></a> и
<a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html#structfield.count"><code>CorrelationPoint::count</code></a>,
равными заданному значению.
Это имеет смысл только для тестов, поэтому она убрана в модуль <code>test_scaffolding</code>.</p>
<p>Читатель устроен так:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn reader() {
    ...
    while ... {
        switch_trap_flag();
        let point = POINT.load();
        switch_trap_flag();
        ...
        assert!(point.count() == point.tsc(), &quot;{:?} is inconsistent&quot;, point);
        ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Он включает режим трассировки функцией <code>switch_trap_flag()</code>, которая просто переключает состояние
<a href="https://en.wikipedia.org/wiki/Trap_flag">флага трассировки</a>
процессора.
После этого запускает тестируемый алгоритм чтения
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#method.load"><code>AtomicCorrelationPoint::load()</code></a>.
Который должен вернуть управление, только когда писатель прекратит обновлять <code>POINT</code> и перейдёт в режим бездействия.
После чего читатель отключает трассировку повторным переключением флаг <code>switch_trap_flag()</code> —
когда она включена он работает очень медленно.
И проверяет консистентность полученного от
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#method.load"><code>AtomicCorrelationPoint::load()</code></a>
значения
<a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html"><code>CorrelationPoint</code></a>.</p>
<p>Нетрудно догадаться, что в этом тесте мы никогда не прерываем писателя и каждый вызов
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#method.store"><code>AtomicCorrelationPoint::store()</code></a> или
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html#method.inc"><code>AtomicCorrelationPoint::inc()</code></a>
выполняется атомарно с точки зрения читателя.
А значит, их корректность мы не проверили.
Это делает другой тест:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test_case]
fn correlation_point_writer() {
    interrupts::test_scaffolding::set_debug_handler(reader);

    writer();
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Он аналогичен рассмотренному <code>correlation_point_reader()</code>, только меняет ролями читателя и писателя.
Теперь писатель запускается “под пошаговой отладкой”, а в обработчике прерывания работает читатель.</p>
<p>Видно, что никак не проверяется случай, когда в едином конкурентном исполнении и читатель прерывается писателем, и наоборот, писатель прерывается читателем.
Также видно, что такой тест не сможет проверить правильность расстановки <code>Ordering</code> в них,
так как с точки зрения пошаговой отладки все инструкции процессора атомарны с наиболее строгой гарантией консистентности.</p>
<blockquote>
<p>Теперь вы можете исследовать код, запуская его в пошаговом режиме.
Например:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test_case]
fn down_the_rabbit_hole() {
    use ku::memory::{Block, Virt};

    interrupts::test_scaffolding::set_debug_handler(collect_statistics);

    switch_trap_flag();
    debug!(&quot;how many instructions does it take to log something?&quot;);
    switch_trap_flag();

    let max_rsp = MAX_RSP.load(Ordering::Relaxed);
    let min_rsp = cmp::min(max_rsp, MIN_RSP.load(Ordering::Relaxed));
    let rip = RIP.load(Ordering::Relaxed);

    debug!(
        instruction_count = INSTRUCTION_COUNT.load(Ordering::Relaxed),
        used_stack_space = ?Block::&lt;Virt&gt;::from_index(min_rsp, max_rsp),
        last_traced_insruction_address = ?Virt::new(rip),
    );

    static INSTRUCTION_COUNT: AtomicUsize = AtomicUsize::new(0);
    static MAX_RSP: AtomicUsize = AtomicUsize::new(usize::MIN);
    static MIN_RSP: AtomicUsize = AtomicUsize::new(usize::MAX);
    static RIP: AtomicUsize = AtomicUsize::new(0);

    extern &quot;x86-interrupt&quot; fn collect_statistics(context: InterruptContext) {
        let context = context.get().mini_context();
        let rip = context.rip().into_usize();
        let rsp = context.rsp().into_usize();

        let max_rsp = cmp::max(rsp, MAX_RSP.load(Ordering::Relaxed));
        let min_rsp = cmp::min(rsp, MIN_RSP.load(Ordering::Relaxed));

        INSTRUCTION_COUNT.fetch_add(1, Ordering::Relaxed);
        MAX_RSP.store(max_rsp, Ordering::Relaxed);
        MIN_RSP.store(min_rsp, Ordering::Relaxed);
        RIP.store(rip, Ordering::Relaxed);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>В отладочной сборке на логирование одной строки ушло 112209 инструкций процессора,
последняя из них располагалась по адресу <code>0v216D07</code>.
А также было потрачено 5.742 KiB стека по адресам <code>[0x100002001c8, 0x100002018c0)</code></p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 1-time-2-correlation-point)
...
time::down_the_rabbit_hole----------------------------------
21:10:12 0 D waiting for the RTC to tick twice
21:10:14.001 0 D how many instructions does it take to log something?
21:10:14.022 0 D how many instructions does it take to log something?
21:10:14.436 0 D instruction_count = 121954; used_stack_space = Ok([0x100001ffbd8, 0x100002012d0), size 5.742 KiB); last_traced_insruction_address = Ok(Virt(0v2180F7))
21:10:14.460 0 D time_to_log_a_message = 2.198 ms; time_to_log_a_message_in_the_stepping_mode = 432.808 ms; stepping_slowdown_ratio = 196.9484863163476
time::down_the_rabbit_hole------------------------- [passed]
</code></pre>
<p>Возможно вы заметили, что второе сообщение <code>how many ...</code>, которое печаталось под трассировкой, появлялось на экране медленнее.</p>
<p>В релизной сборке на логирование одной строки ушло 6874 инструкций и 1.141 KiB стека:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 1-time-2-correlation-point --release)
...
time::down_the_rabbit_hole----------------------------------
21:09:33 0 D waiting for the RTC to tick twice
21:09:35.001 0 D how many instructions does it take to log something?
21:09:35.001 0 D how many instructions does it take to log something?
21:09:35.011 0 D instruction_count = 7624; used_stack_space = Ok([0x10000201890, 0x10000201d20), size 1.141 KiB); last_traced_insruction_address = Ok(Virt(0v20AA12))
21:09:35.014 0 D time_to_log_a_message = 549.737 us; time_to_log_a_message_in_the_stepping_mode = 10.388 ms; stepping_slowdown_ratio = 18.89630272070954
time::down_the_rabbit_hole------------------------- [passed]
</code></pre>
<blockquote>
<p>Теперь вы можете, например, построить гистограмму количества раз, сколько исполнялись инструкции по разным адресам.
И найти самые горячие циклы кода.</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="theory-and-practice-of-concurrency"><a class="header" href="#theory-and-practice-of-concurrency">Theory and Practice of Concurrency</a></h3>
<p>Более подробно познакомиться с конкурентностью, атомарными переменными, синхронизациями, моделями памяти и т.п.,
вы можете на курсе Ромы Липовского “Theory and Practice of Concurrency”:</p>
<ul>
<li>Публичный доступ:
<ul>
<li><a href="https://youtube.com/playlist?list=PL4_hYwCyhAva37lNnoMuBcKRELso5nvBm">Плейлист с лекциями</a>.</li>
<li><a href="https://gitlab.com/Lipovsky/concurrency-course">Репозиторий курса</a>.</li>
</ul>
</li>
<li><a href="https://lk.yandexdataschool.ru/courses/2022-spring/7.1013-theory-and-practice-of-concurrency/about/">Личный кабинет ШАД, весна 2022</a>.</li>
<li><a href="https://wiki.yandex-team.ru/hr/volnoslushateli/lekcii-shad/chetvertyjj-semestr/#zapis2020goda9">Wiki yandex-team, запись 2020 года</a>.</li>
</ul>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-1"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-1">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> ku/src/time/correlation_point.rs |   40 +++++++++++++++++++++++++++++++--------
 1 file changed, 32 insertions(+), 8 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Измерение-частоты-процессора-и-повышение-разрешения-часов"><a class="header" href="#Измерение-частоты-процессора-и-повышение-разрешения-часов">Измерение частоты процессора и повышение разрешения часов</a></h2>
<p>Структура
<a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html"><code>ku::time::correlation_interval::CorrelationInterval</code></a>
из файла <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/time/correlation_interval.rs"><code>ku/src/time/correlation_interval.rs</code></a>
предназначена для соотнесения частоты процессора и другого источника времени.
Она содержит поля:</p>
<ul>
<li><a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html#structfield.base"><code>CorrelationInterval::base</code></a> со знакомым нам <a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html"><code>CorrelationPoint</code></a> в некоторый базовый момент времени, когда тикнули отслеживаемые <a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html"><code>CorrelationInterval</code></a> часы.</li>
<li><a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html#structfield.prev"><code>CorrelationInterval::prev</code></a> с <a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html"><code>CorrelationPoint</code></a> на момент последнего тика отслеживаемых часов.</li>
</ul>
<p><a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html#structfield.base"><code>CorrelationInterval::base</code></a> и
<a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html#structfield.prev"><code>CorrelationInterval::prev</code></a>
содержат количество тиков отслеживаемых часов и номер такта процессора в соответствующие моменты времени.
Частота отслеживаемых часов задаётся как константный параметр <code>TICKS_PER_SECOND</code> для типа
<a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html"><code>struct CorrelationInterval&lt;const TICKS_PER_SECOND: i64&gt;</code></a>.</p>
<p>По этой информации можно:</p>
<ul>
<li>Вычислить частоту процессора с точки зрения отслеживаемых часов.</li>
<li>Пересчитать произвольное значение счётчика тактов процессора <a href="../../doc/ku/time/tsc/struct.Tsc.html"><code>ku::time::tsc::Tsc</code></a> в показания времени отслеживаемых часов. При этом мы фактически повышаем разрешение отслеживаемых часов до частоты процессора. Разумеется, погрешность при этом превышает разрешение.</li>
</ul>
<p>Для часов реального времени
<a href="../../doc/ku/time/rtc/struct.Rtc.html"><code>ku::time::rtc::Rtc</code></a>,
количество тиков в каждом поле
<a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html#structfield.count"><code>CorrelationPoint::count</code></a>
содержит количество секунд с начала Unix–эпохи.
Методы
<a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html"><code>CorrelationInterval</code></a>
будут опираться на это при привязке своих
<a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html"><code>CorrelationPoint</code></a>
к реальному времени.</p>
<p>Структура
<a href="../../doc/ku/time/correlation_interval/struct.AtomicCorrelationInterval.html"><code>ku::time::correlation_interval::AtomicCorrelationInterval</code></a>
содержит аналогичные два поля типа
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a>.
Она находится в таких же отношениях с
<a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html"><code>CorrelationInterval</code></a>,
как
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a>
с
<a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html"><code>CorrelationPoint</code></a>.
То есть,
<a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html"><code>CorrelationInterval</code></a>
является значением, а
<a href="../../doc/ku/time/correlation_interval/struct.AtomicCorrelationInterval.html"><code>AtomicCorrelationInterval</code></a>
его конкурентным хранилищем в памяти.</p>
<blockquote>
<p>Подумайте, почему при этом
<a href="../../doc/ku/time/correlation_interval/struct.AtomicCorrelationInterval.html"><code>AtomicCorrelationInterval</code></a>
устроен гораздо проще чем
<a href="../../doc/ku/time/correlation_point/struct.AtomicCorrelationPoint.html"><code>AtomicCorrelationPoint</code></a>
с его <a href="https://en.wikipedia.org/wiki/Seqlock">sequence lock</a>.</p>
</blockquote>
<p>Основной <a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html#method.datetime">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn CorrelationInterval::datetime&lt;const PARTS_PER_SECOND: i64&gt;(
    atomic_correlation_interval: &amp;AtomicCorrelationInterval&lt;TICKS_PER_SECOND&gt;,
    tsc: Tsc,
) -&gt; DateTime&lt;Utc&gt;
<span class="boring">}
</span></code></pre></pre>
<p>должен для часов, к которым привязан <code>atomic_correlation_interval</code>, выдать время, соответствующее
такту процессора, записанному в <code>tsc</code>.
Время он возвращает в типе
<a href="../../doc/chrono/struct.DateTime.html"><code>chrono::DateTime</code></a>.
Он считает, что заданные ему часы показывают количество секунд, прошедших с начала Unix–эпохи в UTC —
<a href="../../doc/chrono/offset/struct.Utc.html"><code>chrono::offset::Utc</code></a>.</p>
<p>Функции
<a href="../../doc/ku/time/fn.datetime.html"><code>ku::time::datetime()</code></a>
<a href="../../doc/ku/time/fn.datetime_ms.html"><code>ku::time::datetime_ms()</code></a>
используя этот метод повышают разрешение часов реального времени
<a href="../../doc/ku/time/rtc/struct.Rtc.html"><code>ku::time::rtc::Rtc</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn datetime(tsc: Tsc) -&gt; DateTime&lt;Utc&gt; {
    Rtc::datetime::&lt;NSECS_PER_SEC&gt;(tsc)
}

pub fn datetime_ms(tsc: Tsc) -&gt; DateTime&lt;Utc&gt; {
    Rtc::datetime::&lt;MSECS_PER_SEC&gt;(tsc)
}

const MSECS_PER_SEC: i64 = 1_000;
const NSECS_PER_SEC: i64 = 1_000_000_000;
<span class="boring">}
</span></code></pre></pre>
<p>Метод
<a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html#method.datetime"><code>CorrelationInterval::datetime()</code></a>
читает переданный ему на вход <code>atomic_correlation_interval</code>, проверяет что в результирующем
<a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html"><code>CorrelationInterval</code></a>
оба поля —
<a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html#structfield.base"><code>CorrelationInterval::base</code></a> и
<a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html#structfield.prev"><code>CorrelationInterval::prev</code></a> —
валидны и задают разные тики базовых часов.
Если это так, он перекладывает основную работу на вспомогательный
<a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html#method.datetime_with_resolution">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn CorrelationInterval::datetime_with_resolution&lt;const PARTS_PER_SECOND: i64&gt;(
    &amp;self,
    tsc: Tsc,
) -&gt; NaiveDateTime
<span class="boring">}
</span></code></pre></pre>
<p>В тех редких случаях, когда в <code>atomic_correlation_interval</code> ещё не прошло два тика часов, метод
<a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html#method.datetime"><code>CorrelationInterval::datetime()</code></a>
возвращает момент времени
<a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html#structfield.prev"><code>CorrelationInterval::prev</code></a>
в виде
<a href="../../doc/chrono/struct.DateTime.html"><code>DateTime</code></a>.
Мы заметим это на старте системы по низкому — секундному — разрешению в записях лога.</p>
<h3 id="Задача-3--реализация-основного-метода-повышения-разрешения-часов"><a class="header" href="#Задача-3--реализация-основного-метода-повышения-разрешения-часов">Задача 3 — реализация основного метода повышения разрешения часов</a></h3>
<p>Для этой задачи понадобится готовое решение <a href="../../lab/book/1-time-1-rtc.html#%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-1--%D1%87%D1%82%D0%B5%D0%BD%D0%B8%D0%B5-%D1%80%D0%B5%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%B8-%D0%B8%D0%B7-%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D1%81%D1%85%D0%B5%D0%BC%D1%8B-rtc">задачи 1</a>.</p>
<p>Реализуйте метод
<a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html#method.datetime_with_resolution"><code>fn CorrelationInterval::datetime_with_resolution()</code></a>.</p>
<ul>
<li>Считайте, что <code>self.base.count()</code> и <code>self.prev.count()</code> задают разные секунды с начала Unix–эпохи.</li>
<li>Необходимо вернуть реальное время, которое соответствует такту номер <code>tsc.get()</code> процессора. Он может быть как больше <code>self.prev.tsc()</code>, так и меньше <code>self.base.tsc()</code>, а может лежать где-то между ними. Чтобы все эти варианты можно было поддержать, такты процессора хранятся в знаковом типе <a href="https://doc.rust-lang.org/nightly/core/primitive.i64.html"><code>i64</code></a>.</li>
<li>Результат возвращается в типе <a href="../../doc/chrono/naive/struct.NaiveDateTime.html"><code>chrono::naive::NaiveDateTime</code></a>, который не содержит данных о часовом поясе. Идентификатор часового пояса добавит вызывающая функция.</li>
<li>Запрошенное разрешение <code>PARTS_PER_SECOND</code> задаётся в единицах в секунду, например для миллисекунд <code>PARTS_PER_SECOND = 1_000</code>. Оно не будет выше наносекунд — <code>PARTS_PER_SECOND = 1_000_000_000</code>, — которые поддерживает <a href="../../doc/chrono/naive/struct.NaiveDateTime.html"><code>NaiveDateTime</code></a>.</li>
<li><a href="https://en.wikipedia.org/wiki/Leap_second">Високосные секунды</a> не поддерживаем.</li>
</ul>
<h4 id="Зависание-при-логировании"><a class="header" href="#Зависание-при-логировании">Зависание при логировании</a></h4>
<p>Если попробовать добавить логирование в метод
<a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html#method.datetime_with_resolution"><code>CorrelationInterval::datetime_with_resolution()</code></a>,
то код зависнет.
Логирование само использует
<a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html#method.datetime_with_resolution"><code>CorrelationInterval::datetime_with_resolution()</code></a>,
поэтому можно было бы ожидать, что возникнет бесконечная рекурсия:</p>
<ul>
<li><code>debug!()</code> или другой макрос логирования вызывает <code>datetime_with_resolution()</code>.</li>
<li>Который вызывает <code>debug!()</code> или другой макрос логирования.</li>
<li>Который вызывает <code>datetime_with_resolution()</code>.</li>
<li>…</li>
<li>В конце-концов произошло бы исчерпание стека и падение ядра по Page Fault.</li>
</ul>
<p>Бесконечной рекурсии не происходит из-за дополнительной блокировки в логировании — поле
<a href="../../doc/kernel/log/struct.LogCollector.html#structfield.log"><code>kernel::log::LogCollector::log</code></a>
имеет тип
<a href="../../doc/spin/type.Mutex.html"><code>spin::Mutex</code></a><code>&lt;</code><a href="../../doc/kernel/log/struct.Log.html"><code>kernel::log::Log</code></a><code>&gt;</code>.
Основное предназначение этой блокировки —
предотвратить перемешивание кусков сообщений от разных процессоров в системе.</p>
<p>А вот бесконечную рекурсию она переводит во <a href="https://en.wikipedia.org/wiki/Deadlock">взаимоблокировку</a>.
Когда происходит вызов логирования, блокировка захватывается.
С захваченной блокировкой происходит вызов
<a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html#method.datetime_with_resolution"><code>CorrelationInterval::datetime_with_resolution()</code></a>.
Если он сам вызывает логирование, то происходит попытка рекурсивного захвата уже захваченной блокировки.
Она не поддерживает рекурсивный захват, поэтому происходит
<a href="https://en.wikipedia.org/wiki/Deadlock">взаимоблокировка</a>,
которая и проявляется как зависание.
Факт <a href="https://en.wikipedia.org/wiki/Deadlock">взаимоблокировки</a>,
какую конкретно блокировку и какая строка кода пытается захватить,
легко узнать из <code>(gdb) backtrace</code>, прервав зависший код из <code>gdb</code> комбинацией <code>&lt;Ctrl-C&gt;</code>:</p>
<pre><code>...
0x000000000000fff0 in ?? ()
(gdb) continue
Continuing.
^C
Thread 1 received signal SIGINT, Interrupt.
0x00000000002ecd9c in core::sync::atomic::atomic_load&lt;u8&gt; (dst=0x320b40 &lt;kernel::log::LOG_COLLECTOR+8&gt;, order=core::sync::atomic::Ordering::Relaxed) at src/sync/atomic.rs:2960
2960	        match order {
(gdb) backtrace
#0  0x00000000002ecd9c in core::sync::atomic::atomic_load&lt;u8&gt; (dst=0x320b40 &lt;kernel::log::LOG_COLLECTOR+8&gt;, 
    order=core::sync::atomic::Ordering::Relaxed) at src/sync/atomic.rs:2960
#1  0x000000000022a11f in core::sync::atomic::AtomicBool::load (self=0x320b40 &lt;kernel::log::LOG_COLLECTOR+8&gt;, 
    order=core::sync::atomic::Ordering::Relaxed)
    at /home/sergey/.rustup/toolchains/nightly-2022-08-30-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:456
#2  0x000000000025d49f in spin::mutex::spin::SpinMutex&lt;kernel::log::Log, spin::relax::Spin&gt;::is_locked&lt;kernel::log::Log, spin::relax::Spin&gt; (self=0x320b40 &lt;kernel::log::LOG_COLLECTOR+8&gt;)
    at /home/sergey/.cargo/registry/src/github.com-1ecc6299db9ec823/spin-0.9.4/src/mutex/spin.rs:192
#3  spin::mutex::spin::SpinMutex&lt;kernel::log::Log, spin::relax::Spin&gt;::lock&lt;kernel::log::Log, spin::relax::Spin&gt; (
    self=0x320b40 &lt;kernel::log::LOG_COLLECTOR+8&gt;)
    at /home/sergey/.cargo/registry/src/github.com-1ecc6299db9ec823/spin-0.9.4/src/mutex/spin.rs:171
#4  spin::mutex::Mutex&lt;kernel::log::Log, spin::relax::Spin&gt;::lock&lt;kernel::log::Log, spin::relax::Spin&gt; (
    self=0x320b40 &lt;kernel::log::LOG_COLLECTOR+8&gt;)
    at /home/sergey/.cargo/registry/src/github.com-1ecc6299db9ec823/spin-0.9.4/src/mutex.rs:170
#5  kernel::log::{impl#4}::event (self=0x320b38 &lt;kernel::log::LOG_COLLECTOR&gt;, event=0x10000200c10)
    at kernel/src/log.rs:241
...
#11 0x00000000002b85a2 in ku::time::correlation_interval::CorrelationInterval&lt;1&gt;::datetime_with_resolution&lt;1, 1000&gt; (
    self=0x10000200fa8, tsc=...) at ku/src/time/correlation_interval.rs:61
#12 0x00000000002b8059 in ku::time::correlation_interval::CorrelationInterval&lt;1&gt;::datetime&lt;1, 1000&gt; (
    atomic_correlation_interval=0x344030 &lt;kernel::SYSTEM_INFO+48&gt;, tsc=...) at ku/src/time/correlation_interval.rs:46
#13 0x00000000002b4d08 in ku::time::rtc::Rtc::datetime&lt;1000&gt; (tsc=...) at ku/src/time/rtc.rs:22
#14 0x00000000002b4656 in ku::time::datetime_ms (tsc=...) at ku/src/time/mod.rs:49
#15 0x000000000025cb47 in kernel::log::Log::log_metadata (self=0x320b41 &lt;kernel::log::LOG_COLLECTOR+9&gt;, 
    level=0x30c030 &lt;kernel::kernel_main::CALLSITE::META+32&gt;, metadata=...) at kernel/src/log.rs:144
#16 0x000000000025cabe in kernel::log::Log::log_event (self=0x320b41 &lt;kernel::log::LOG_COLLECTOR+9&gt;, 
    event=0x100002012b0, tsc=...) at kernel/src/log.rs:133
#17 0x000000000025d512 in kernel::log::{impl#4}::event (self=0x320b38 &lt;kernel::log::LOG_COLLECTOR&gt;, 
    event=0x100002012b0) at kernel/src/log.rs:241
...
</code></pre>
<p>Фрейм <code>#2</code> сообщает нам, что код крутится в <code>SpinMutex&lt;kernel::log::Log&gt;</code>, принадлежащей
<a href="../../doc/kernel/log/static.LOG_COLLECTOR.html"><code>kernel::log::LOG_COLLECTOR</code></a>:</p>
<pre><code>#2  0x000000000025d49f in spin::mutex::spin::SpinMutex&lt;kernel::log::Log, spin::relax::Spin&gt;::is_locked&lt;kernel::log::Log, spin::relax::Spin&gt; (self=0x320b40 &lt;kernel::log::LOG_COLLECTOR+8&gt;)
</code></pre>
<p>Фрейм <code>#5</code> сообщает где вызывается повторный захват блокировки — в строке <code>kernel/src/log.rs:241</code> метода <code>event()</code>:</p>
<pre><code>#5  kernel::log::{impl#4}::event (self=0x320b38 &lt;kernel::log::LOG_COLLECTOR&gt;, event=0x10000200c10)
    at kernel/src/log.rs:241
</code></pre>
<p>А по фрейму <code>#17</code> видно, что блокировка уже была захвачена той же строкой кода:</p>
<pre><code>#17 0x000000000025d512 in kernel::log::{impl#4}::event (self=0x320b38 &lt;kernel::log::LOG_COLLECTOR&gt;, 
    event=0x100002012b0) at kernel/src/log.rs:241
</code></pre>
<p>Отладить метод
<a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html#method.datetime_with_resolution"><code>fn CorrelationInterval::datetime_with_resolution()</code></a>.
с помощью логирования можно разорвав бесконечную рекурсию.
Например, не вызывая функции времени из логирования.
Для этого служит формат
<a href="../../doc/kernel/log/enum.Format.html#variant.Timeless"><code>kernel::log::Format::Timeless</code></a>.
Чтобы воспользоваться им, измените строку инициализации
<a href="../../doc/kernel/log/static.LOG_COLLECTOR.html"><code>kernel::log::LOG_COLLECTOR</code></a>
в конце файла
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/log.rs"><code>kernel/src/log.rs</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static LOG_COLLECTOR: LogCollector = LogCollector::new(Format::Timeless, Level::DEBUG);
<span class="boring">}
</span></code></pre></pre>
<p>Также иногда можно убирать
<a href="../../doc/spin/type.Mutex.html"><code>Mutex</code></a>
из поля
<a href="../../doc/kernel/log/struct.LogCollector.html#structfield.log"><code>kernel::log::LogCollector::log</code></a>.
Если на нём возникает <a href="https://en.wikipedia.org/wiki/Deadlock">взаимоблокировка</a>.
А перемешивание записей логов не мешает отладке или вообще не возникает при использования только одного процессора.</p>
<h3 id="Запуск-тестов-2"><a class="header" href="#Запуск-тестов-2">Запуск тестов</a></h3>
<p>Тесты можно запустить командой <code>cargo test --test 1-time-3-high-resolution-date</code> в директории <code>kernel</code> репозитория.</p>
<p>После выполнения задачи должен проходить тест <code>high_resolution_date()</code>
в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/time.rs"><code>kernel/tests/time.rs</code></a>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 1-time-3-high-resolution-date)
...
time::high_resolution_date----------------------------------
10:39:50.562 0 D waiting for the RTC to tick twice
10:39:52.001 0 D measuring; timer_ticks = 102
10:39:57.015 0 D measured; samples = 100; min = PT0.049911511S; max = PT0.050046701S; mean = PT0.049999155S; deviation = PT0.000020516S
10:39:57.024 0 D restrictions; min_delta = PT0.040S; max_delta = PT0.060S; min_mean = PT0.049500S; max_mean = PT0.050500S; min_deviation = PT0.000000100S; max_deviation = PT0.005S
time::high_resolution_date------------------------- [passed]
</code></pre>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-2"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-2">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> ku/src/time/correlation_interval.rs |   26 ++++++++++++++++++++++++--
 1 file changed, 24 insertions(+), 2 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Обработка-прерываний-rtc"><a class="header" href="#Обработка-прерываний-rtc">Обработка прерываний RTC</a></h2>
<p>Как вы помните, при инициализации RTC функция
<a href="../../doc/kernel/time/rtc/fn.init.html"><code>kernel::time::rtc::init()</code></a>
включает <a href="https://en.wikipedia.org/wiki/Interrupt">прерывание</a>,
которое сигнализирует о том, что RTC обновил свою информацию о времени и дате:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let new_settings = ...
    RegisterB::UPDATE_ENDED_INTERRUPT |
    ...
<span class="boring">}
</span></code></pre></pre>
<p>Оно приходит каждую секунду.
Обработчик прерываний устроен так:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;x86-interrupt&quot; fn rtc(_context: InterruptContext) {
    INTERRUPT_STATS[RTC].inc();
    rtc::interrupt();
}
<span class="boring">}
</span></code></pre></pre>
<p>он увеличивает счётчик прерываний от RTC в структуре
<a href="../../doc/kernel/interrupts/static.INTERRUPT_STATS.html"><code>kernel::interrupts::INTERRUPT_STATS</code></a>,
которая является массивом элементов типа
<a href="../../doc/kernel/interrupts/struct.Statistics.html"><code>kernel::interrupts::Statistics</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Statistics {
    count: AtomicUsize,
    mnemonic: &amp;'static str,
    name: &amp;'static str,
}
<span class="boring">}
</span></code></pre></pre>
<p>И кроме счётчика прерываний
<a href="../../doc/kernel/interrupts/struct.Statistics.html#structfield.count"><code>Statistics::count</code></a>,
содержит также имя и короткую мнемонику конкретного прерывания.
Достать значение счётчика из неё можно методом
<a href="../../doc/kernel/interrupts/struct.Statistics.html#method.count"><code>Statistics::count()</code></a>.</p>
<p>Основную работу
<a href="../../doc/kernel/interrupts/fn.rtc.html"><code>kernel::interrupts::rtc()</code></a>
перекладывает на
<a href="../../doc/kernel/time/rtc/fn.interrupt.html"><code>kernel::time::rtc::interrupt()</code></a>,
которая определена в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/time/rtc.rs"><code>kernel/src/time/rtc.rs</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub(crate) fn interrupt() {
    if interrupt_status().contains(RegisterC::UPDATE_ENDED_INTERRUPT) {
        if let Some(timestamp) = timestamp() {
            let now = CorrelationPoint::now(timestamp * TICKS_PER_SECOND);
            let rtc = SYSTEM_INFO.rtc();
            rtc.init_base(now);
            rtc.store_prev(now);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Вы уже знакомы почти со всеми кусочками, которые использует этот код.
Краткое напоминание:</p>
<ul>
<li><a href="../../doc/kernel/time/rtc/fn.timestamp.html"><code>timestamp()</code></a> читает дату и время из микросхемы RTC и переводит их в секунды от начала Unix–эпохи.</li>
<li><a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html#method.now"><code>CorrelationPoint::now()</code></a> добавляет к этому значению текущий номер такта процессора.</li>
<li><code>rtc.init_base(now)</code> сохраняет получившуюся пару <code>now</code> в поле <a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html#structfield.base"><code>CorrelationInterval::base</code></a>, если оно ещё не было инициализировано. То есть, это происходит только на первом прерывании.</li>
<li>А <code>rtc.store_prev(now)</code> сохраняет пару <code>now</code> в поле <a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html#structfield.prev"><code>CorrelationInterval::prev</code></a> на каждом прерывании.</li>
</ul>
<p>Таким образом,
<a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html#method.datetime"><code>CorrelationInterval::datetime()</code></a>
может прочитать эти сохранённые значения и,
если RTC уже дважды тикнул, то оценить текущее время по нему и одновременно по счётчику тактов процессора,
с разрешением выше секунды.
Если же RTC ещё не тикнул дважды, то
<a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html#method.datetime"><code>CorrelationInterval::datetime()</code></a>
может выдать последнее прочитанное из RTC значение, имеющее разрешение в секунду.
Для того чтобы не ждать значение
<a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html#structfield.prev"><code>CorrelationInterval::prev</code></a>
до первого тика RTC, функция
<a href="../../doc/kernel/time/rtc/fn.init.html"><code>kernel::time::rtc::init()</code></a>
на старте записывает в него значение даты и времени из RTC:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let rtc = SYSTEM_INFO.rtc();
rtc.store_prev(CorrelationPoint::invalid(timestamp() * TICKS_PER_SECOND));
<span class="boring">}
</span></code></pre></pre>
<p>При этом
<a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html#method.invalid"><code>CorrelationPoint::invalid()</code></a>
помечает, что этим значением нельзя пользоваться для оценки частоты процессора и текущего времени высокого разрешения.
Так как оно взято в случайный момент между тиками RTC.
А не привязано по времени к определённому тику за счёт вызова из прерывания RTC.</p>
<p>Остаётся понять, что же такое <a href="../../doc/ku/info/static.SYSTEM_INFO.html"><code>SYSTEM_INFO</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Информация-о-системе"><a class="header" href="#Информация-о-системе">Информация о системе</a></h2>
<p>Ядро предоставляет пользовательским процессам часть информации о системе,
сохраняя её в памяти, доступной пользователю на чтение.
Эта информация собирается в виде структуры общей информации о системе
<a href="../../doc/ku/info/struct.SystemInfo.html"><code>ku::info::SystemInfo</code></a>
и в виде структуры с информацией о текущем процессе
<a href="../../doc/ku/info/struct.ProcessInfo.html"><code>ku::info::ProcessInfo</code></a>,
которые определены в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/info.rs"><code>ku/src/info.rs</code></a>.</p>
<p>В частности, в поле
<a href="../../doc/ku/info/struct.SystemInfo.html#structfield.rtc"><code>SystemInfo::rtc</code></a>
процессу пользователя доступен
<a href="../../doc/ku/time/correlation_interval/struct.AtomicCorrelationInterval.html"><code>AtomicCorrelationInterval</code></a>
для показаний RTC.
А также, например, идентификатор текущего процесса в поле
<a href="../../doc/ku/info/struct.ProcessInfo.html#structfield.pid"><code>ProcessInfo::pid</code></a>.</p>
<p>Пользовательские процессы сохраняют указатели на предоставляемую ядром информацию в глобальных переменных
<a href="../../doc/ku/info/static.PROCESS_INFO.html"><code>ku::info::PROCESS_INFO</code></a>
и
<a href="../../doc/ku/info/static.SYSTEM_INFO.html"><code>ku::info::SYSTEM_INFO</code></a>.
За это отвечает функция <a href="../../doc/lib/fn._start.html"><code>lib::_start()</code></a>
в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/user/lib/src/lib.rs"><code>user/lib/src/lib.rs</code></a>,
с которой начинается выполнение процессов, подключивших библиотеку <code>user/lib</code> в своём <code>Cargo.toml</code>.</p>
<p>Поэтому пользовательский процесс может узнать свой идентификатор или текущее системное время,
не делая никаких системных вызовов, а просто читая из памяти.
То есть, без переключения в контекст ядра, что было бы дольше.
Ядро даже не предоставляет системных вызовов для выяснения времени или идентификатора процесса.
Это похоже на механизм
<a href="https://en.wikipedia.org/wiki/VDSO">virtual dynamic shared object (vDSO)</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Собирая-всё-вместе"><a class="header" href="#Собирая-всё-вместе">Собирая всё вместе</a></h2>
<p>В файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/main.rs"><code>kernel/src/main.rs</code></a> определена функция <code>kernel_main()</code>.
Вы можете использовать её по своему усмотрению, например проверяя какую-нибудь функциональность.</p>
<p>Например:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! {
    kernel::init_subsystems(boot_info, Subsystems::empty());

    while INTERRUPT_STATS[RTC].count() &lt; 10 {
        if let Some(frequency) = Pit::tsc_per_second() {
            debug!(%frequency, &quot;CPU frequency measured by PIT&quot;);
        }

        if let Some(frequency) = Rtc::tsc_per_second() {
            debug!(%frequency, &quot;CPU frequency measured by RTC&quot;);
        }

        debug!(time_precision = %time::timer().lap());

        for (number, stats) in INTERRUPT_STATS.iter().enumerate() {
            let count = stats.count();
            if count != 0 {
                let mnemonic = stats.mnemonic();
                debug!(number, %mnemonic, count, &quot;interrupt stats&quot;);
            }
        }

        x86_64::instructions::hlt();
    }

    kernel::exit_qemu(ExitCode::SUCCESS);
}
<span class="boring">}
</span></code></pre></pre>
<p>Сначала выполняется инициализация системы функцией
<a href="../../doc/kernel/fn.init.html"><code>kernel::init()</code></a>
из файла <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/lib.rs"><code>kernel/src/lib.rs</code></a>.
А затем мы в цикле выводим в лог статистику счётчиков прерываний и
вычисленную с помощью RTC и PIT частоту процессора.
Инструкция
<a href="https://www.felixcloutier.com/x86/hlt"><code>HLT</code></a>,
которую мы используем через функцию
<a href="../../doc/x86_64/instructions/fn.hlt.html"><code>x86_64::instructions::hlt()</code></a>,
выключает процессор до прихода следующего прерывания.
Реализация PIT устроена также, как и изученная вами реализация RTC.
Только он настроен тикать 20 раз в секунду и не привязан к реальному времени.</p>
<p>Запускаем:</p>
<pre><code class="language-console">$ make run
</code></pre>
<p>или</p>
<pre><code class="language-console">$ (cd kernel; cargo run)
</code></pre>
<p>В файле <code>kernel/serial.out</code> появляется лог, время должно соответствовать команде <code>date -u</code>:</p>
<pre><code class="language-console">14:58:18 0 I RTC init; acknowledged_settings = USE_24_HOUR_FORMAT | USE_BINARY_FORMAT | UPDATE_ENDED_INTERRUPT
14:58:18 0 I time init
14:58:18 0 I Nikka booted; now = 2022-09-17 14:58:18 UTC; tsc = Tsc(5139186658)
14:58:18 0 I GDT init
14:58:18 0 I interrupts init
</code></pre>
<p>Видно, что RTC инициализировался, и выдаёт разумное время — <code>now = 2022-09-17 14:58:18 UTC</code>.
А время в логе пока имеет разрешение в секунду.
Дальше запускается наш цикл сбора статистик прерываний.
На первой итерации их ещё нет и он печатает только одну строку:</p>
<pre><code class="language-console">14:58:18 0 D time_precision = 61.005 ktsc
</code></pre>
<p>Так как мы пока не откалибровали частоту процессора, в ней точность времени указана в тысячах его тиков — <code>ktsc</code>.
Потом тикает PIT:</p>
<pre><code class="language-console">14:58:18 0 D CPU frequency measured by PIT; frequency = 3.434 GHz
14:58:18 0 D time_precision = 2.572 ktsc
14:58:18 0 D interrupt stats; number = 32; mnemonic = #TI; count = 1
</code></pre>
<p>Он сразу готов оценить частоту процессора, так как при инициализации в его
<a href="../../doc/ku/time/correlation_interval/struct.CorrelationInterval.html#structfield.base"><code>CorrelationInterval::base</code></a>
записывается валидное значение с
<a href="../../doc/ku/time/correlation_point/struct.CorrelationPoint.html#structfield.count"><code>CorrelationPoint::count</code></a>
равным нулю.
Ждём дальше.
PIT тикает уже 9 раз, и в первый раз тикает RTC.
Текущее время в логе увеличивается на 1 секунду:</p>
<pre><code class="language-console">14:58:19 0 D time_precision = 2.871 ktsc
14:58:19 0 D interrupt stats; number = 32; mnemonic = #TI; count = 9
14:58:19 0 D interrupt stats; number = 40; mnemonic = #RT; count = 1
14:58:19 0 D CPU frequency measured by PIT; frequency = 3.773 GHz
</code></pre>
<p>RTC тикает во второй раз, и на основе его показаний уже можно оценить частоту процессора.
Также увеличивается разрешение системного времени в лог–записях:</p>
<pre><code>14:58:20.001 0 D CPU frequency measured by PIT; frequency = 3.557 GHz
14:58:20.005 0 D CPU frequency measured by RTC; frequency = 3.424 GHz
14:58:20.009 0 D time_precision = 881.745 ns
14:58:20.016 0 D interrupt stats; number = 32; mnemonic = #TI; count = 28
14:58:20.020 0 D interrupt stats; number = 40; mnemonic = #RT; count = 2
</code></pre>
<p>А вычисление интервалов времени начинает опираться на секунды — <code>time_precision = 881.745 ns</code>.
То есть, между последовательными обращениями к <code>RDTSC</code> проходит около 881 наносекунд.
Такая низкая точность объясняется дебажной сборкой.</p>
<p>Если же собрать релизную, то получим более разумную цифру:</p>
<pre><code class="language-console">$ (cd kernel; cargo run --release)
...
15:08:31.792 0 D time_precision = 93.029 ns
</code></pre>
<p>Правда, она всё ещё далека от идеала.
Это связано с запуском под эмулятором.
Если запустить Nikka на железе, то получаем прерно 30–80 тактов, или около 10-20 наносекунд:
<img src="1-time-7-time-precision.png" alt="" /></p>
<blockquote>
<h3 id="Больше-информации-про-время-в-компьютерных-системах"><a class="header" href="#Больше-информации-про-время-в-компьютерных-системах">Больше информации про время в компьютерных системах</a></h3>
<p>Если вас заинтересовала тема отслеживания времени в компьютерных системах,
вы можете посмотреть небольшой отрывок с <a href="https://lk.yandexdataschool.ru/courses/2021-autumn/7.946-raspredelennye-sistemy/classes/7879/">семинара из курса распределённых систем</a>.
В <a href="https://disk.yandex.ru/i/MwH4kiQ_p4XCsA">видеозаписи</a> он начинается с 44:44.
Там, в частности рассказано:</p>
<ul>
<li>Что такое високосные секунды.</li>
<li>Оказывается, есть несколько стандартов текущего времени. И некоторые из них зависят, например, от приливов.</li>
<li>Как устроено отслеживание точного времени на Земле.</li>
<li>Про несколько серьёзных компьютерных сбоев, связанных с неаккуратной работой со временем в программах. Например, про <a href="https://blog.cloudflare.com/how-and-why-the-leap-second-affected-cloudflare-dns/">сбой в Cloudflare</a> из-за использования немонотонных часов при измерении интервала времени.</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Память"><a class="header" href="#Память">Память</a></h2>
<p>В этой лабораторке нужно будет написать функции управления памятью в операционной системе Nikka.
Для вашего удобства, лабораторка разбита на 13 задач в трёх блоках, которые нужно делать по порядку:</p>
<ul>
<li>Временный аллокатор физических фреймов.</li>
<li>Виртуальное адресное пространство.</li>
<li>Основной аллокатор физических фреймов.</li>
</ul>
<h3 id="Код-работы-с-памятью-в-nikka-собран-в-модули"><a class="header" href="#Код-работы-с-памятью-в-nikka-собран-в-модули">Код работы с памятью в Nikka собран в модули</a></h3>
<ul>
<li>
<p><a href="../../doc/kernel/memory/index.html"><code>kernel::memory</code></a> в директории <code>kernel/src/memory</code>. Здесь находится часть работы с памятью, которая происходит только в ядре.</p>
<ul>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/mod.rs"><code>kernel/src/memory/mod.rs</code></a> — корневая часть модуля <a href="../../doc/kernel/memory/index.html"><code>kernel::memory</code></a>.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/address_space.rs"><code>kernel/src/memory/address_space.rs</code></a> — абстракция адресного пространства <code>AddressSpace</code>.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/boot_frame_allocator.rs"><code>kernel/src/memory/boot_frame_allocator.rs</code></a> — временный аллокатор физических фреймов <code>BootFrameAllocator</code>.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/gdt.rs"><code>kernel/src/memory/gdt.rs</code></a> — таблица сегментов памяти <code>Gdt</code>.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/main_frame_allocator.rs"><code>kernel/src/memory/main_frame_allocator.rs</code></a> — основной аллокатор физических фреймов <code>MainFrameAllocator</code>.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/mapping.rs"><code>kernel/src/memory/mapping.rs</code></a> — реализация отображения виртуальной памяти в физическую <code>Mapping</code>.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/page_allocator.rs"><code>kernel/src/memory/page_allocator.rs</code></a> — аллокатор страниц виртуальной памяти <code>PageAllocator</code>.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/stack.rs"><code>kernel/src/memory/stack.rs</code></a> — работа со стеками <code>Stack</code> и выделенные стеки для непредвиденных исключений <code>ExceptionStacks</code>.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/tss.rs"><code>kernel/src/memory/tss.rs</code></a> — сегмент состояния задачи (<a href="https://en.wikipedia.org/wiki/Task_state_segment">task state segment</a>, TSS).</li>
</ul>
</li>
<li>
<p><a href="../../doc/ku/memory/index.html"><code>ku::memory</code></a> в директории <code>ku/src/memory</code>. Здесь собраны базовые примитивы для работы с памятью, которые нужны и в ядре, и в пространстве пользователя.</p>
<ul>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/memory/mod.rs"><code>ku/src/memory/mod.rs</code></a> — корневая часть модуля <a href="../../doc/ku/memory/index.html"><code>ku::memory</code></a>.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/memory/addr.rs"><code>ku/src/memory/addr.rs</code></a> — работа с адресами <code>Addr</code>, <code>Virt</code> и <code>Phys</code>.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/memory/block.rs"><code>ku/src/memory/block.rs</code></a> — работа с блоками памяти <code>Block</code>.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/memory/frage.rs"><code>ku/src/memory/frage.rs</code></a> — физические фреймы <code>Frame</code>, виртуальные страницы <code>Page</code>, и их общие аспекты <code>Frage</code>.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/memory/mmu.rs"><code>ku/src/memory/mmu.rs</code></a> — работа с блоком управления памятью (<a href="https://en.wikipedia.org/wiki/Memory_management_unit">memory management unit</a>, MMU), описывает таблицы страниц <code>PageTable</code>, их записи <code>PageTableEntry</code>, флаги доступа <code>PageTableFlags</code>.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/memory/page_fault_info.rs"><code>ku/src/memory/page_fault_info.rs</code></a> — информация об <a href="https://en.wikipedia.org/wiki/Page_fault">исключении доступа к странице</a> (Page Fault) в виде <code>PageFaultInfo</code>.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/memory/size.rs"><code>ku/src/memory/size.rs</code></a> — абстракция размера в памяти <code>Size</code>.</li>
</ul>
</li>
</ul>
<h3 id="Ориентировочный-объём-работ-этой-лабораторки-1"><a class="header" href="#Ориентировочный-объём-работ-этой-лабораторки-1">Ориентировочный объём работ этой лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/memory/address_space.rs        |   20 ++++-
 kernel/src/memory/boot_frame_allocator.rs |   43 ++++++++++-
 kernel/src/memory/main_frame_allocator.rs |  116 ++++++++++++++++++++++++++++--
 kernel/src/memory/mapping.rs              |   88 +++++++++++++++++++++-
 kernel/src/memory/page_allocator.rs       |   32 +++++++-
 ku/src/memory/block.rs                    |    8 +-
 6 files changed, 289 insertions(+), 18 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Физические-и-виртуальные-адреса"><a class="header" href="#Физические-и-виртуальные-адреса">Физические и виртуальные адреса</a></h2>
<p>Ядру приходится работать с двумя разными множествами адресов — физическими и виртуальными.
Прикладные программы обычно работают только с виртуальными адресами, поэтому необходимость разделять множества физических и виртуальных адресов может быть непривычна.
Но это один из важных моментов, который придётся держать в голове, выполняя лабораторную работу.
И желание произвольно преобразовывать между собой указатели и целые числа, содержащие адреса, может привести к большим проблемам.
Если где-то перепутать физический адрес с виртуальным, или просто тождественно преобразовать битовое представление одного типа адреса в другой, то результатом будет неопределённое поведение.
Усугубляющееся тем, что оно возникло не в пользовательском коде, а в ядре.
Оно, например, может привести к перезагрузке компьютера с потерей данных, необходимых для отладки.</p>
<p>В частности поэтому, запускать ОС мы будем не на физическом железе, а в эмуляторе qemu.
Так отлаживать будет проще.
К qemu можно подключить gdb и отлаживать ядро практически как обычный пользовательский код.
Кроме того, мы выведем логирование в COM-порт, а всё что будем в него писать, средствами qemu перенаправим в файл.
Так логи не потеряются даже если эмулируемая машина перезагрузится.</p>
<h2 id="Типы-для-работы-с-памятью-и-базовые-преобразования"><a class="header" href="#Типы-для-работы-с-памятью-и-базовые-преобразования">Типы для работы с памятью и базовые преобразования</a></h2>
<p>Для того чтобы было проще не перепутать физические и виртуальные адреса, мы не будем для них использовать базовые типы <a href="https://doc.rust-lang.org/nightly/core/primitive.usize.html"><code>usize</code></a>/<a href="https://doc.rust-lang.org/nightly/core/primitive.u64.html"><code>u64</code></a>.
Вместо этого вводятся два разных высокоуровневых типа, которые сделаны несовместимы:</p>
<ul>
<li><a href="../../doc/ku/memory/addr/type.Phys.html"><code>Phys</code></a> для физических адресов;</li>
<li><a href="../../doc/ku/memory/addr/type.Virt.html"><code>Virt</code></a> для виртуальных.</li>
</ul>
<p>Так что если присвоить переменной виртуального адреса значение физического, или наоборот,</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let phys = Phys::new(0x123ABC);
let virt: Virt;
virt = phys;
<span class="boring">}
</span></code></pre></pre>
<p>компилятор выдаст ошибку и предотвратит неопределённое поведение:</p>
<pre><code class="language-console">error[E0308]: mismatched types
   --&gt; src/memory/addr.rs:353:12
    |
353 |     virt = phys;
    |            ^^^^ expected struct `Addr`, found enum `core::result::Result`
    |
    = note: expected struct `Addr&lt;VirtTag&gt;`
                 found enum `core::result::Result&lt;Addr&lt;PhysTag&gt;, error::Error&gt;`
</code></pre>
<p>Типы не совместимы, но родственны, так как оба являются мономорфизациями
<a href="https://doc.rust-lang.ru/book/ch10-01-syntax.html">обобщённого типа</a>
<a href="../../doc/ku/memory/addr/struct.Addr.html"><code>Addr</code></a><code>&lt;T: </code><a href="../../doc/ku/memory/addr/trait.Tag.html"><code>Tag</code></a><code>&gt;</code>.
Это сделано чтобы не дублировать одинаковый код.
При поиске по документации полезно помнить, что
<a href="../../doc/ku/memory/addr/type.Phys.html"><code>Phys</code></a> и
<a href="../../doc/ku/memory/addr/type.Virt.html"><code>Virt</code></a> —
это мономорфизации <a href="../../doc/ku/memory/addr/struct.Addr.html"><code>Addr</code></a>.
Потому что общие методы реализованы в обобщённом типе
<a href="../../doc/ku/memory/addr/struct.Addr.html"><code>Addr</code></a>,
и в документации показываются только там.
В документации на
<a href="../../doc/ku/memory/addr/type.Phys.html"><code>Phys</code></a> и
<a href="../../doc/ku/memory/addr/type.Virt.html"><code>Virt</code></a>
будут только методы специфичные для них, общих методов из
<a href="../../doc/ku/memory/addr/struct.Addr.html"><code>Addr</code></a>
не будет показываться.</p>
<p>Таким образом места, где нужно повышенное внимание к типу адреса, а компилятор не в силах помочь, — это места преобразований между базовыми типами
<a href="https://doc.rust-lang.org/nightly/core/primitive.usize.html"><code>usize</code></a>/<a href="https://doc.rust-lang.org/nightly/core/primitive.u64.html"><code>u64</code></a>
и высокоуровневыми типами адресов.
К счастью, таких мест очень мало.
Записываются эти преобразования как показано в примерах
<a href="../../doc/ku/memory/addr/type.Phys.html#%D0%9F%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-phys-%D0%B8-%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%BC%D0%B8-%D1%82%D0%B8%D0%BF%D0%B0%D0%BC%D0%B8">для <code>Phys</code></a> и
<a href="../../doc/ku/memory/addr/type.Virt.html#%D0%9F%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-virt-%D0%B8-%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%BC%D0%B8-%D1%82%D0%B8%D0%BF%D0%B0%D0%BC%D0%B8">для <code>Virt</code></a>.
Иногда нам также встретится тип для виртуальных адресов библиотеки
<a href="../../doc/x86_64/index.html">x86_64</a> —
<a href="../../doc/x86_64/addr/struct.VirtAddr.html"><code>x86_64::VirtAddr</code></a>.
<a href="../../doc/ku/memory/addr/type.Virt.html"><code>Virt</code></a> может быть преобразован в <a href="../../doc/x86_64/addr/struct.VirtAddr.html"><code>x86_64::VirtAddr</code></a> как <a href="../../doc/ku/memory/addr/type.Virt.html#%D0%9F%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-virt-%D0%B8-virtaddr">показано в примерах в документации</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(virt_addr: VirtAddr) -&gt; Virt {
    virt_addr.into()
}

let virt = Virt::new(0x123ABC)?;
let virt_addr: VirtAddr = virt.into();
let virt2: Virt = virt_addr.into();
assert!(virt == virt2);
assert!(virt == f(virt.into()));
<span class="boring">}
</span></code></pre></pre>
<p>Rust поддерживает полиморфизм по возвращаемому значению, поэтому можно преобразовывать через
<a href="../../doc/ku/memory/addr/type.Virt.html#method.into"><code>Virt::into()</code></a>
в контексте, который требует
<a href="../../doc/x86_64/addr/struct.VirtAddr.html"><code>x86_64::VirtAddr</code></a>, —
<code>f(virt.into())</code> и наоборот — <code>virt_addr.into()</code>.
Это преобразование делается через стандартный типаж
<a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html"><code>core::convert::From</code></a>
в <a href="../../doc/ku/memory/addr/type.Virt.html#method.from"><code>Virt::from()</code></a>,
именно её зовёт <a href="../../doc/x86_64/addr/struct.VirtAddr.html#method.into"><code>x86_64::VirtAddr::into()</code></a>.</p>
<h2 id="Некорректные-физические-и-виртуальные-адреса"><a class="header" href="#Некорректные-физические-и-виртуальные-адреса">Некорректные физические и виртуальные адреса</a></h2>
<p><code>?</code> в <code>Virt::new(0x123ABC)?</code> означает проброс ошибки на уровень выше в стеке вызовов функций.
Дело в том, что не любое 64-битное число является валидным физическим или виртуальным адресом с точки зрения
<a href="https://wiki.osdev.org/X86-64">архитектуры x86-64</a>.
Поэтому <a href="../../doc/ku/memory/addr/struct.Addr.html#method.new"><code>Addr::new()</code></a> возвращает
<a href="../../doc/ku/error/type.Result.html"><code>Result&lt;Addr&gt;</code></a>, в котором либо лежит адрес, либо ошибка
<a href="../../doc/ku/error/enum.Error.html#variant.InvalidArgument"><code>Error::InvalidArgument</code></a>.
Оператор <code>?</code> соответственно либо возвращает адрес, либо пробрасывает ошибку выше.
Примеры получения ошибки есть в документации
<a href="../../doc/ku/memory/addr/type.Phys.html#%D0%9D%D0%B5%D0%BA%D0%BA%D0%BE%D1%80%D1%80%D0%B5%D0%BA%D1%82%D0%BD%D1%8B%D0%B5-%D0%B0%D0%B4%D1%80%D0%B5%D1%81%D0%B0">для <code>Phys</code></a> и
<a href="../../doc/ku/memory/addr/type.Virt.html#%D0%9D%D0%B5%D0%BA%D0%BA%D0%BE%D1%80%D1%80%D0%B5%D0%BA%D1%82%D0%BD%D1%8B%D0%B5-%D0%B0%D0%B4%D1%80%D0%B5%D1%81%D0%B0">для <code>Virt</code></a>.</p>
<p>Поведение <a href="../../doc/x86_64/addr/struct.VirtAddr.html#method.new"><code>x86_64::VirtAddr::new()</code></a>
в случае ошибки отличается, —
<a href="../../doc/x86_64/addr/struct.VirtAddr.html#panics">эта функция паникует</a>.
Это одна из причин, по которой мы не можем использовать всюду
<a href="../../doc/x86_64/addr/struct.VirtAddr.html"><code>x86_64::VirtAddr</code></a>,
и вынуждены определять собственный тип
<a href="../../doc/ku/memory/addr/type.Virt.html"><code>Virt</code></a>.</p>
<p>Когда мы дойдём до реализации системных вызовов, нам понадобится в ядре создавать виртуальные адреса из 64-х битных чисел, переданных из пользовательского процесса.
При этом мы не можем наложить аппаратных ограничений на эти числа, вроде того, чтобы потребовать от них быть валидными адресами.
То есть, ядро должно программно валидировать все приходящие ему из пользовательских процессов данные.
Если мы в ядре во время обработки системного вызова без дополнительной валидации вызовем
<code>x86_64::VirtAddr::new(user_address)</code>, то ядро запаникует,
как только сбойный или зловредный пользовательский процесс передаст невалидный <code>user_address</code> в этот системный вызов.
Тогда работа компьютера остановится и пострадают все процессы, а не только виноватый.
Вместо паники ядро должно вернуть ошибку пользовательскому процессу.
А для этого нужно эту ошибку прокинуть по всему стеку вызовов от места возникновения до точки входа в системные вызовы в ядре.</p>
<p>По той же причине ядро имеет право паниковать только при обнаружении некорректной работы самого себя или оборудования.
А значит, паникующими функциями в ядре пользоваться нужно очень внимательно.</p>
<p>С другой стороны, функции преобразования указателей и ссылок в
<a href="../../doc/ku/memory/addr/type.Virt.html"><code>Virt</code></a></p>
<ul>
<li><a href="../../doc/ku/memory/addr/type.Virt.html#method.from_ptr"><code>fn Virt::from_ptr&lt;T&gt;(ptr: *const T) -&gt; Virt</code></a> и</li>
<li><a href="../../doc/ku/memory/addr/type.Virt.html#method.from_ref"><code>fn from_ref&lt;T&gt;(x: &amp;T) -&gt; Virt</code></a></li>
</ul>
<p>паникуют на некорректных виртуальных адресах.
Потому что указатели и ссылки должны быть корректными виртуальными адресами.
Иначе, есть ошибка в том месте кода ядра, которое сформировало такую невалидную ссылку или указатель.</p>
<p>А вот функции преобразования
<a href="../../doc/ku/memory/addr/type.Virt.html"><code>Virt</code></a>
в константные и изменяемые указатели, ссылки и срезы</p>
<ul>
<li><a href="../../doc/ku/memory/addr/type.Virt.html#method.try_into_ptr"><code>fn try_into_ptr&lt;T&gt;(self) -&gt; Result&lt;*const T&gt;</code></a>,</li>
<li><a href="../../doc/ku/memory/addr/type.Virt.html#method.try_into_mut_ptr"><code>fn try_into_mut_ptr&lt;T&gt;(self) -&gt; Result&lt;*mut T&gt;</code></a>,</li>
<li><a href="../../doc/ku/memory/addr/type.Virt.html#method.try_into_ref"><code>unsafe fn try_into_ref&lt;T&gt;(self) -&gt; Result&lt;&amp;T&gt;</code></a> и</li>
<li><a href="../../doc/ku/memory/addr/type.Virt.html#method.try_into_mut"><code>unsafe fn try_into_mut&lt;T&gt;(self) -&gt; Result&lt;&amp;mut T&gt;</code></a> и</li>
<li><a href="../../doc/ku/memory/addr/type.Virt.html#method.try_into_slice"><code>unsafe fn try_into_slice&lt;T&gt;(self, len: usize) -&gt; Result&lt;&amp;[T]&gt;</code></a></li>
<li><a href="../../doc/ku/memory/addr/type.Virt.html#method.try_into_mut_slice"><code>unsafe fn try_into_mut_slice&lt;T&gt;(self, len: usize) -&gt; Result&lt;&amp;mut [T]&gt;</code></a></li>
</ul>
<p>возвращают
<a href="../../doc/ku/error/enum.Error.html#variant.InvalidArgument"><code>Error::InvalidArgument</code></a>,
если исходный
<a href="../../doc/ku/memory/addr/type.Virt.html"><code>Virt</code></a>
не удовлетворяет выравниванию запрошенного типа <code>T</code>.
Методы, возвращающие ссылку, дополнительно возвращают
<a href="../../doc/ku/error/enum.Error.html#variant.InvalidArgument"><code>Error::InvalidArgument</code></a>,
если исходный
<a href="../../doc/ku/memory/addr/type.Virt.html"><code>Virt</code></a>
равен нулю.
Кроме того, они помечены
<a href="https://doc.rust-lang.ru/book/ch19-01-unsafe-rust.html"><code>unsafe</code></a>,
так как вызывающая сторона должна гарантировать, что по адресу из исходного
<a href="../../doc/ku/memory/addr/type.Virt.html"><code>Virt</code></a>
находится корректное значение запрошенного типа.
Или
<a href="https://doc.rust-lang.ru/book/ch04-03-slices.html">срез</a>
корректных значений запрошенного типа, не менее заданного размера, для методов
<a href="../../doc/ku/memory/addr/type.Virt.html#method.try_into_slice"><code>Virt::try_into_slice()</code></a> и
<a href="../../doc/ku/memory/addr/type.Virt.html#method.try_into_mut_slice"><code>Virt::try_into_mut_slice()</code></a>.
Этим список гарантий, которые должна предоставить вызывающая сторона, не исчерпывается.
Но это всё <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">требования самого Rust</a> на ссылки, например:</p>
<ul>
<li>в программе не возникнет нарушения уникальности <code>&amp;mut T</code> ссылок,</li>
<li>по полученной <a href="https://doc.rust-lang.ru/book/ch03-01-variables-and-mutability.html">изменяемой</a> ссылке не находится неизменяемый объект, и т.д.</li>
</ul>
<p>Собственных требований эти функции не накладывают.</p>
<h2 id="Печать-адресов"><a class="header" href="#Печать-адресов">Печать адресов</a></h2>
<p>Нам часто захочется печатать адреса.
Чтобы и тут легко отличать виртуальные адреса от физических, они печатаются по-разному.
В качестве базового формата взят 16-ричный формат с префиксом <code>0x</code> и заглавными буквами <code>A</code>-<code>F</code>.
Но для физических адресов префикс <code>0x</code>
<a href="../../doc/ku/memory/addr/trait.Tag.html#associatedconstant.HEX_PREFIX">заменён</a>
на <code>0p</code> (<strong>p</strong>hysical), а для виртуальных — на <code>0v</code> (<strong>v</strong>irtual).
Например, <code>0p123ABC</code> — физический адрес, а <code>0v123ABC</code> — виртуальный.
К сожалению, легко глобально переопределить формат печати обычных указателей не получается.
Поэтому, в тех редких случаях, когда печатается стандартный
<a href="https://doc.rust-lang.org/std/primitive.pointer.html">указатель</a>,
его формат будет <code>0x123abc</code>.
Но при включённом пейджинге указатели могут быть только виртуальными, поэтому неоднозначности не возникает.</p>
<blockquote>
<p>Заглавные буквы используются чтобы все шестнадцатеричные цифры имели одинаковую высоту.
Благодаря этому шестнадцатеричные числа лучше выделяются в тексте, особенно англоязычном, и их легче читать.
<code>Compare 0xdeadbeaf and 0xDEADBEEF for example</code>.
Отдельный шрифт не всегда применим, например для лога.
Заметьте, что в современной технической литературе используются шрифты с одинаковой высотой десятичных цифр.
А вот в художественной литературе попадаются <a href="https://art-nto.ru/800/600/http/legionfonts.com/img-fonts/zanerian-two/og-zanerian-two-font-abc.jpg">шрифты</a>, которые не обладают таким свойством.</p>
</blockquote>
<h2 id="Страницы-памяти"><a class="header" href="#Страницы-памяти">Страницы памяти</a></h2>
<p>Физические страницы обычно называют фреймами.
Когда говорят про просто страницы, возникает неоднозначность — могут иметься в виду фреймы или страницы виртуальной памяти.
Постараемся придерживаться слова страница только в отношении виртуальной памяти.
Физические фреймы памяти также не стоит путать с виртуальными страницами, поэтому для них тоже заведены отдельные несовместимые типы:</p>
<ul>
<li><a href="../../doc/ku/memory/frage/type.Frame.html"><code>Frame</code></a> для физических фреймов;</li>
<li><a href="../../doc/ku/memory/frage/type.Page.html"><code>Page</code></a> для виртуальных страниц.</li>
</ul>
<p>Они также являются мономорфизациями одного и того же обобщённого типа
<a href="../../doc/ku/memory/frage/struct.Frage.html"><code>Frage&lt;T: Tag&gt;</code></a> (<strong>Fra</strong>me or P<strong>age</strong>)<sup class="footnote-reference"><a href="#1">1</a></sup>.
<a href="../../doc/ku/memory/frage/struct.Frage.html"><code>Frage</code></a> естественным образом связан с
<a href="../../doc/ku/memory/addr/struct.Addr.html"><code>Addr</code></a> — собственным адресом.
Для преобразований используются
<a href="../../doc/ku/memory/frage/struct.Frage.html#method.new"><code>Frage::new(address: Addr) -&gt; Result&lt;Frage&gt;</code></a> и
<a href="../../doc/ku/memory/frage/struct.Frage.html#method.address"><code>Frage::address(&amp;self) -&gt; Addr</code></a>.</p>
<p>Кроме того, ещё удобно нумеровать фреймы и страницы, поэтому
<a href="../../doc/ku/memory/frage/struct.Frage.html"><code>Frage</code></a> поддерживает преобразования из/в свой номер —
<a href="../../doc/ku/memory/frage/struct.Frage.html#method.from_index"><code>Frage::from_index(index: usize) -&gt; Frage</code></a>,
<a href="../../doc/ku/memory/frage/struct.Frage.html#method.index"><code>Frage::index(self) -&gt; usize</code></a>.</p>
<p>Поддерживать будем только 4KiB-ные страницы, вы встретите в коде константу
<a href="../../doc/ku/memory/frage/struct.Frage.html#associatedconstant.SIZE"><code>Page::SIZE</code></a>.
Конечно, в таком случае преобразования адреса страницы из/в индекс тривиально, — это просто умножение/деление на
<code>4096 = 4 *</code><a href="../../doc/ku/memory/size/constant.KiB.html"><code>KiB</code></a>.
Но стоит пользоваться именно именованными функциями, а не просто арифметической операцией, так как это более явно говорит о намерениях и более понятно читателю кода.</p>
<p>При поиске по документации полезно помнить, что
<a href="../../doc/ku/memory/frage/type.Frame.html"><code>Frame</code></a> и
<a href="../../doc/ku/memory/frage/type.Page.html"><code>Page</code></a> —
это мономорфизации
<a href="../../doc/ku/memory/frage/struct.Frage.html"><code>Frage</code></a>.
Потому что общие методы реализованы в обобщённом типе
<a href="../../doc/ku/memory/frage/struct.Frage.html"><code>Frage</code></a>,
и в документации показываются только там.
В документации на
<a href="../../doc/ku/memory/frage/type.Frame.html"><code>Frame</code></a> и
<a href="../../doc/ku/memory/frage/type.Page.html"><code>Page</code></a>
будут только методы специфичные для них, общих методов из
<a href="../../doc/ku/memory/frage/struct.Frage.html"><code>Frage</code></a>
не будет.</p>
<hr />
<p><sup class="footnote-reference"><a href="#1">1</a></sup> Объявляется конкурс на более элегантное название.</p>
<h2 id="Печать-переменных-для-страниц"><a class="header" href="#Печать-переменных-для-страниц">Печать переменных для страниц</a></h2>
<p>Печать переменных для страниц базируется на индексе и адресе, в формате <code>индекс @ адрес</code> для <a href="../../doc/ku/memory/frage/struct.Frage.html#impl-Display"><code>Display (если нажать на [src] справа, вы увидите реализацию этого в коде)</code></a>.
При этом адрес выдаётся в ранее упомянутом формате, поэтому из него легко понять распечатана переменная физического фрейма или виртуальной страницы.
Кроме того, <a href="../../doc/ku/memory/frage/struct.Frage.html#impl-Debug">в формате <code>Debug</code></a>
всё это снабжается явным указанием типа и получается формат
<a href="../../doc/ku/memory/addr/trait.Tag.html#associatedconstant.FRAGE_NAME"><code>тип</code></a><code>(индекс @ адрес)</code>.
Например: <code>Frame(12492 @ 0p30CC000)</code> для <code>Debug</code> и <code>12492 @ 0p30CC000</code> для <code>Display</code>,
<code>Page(4503599627370148 @ 0vFFFFFFFFFFEA4000)</code> для <code>Debug</code> и <code>4503599627370148 @ 0vFFFFFFFFFFEA4000</code> для <code>Display</code>.</p>
<h2 id="Блоки-памяти"><a class="header" href="#Блоки-памяти">Блоки памяти</a></h2>
<p><a href="../../doc/ku/memory/block/struct.Block.html"><code>Block&lt;T&gt;</code></a> — это абстракция куска физической или виртуальной памяти, постраничного или произвольного:</p>
<ul>
<li><code>Block&lt;Phys&gt;</code> — произвольный кусок физической памяти;</li>
<li><code>Block&lt;Virt&gt;</code> — произвольный кусок виртуальной памяти;</li>
<li><code>Block&lt;Frame&gt;</code> — набор последовательных физических фреймов;</li>
<li><code>Block&lt;Page&gt;</code> — набор последовательных виртуальных страниц.</li>
</ul>
<p><code>Block</code> не владеет описываемой им памятью.</p>
<p>Реализация <a href="../../doc/ku/memory/block/struct.Block.html"><code>Block</code></a> — это просто пара индексов.
<a href="../../doc/ku/memory/block/struct.Block.html#structfield.start"><code>Block::start</code></a> — индекс первого элемента в блоке.
<a href="../../doc/ku/memory/block/struct.Block.html#structfield.end"><code>Block::end</code></a> — индекс следующего за последним элементом блока.
То есть, как обычно, это полуоткрытый интервал элементов.
Основные его методы:</p>
<ul>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.new"><code>fn Block::new(start: T, end: T) -&gt; Result&lt;Self&gt;</code></a> — создаёт блок для полуоткрытого интервала <code>[start, end)</code> базового типа <code>T</code>, который может быть <code>Phys</code>, <code>Virt</code>, <code>Frame</code> или <code>Page</code>.</li>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.from_index"><code>fn Block::from_index(start: usize, end: usize) -&gt; Result&lt;Self&gt;</code></a> — создаёт блок для полуоткрытого интервала <code>[start, end)</code> базового типа <code>T</code>, который задаётся своими индексами — номерами байт для <code>Phys</code> и <code>Virt</code>, номерами фреймов для <code>Frame</code> и номерами страниц для <code>Page</code>.</li>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.from_index_u64"><code>fn Block::from_index_u64(start: u64, end: u64) -&gt; Result&lt;Self&gt;</code></a> — аналогичен <a href="../../doc/ku/memory/block/struct.Block.html#method.from_index"><code>Block::from_index()</code></a>, но индексы имеют тип <a href="https://doc.rust-lang.org/nightly/core/primitive.u64.html"><code>u64</code></a> вместо <a href="https://doc.rust-lang.org/nightly/core/primitive.usize.html"><code>usize</code></a>.</li>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.count"><code>fn Block::count() -&gt; usize</code></a> — количество элементов в блоке, равно <code>Block::end() - Block::start()</code>.</li>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.size"><code>fn Block::size() -&gt; usize</code></a> — размер блока в байтах, равно количеству элементов в блоке, умноженному на размер элемента.</li>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.start_address"><code>fn Block::start_address() -&gt; Addr</code></a> — адрес первого элемента блока.</li>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.end_address"><code>fn Block::end_address() -&gt; Result&lt;Addr&gt;</code></a> — адрес следующего за последним элементом блока. Может не существовать из-за переполнения, поэтому с ним нужно обращаться осторожно.</li>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.contains"><code>fn Block::contains(element: T) -&gt; bool</code></a> — возвращает <code>true</code>, если блок содержит заданный элемент.</li>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.contains"><code>fn Block::contains_address(addr: Addr) -&gt; bool</code></a> — возвращает <code>true</code>, если блок содержит заданный адрес.</li>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.contains"><code>fn Block::tail(count: usize) -&gt; Option&lt;Self&gt;</code></a> — откусывает от блока хвост с заданным количеством элементов, и возвращает его в виде нового блока. Старое значение исходного блока таким образом разбивается на дизъюнктное объединение нового значение исходного блока и возвращаемого значения. Если исходный блок содержит менее <code>count</code> единиц базового типа <code>T</code>, метод не меняет исходный блок и возвращает <code>None</code>.</li>
</ul>
<p>По <code>Block::&lt;Frame&gt;</code> или <code>Block::&lt;Page&gt;</code> <a href="../../doc/ku/memory/block/struct.Block.html#impl-IntoIterator">можно проитерироваться</a>, вызвав <a href="../../doc/ku/memory/block/struct.Block.html#method.into_iter"><code>Block::&lt;Frage&gt;::into_iter()</code></a>.
Полученный итератор будет последовательно выдавать очередной <code>Frame</code> или <code>Page</code>.</p>
<p><code>Block::&lt;Virt&gt;</code> может быть создан из
указателя, ссылки или
<a href="https://doc.rust-lang.ru/book/ch04-03-slices.html">среза</a>:</p>
<ul>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.from_ptr"><code>fn Block::&lt;Virt&gt;::from_ptr&lt;T&gt;(x: *const T) -&gt; Block&lt;Virt&gt;</code></a>,</li>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.from_ptr"><code>fn Block::&lt;Virt&gt;::from_ref&lt;T&gt;(x: &amp;T) -&gt; Block&lt;Virt&gt;</code></a>,</li>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.from_slice"><code>fn Block::&lt;Virt&gt;::from_slice&lt;T&gt;(x: &amp;[T]) -&gt; Block&lt;Virt&gt;</code></a></li>
</ul>
<p><code>Block::&lt;Virt&gt;</code> и <code>Block::&lt;Page&gt;</code> могут быть превращены в константные и изменяемые указатели, ссылки и слайсы:</p>
<ul>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.try_into_ptr"><code>fn Block::try_into_ptr&lt;Q&gt;() -&gt; Result&lt;*const Q&gt;</code></a></li>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.try_into_mut_ptr"><code>fn Block::try_into_mut_ptr&lt;Q&gt;() -&gt; Result&lt;*mut Q&gt;</code></a></li>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.try_into_ref"><code>unsafe fn Block::try_into_ref&lt;Q&gt;() -&gt; Result&lt;&amp;Q&gt;</code></a></li>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.try_into_mut"><code>unsafe fn Block::try_into_mut&lt;Q&gt;() -&gt; Result&lt;&amp;Q&gt;</code></a></li>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.try_into_slice"><code>unsafe fn Block::try_into_slice&lt;Q&gt;() -&gt; Result&lt;&amp;[Q]&gt;</code></a></li>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.try_into_mut_slice"><code>unsafe fn Block::try_into_mut_slice&lt;Q&gt;() -&gt; Result&lt;&amp;mut [Q]&gt;</code></a></li>
</ul>
<p>Эти методы аналогичны соответствующим методам <code>Virt</code>.
Использовать <code>Block</code> для подобных целей предпочтительнее, чем <code>Virt</code>,
так как <code>Block</code> знает свой размер в памяти и делает дополнительные проверки на него.
И, по той же причине, не требует указания количества элементов при преобразованиях в срезы.</p>
<p>У <code>Block::&lt;Addr&gt;</code> есть ещё метод</p>
<ul>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.enclosing"><code>fn Block::&lt;Addr&gt;::enclosing() -&gt; Block&lt;Frage&gt;</code></a>, который для заданного блока виртуальных или физических адресов возвращает минимальный содержащий его блок виртуальных страниц или физических фреймов соответственно.</li>
</ul>
<h2 id="Две-половины-виртуального-адресного-пространства"><a class="header" href="#Две-половины-виртуального-адресного-пространства">Две половины виртуального адресного пространства</a></h2>
<p>У виртуальных адресов в <a href="https://en.wikipedia.org/wiki/X86-64">архитектуре x86-64</a>
есть особенность.
Множество их допустимых значений разбивается на
<a href="https://en.wikipedia.org/wiki/X86-64#Virtual_address_space_details">две половины</a>.
В данный момент реально используются 48–битные виртуальные адреса и получаются такие диапазоны:</p>
<ul>
<li>“нижняя половина” от <code>0v0000_0000_0000_0000</code> до <code>0v0000_7FFF_FFFF_FFFF</code> включительно и</li>
<li>“верхняя половина” от <code>0vFFFF_8000_0000_0000</code> до <code>0vFFFF_FFFF_FFFF_FFFF</code> включительно.</li>
</ul>
<p>То есть, виртуальные адреса скорее ведут себя как 48–битные <strong>знаковые</strong> числа.
Но, в обычных языках таких типов нет, и в целом удобнее пользоваться для адресов беззнаковыми числами.
К тому же для физических адресов ничего подобного нет, у них единый диапазон.</p>
<p>Поэтому при работе с виртуальными адресами нужно проявлять осторожность.
Следующий за виртуальным адресом <code>0v0000_7FFF_FFFF_FFFF</code> — это
не <code>0v0000_8000_0000_0000</code>, а <code>0vFFFF_8000_0000_0000</code>.
А адрес <code>0v0000_8000_0000_0000</code> не валиден и приведёт к исключению процессора.
А расстояние между этими последовательными адресами не 1, как между другими последовательными адресами.
Или по-другому, размер объекта, который начался в “нижней половине”, а закончился в “верхней половине”
не соответствует разности между битовыми представлениями его
конца — следующего адреса за последним, принадлежащим объекту, — и его начала.</p>
<p>Кроме того, чтобы не рисковать получить какую-нибудь ошибку из-за переполнения,
пересекать границу между <code>0vFFFF_FFFF_FFFF_FFFF</code> и <code>0v0000_0000_0000_0000</code> тоже не стоит.</p>
<p>То есть, чтобы работать без риска ошибок, стоит ввести ограничение:</p>
<ul>
<li>Любой объект в виртуальном адресном пространстве должен целиком содержаться либо в “нижней половине”, либо в “верхней половине”. И не должен пересекать границы между ними — ни границу <code>0v0000_7FFF_FFFF_FFFF/0vFFFF_8000_0000_0000</code>, ни границу <code>0vFFFF_FFFF_FFFF_FFFF/0v0000_0000_0000_0000</code>.</li>
</ul>
<p><code>Block&lt;Virt&gt;</code> и <code>Block&lt;Page&gt;</code> учитывают это ограничение и возвращают ошибку
<a href="../../doc/ku/error/enum.Error.html#variant.InvalidArgument"><code>Error::InvalidArgument</code></a>,
если попытаться создать блок с началом и концом в разных половинах виртуального адресного пространства.</p>
<h2 id="usize-versus-u64"><a class="header" href="#usize-versus-u64">usize versus u64</a></h2>
<p>Для низкоуровневого хранения величин, вроде адресов, номеров и т.д. можно было бы использовать любой из этих римитивных типов:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/core/primitive.u64.html"><code>u64</code></a> — целочисленный тип с фиксированным количеством бит, подходящий для регистров <a href="https://wiki.osdev.org/X86-64">x86-64</a> и часто использующийся при взаимодействии с железом в этой архитектуре.</li>
<li><a href="https://doc.rust-lang.org/nightly/core/primitive.usize.html"><code>usize</code></a> — языковая абстракция регистра в текущей архитектуре, размера объекта в памяти и, фактически, указателя. (Если закрыть глаза на <a href="https://en.wikipedia.org/wiki/Far_pointer">far pointer</a>, с которыми мы почти не столкнёмся. И который в любом случае не 64–битный.)</li>
</ul>
<p>Тип <a href="https://doc.rust-lang.org/nightly/core/primitive.u64.html"><code>u64</code></a> хорош своей фиксированностью.
Если нужно, чтобы код работал со структурами данных фиксированного размера конкретной фиксированной платформы,
такими как таблицы страниц, GDT, и т.п., этот тип хорошо подходит.
Особенно, если хочется компилироваться, в том числе, не под целевую платформу, но при этом работать с её структурами.
Подобная задача, например, возникает при эмуляции целевой платформы под платформой с другой архитектурой.
Поэтому <a href="https://doc.rust-lang.org/nightly/core/primitive.u64.html"><code>u64</code></a> — выбор библиотек
<a href="../../doc/x86/index.html">x86</a> и <a href="../../doc/x86_64/index.html">x86_64</a>,
которые реализуют работу с конкретной аппаратной платформой.</p>
<p>Однако аналогично другим языкам высокого уровня, в Rust в случаях,
когда нужно указать размер объекта в памяти, индекс в срезе и тому подобного,
для переносимости кода между архитектурами используется тип
<a href="https://doc.rust-lang.org/nightly/core/primitive.usize.html"><code>usize</code></a>.
Так как он привязан не к какой-то конкретной платформе, а к текущей.
Поэтому, если в коде нужно работать с
<a href="https://doc.rust-lang.org/nightly/core/primitive.u64.html"><code>u64</code></a>,
то в нём часто будут выполняться преобразования между
<a href="https://doc.rust-lang.org/nightly/core/primitive.u64.html"><code>u64</code></a> и
<a href="https://doc.rust-lang.org/nightly/core/primitive.usize.html"><code>usize</code></a>.
В языках вроде C или C++, которые спокойно относятся к преобразованиям между целыми даже разного размера и
даже к преобразованиям, теряющим часть бит информации,
это не отобразилось бы на исходном коде.
Только привело бы к трудноуловимым ошибкам, когда потеря информации при преобразовании не является умышленной.
Rust строже относится к работе с типами, и в нём преобразования между разными целыми типами нужно делать явно.</p>
<p>Nikka не является эмулятором и запускается на той же платформе, для которой строит предопределённые железом структуры данных.
Поэтому она может выбрать как
<a href="https://doc.rust-lang.org/nightly/core/primitive.u64.html"><code>u64</code></a>, так и
<a href="https://doc.rust-lang.org/nightly/core/primitive.usize.html"><code>usize</code></a>.
Для удобства работы, чтобы явных преобразований между
<a href="https://doc.rust-lang.org/nightly/core/primitive.u64.html"><code>u64</code></a> и
<a href="https://doc.rust-lang.org/nightly/core/primitive.usize.html"><code>usize</code></a>
делать как можно меньше,
в Nikka выбор сделан в пользу использования
<a href="https://doc.rust-lang.org/nightly/core/primitive.usize.html"><code>usize</code></a>.
В том числе в случаях, в которых в <a href="https://wiki.osdev.org/X86-64">архитектуре x86-64</a>
требуется 64-битная величина.</p>
<p>К сожалению, полностью от преобразований между
<a href="https://doc.rust-lang.org/nightly/core/primitive.u64.html"><code>u64</code></a> и
<a href="https://doc.rust-lang.org/nightly/core/primitive.usize.html"><code>usize</code></a>
уйти не получается.
Например, они иногда возникают в тех местах, где используются библиотеки
<a href="../../doc/x86/index.html">x86</a> и <a href="../../doc/x86_64/index.html">x86_64</a>.
Писать <code>value as type</code> в таких случаях некомфортно, так как в общем случае <code>as</code> может терять информацию.
Например, <code>12345u16 as u8</code> молча теряет информацию, поэтому лучше</p>
<ul>
<li>либо написать <code>u8::try_from(x)</code> и обработать ошибку,</li>
<li>либо явно срезать лишние биты — <code>u8::try_from(x &amp; 0xFF).expect(&quot;...&quot;)</code>.</li>
</ul>
<p>А <code>as</code> оставить для преобразований, где без него не обойтись, например между ссылками и указателями, указателями и
<a href="https://doc.rust-lang.org/nightly/core/primitive.usize.html"><code>usize</code></a> и т.п.
В коде, пестрящем <code>as</code>, глаз замыливается и становится ещё труднее увидеть ошибку,
вызванную потерей информации в одном из <code>as</code>.</p>
<p>Для самых частых преобразований, собственно, между
<a href="https://doc.rust-lang.org/nightly/core/primitive.u64.html"><code>u64</code></a> и
<a href="https://doc.rust-lang.org/nightly/core/primitive.usize.html"><code>usize</code></a>,
есть вспомогательные функции:</p>
<ul>
<li><a href="../../doc/ku/memory/size/fn.into_usize.html"><code>ku::memory::size::into_usize(x: u64)</code></a></li>
<li><a href="../../doc/ku/memory/size/fn.into_u64.html"><code>ku::memory::size::into_u64(x: usize)</code></a></li>
</ul>
<p>Во время компиляции они на всякий случай проверяют, что входной и целевой тип имеют одинаковый размер.
Поэтому гарантируют, что потери информации при преобразованиях не будет.</p>
<p>Для удобства, высокоуровневые типы, для которых это может пригодиться, предоставляют конструкторы из
<a href="https://doc.rust-lang.org/nightly/core/primitive.u64.html"><code>u64</code></a>,
в дополнение к основным конструкторам из
<a href="https://doc.rust-lang.org/nightly/core/primitive.usize.html"><code>usize</code></a>.
Например:</p>
<ul>
<li><a href="../../doc/ku/memory/addr/struct.Addr.html#method.new_u64"><code>Virt::new_u64(addr: u64)</code></a> и</li>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.from_index_u64"><code>Block::from_index_u64(start: u64, end: 64)</code></a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Страничные-отображения"><a class="header" href="#Страничные-отображения">Страничные отображения</a></h2>
<p>Основную работу по преобразованию виртуальных адресов в соответствующие физические будет делать метод
<a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.translate"><code>Mapping::translate()</code></a>
структуры
<a href="../../doc/kernel/memory/mapping/struct.Mapping.html"><code>kernel::memory::mapping::Mapping</code></a>.</p>
<p>Обратное преобразование, из физического адреса в виртуальный, вообще говоря не является функцией, так как один и тот же физический адрес может быть отображён на несколько разных виртуальных адресов в одном адресном пространстве.
Однако, очень полезно находить какой-нибудь виртуальный адрес, соответствующий данному физическому.
Это понадобится в случае, когда захочется прочитать из физической памяти или записать в неё.
В частности, при реализации самого
<a href="../../doc/kernel/memory/mapping/struct.Mapping.html"><code>Mapping</code></a>
такая задача возникнет.</p>
<p>Решать эту задачу можно по-разному, например:</p>
<ul>
<li>Можно отобразить нужный физический фрейм временно в какую-нибудь свободную виртуальную страницу и писать уже в неё.</li>
<li>В частном случае работы с фреймами, содержащими собственно страничное отображение, можно сделать <a href="https://wiki.osdev.org/Page_Tables#Recursive_mapping">рекурсивную запись</a>, и через неё все эти физические фреймы станут доступны в виртуальном адресном пространстве. Этот приём ещё пригодится нам в последующих лабораторках.</li>
<li>Можно линейно отобразить всю физическую память или её значительную часть в отдельный диапазон виртуального адресного пространства. Тогда для получения доступа к заданному физическому адресу, нужно будет взять виртуальный адрес, равный сумме из некоторой константы — виртуального адреса начала такого отображения — и смещения нужного физического адреса от физического нуля.</li>
</ul>
<p>Последний вариант достаточно прост в использовании, а адресное пространство в x86-64 достаточно большое для его реализации.
Поэтому воспользуемся этим вариантом.
В коде виртуальный адрес начала этого линейного отображения называется <code>phys2virt</code>, имеет тип
<a href="../../doc/ku/memory/frage/type.Page.html"><code>Page</code></a>
и содержит адрес виртуальной страницы, в которую отображён нулевой фрейм.
А для собственно преобразования заданного физического адреса <code>address</code> служит функция
<a href="../../doc/kernel/memory/fn.phys2virt_map.html"><code>kernel::memory::phys2virt_map()</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn phys2virt_map(phys2virt: Page, address: Phys) -&gt; Virt
<span class="boring">}
</span></code></pre></pre>
<p>Обеспечивает отображение всей физической памяти в виртуальную память библиотека
<a href="../../doc/bootloader/index.html">bootloader</a>,
которая грузит ядро в память при старте компьютера.
Об этом мы попросили её, задав опцию <code>map_physical_memory</code> в файле <code>kernel/Cargo.toml</code>:</p>
<pre><code class="language-toml">    bootloader = { ..., features = [&quot;map_physical_memory&quot;] }
</code></pre>
<p>Она же сообщает нам о выбранном ею для этого виртуальном адресе в поле
<a href="../../doc/bootloader/bootinfo/struct.BootInfo.html#structfield.physical_memory_offset">BootInfo::physical_memory_offset</a>
структуры
<a href="../../doc/bootloader/bootinfo/struct.BootInfo.html">bootloader::bootinfo::BootInfo</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Преобразования-внутри-физического-пространства"><a class="header" href="#Преобразования-внутри-физического-пространства">Преобразования внутри физического пространства</a></h2>
<p><img src="2-mm-3-phys.svg" alt="" /></p>
<h2 id="Преобразования-внутри-виртуального-пространства"><a class="header" href="#Преобразования-внутри-виртуального-пространства">Преобразования внутри виртуального пространства</a></h2>
<p><img src="2-mm-3-block-virt.svg" alt="" /></p>
<p><img src="2-mm-3-virt.svg" alt="" /></p>
<h2 id="Преобразования-между-addrphysvirt-и-frageframepage"><a class="header" href="#Преобразования-между-addrphysvirt-и-frageframepage">Преобразования между Addr/Phys/Virt и Frage/Frame/Page</a></h2>
<p><img src="2-mm-3-addr.svg" alt="" /></p>
<h2 id="Преобразования-между-пространствами"><a class="header" href="#Преобразования-между-пространствами">Преобразования между пространствами</a></h2>
<p><img src="2-mm-3-spaces.svg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="План-лабораторной-работы-1"><a class="header" href="#План-лабораторной-работы-1">План лабораторной работы №1</a></h2>
<p>Для управления памятью ядру нужна структура данных, хранящая информацию про имеющиеся физические фреймы.
Когда будет поступать запрос на выделение памяти, эта структура должна будет выдать запрошенное количество фреймов.
При освобождении фреймов же, структура должна будет обработать этот факт.
То есть, ядру понадобится аллокатор физических фреймов.</p>
<p>Однако, самой такой структуре нужна память.
Эту память нужно как-то выделить и учесть в самом аллокаторе памяти.
Причём выделять память под аллокатор нужно до того как он сам будет инициализирован.
Получаем замкнутый круг.</p>
<p>Выбираться из него будем в три этапа.</p>
<p>Сначала
<a href="../../lab/book/2-mm-5-boot-frame-allocator.html">реализуем простой аллокатор</a>
физических фреймов
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html"><code>BootFrameAllocator</code></a>.
Он не будет требовать много памяти и его размер будет известен на этапе компиляции.
Этот аллокатор при инициализации должен будет учесть значительную часть свободной физической памяти.
В качестве структуры данных для учёта свободных фреймов
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html"><code>BootFrameAllocator</code></a>
использует пару индексов — номер первого свободного фрейма и номер следующего за последним свободным фреймом.
При аллокации он выдаёт свободные фреймы и меняет индексы для учёта этого факта.
А вот деаллокацию он просто не поддерживает.
Использовать этот аллокатор будем только во время инициализации ядра, что подчёркивается его названием.</p>
<p>На втором этапе нам нужно будет
<a href="../../lab/book/2-mm-6-address-space.html">поддержать работу с виртуальным адресным пространством</a>,
инкапсулированную в структуру
<a href="../../doc/kernel/memory/struct.AddressSpace.html"><code>AddressSpace</code></a>.
В ней вы реализуете аллокацию виртуальных страниц в адресном пространстве и страничное преобразование.
С помощью этих операций в дальнейшем можно будет аллоцировать память под структуры, размер которых не известен на этапе компиляции.</p>
<p>После этого
<a href="../../lab/book/2-mm-7-main-frame-allocator.html">реализуем чуть более сложный аллокатор</a>
физических фреймов
<a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html"><code>MainFrameAllocator</code></a>.
Про каждый фрейм он будет помнить некоторую информацию, собранную в
<a href="../../doc/kernel/memory/main_frame_allocator/enum.FrameInfo.html"><code>FrameInfo</code></a>.
Соответственно, ему потребуется целый
<a href="https://doc.rust-lang.ru/book/ch04-03-slices.html">срез</a>
<a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html#structfield.frame_info"><code>MainFrameAllocator::frame_info</code></a>.
Размер этого среза зависит от доступного количества памяти в компьютере,
поэтому он не может быть инициализирован статически.
Память под него мы выделим с помощью
<a href="../../doc/kernel/memory/struct.AddressSpace.html"><code>AddressSpace</code></a>
из
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html"><code>BootFrameAllocator</code></a>.</p>
<p>Отражением этого плана в коде является функция
<a href="../../doc/kernel/memory/fn.init.html"><code>kernel::memory::init()</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init(boot_info: &amp;'static BootInfo) {
    ...

    *FRAME_ALLOCATOR.lock() = FrameAllocator::Boot(
        BootFrameAllocator::new(&amp;boot_info.memory_map)
    );

    *BASE_ADDRESS_SPACE.lock() = AddressSpace::new(phys2virt);

    *FRAME_ALLOCATOR.lock() = FrameAllocator::Main(
        main_frame_allocator::init(&amp;boot_info.memory_map),
    );

    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Сначала глобальным аллокатором физических фреймов
<a href="../../doc/kernel/memory/struct.FRAME_ALLOCATOR.html"><code>FRAME_ALLOCATOR</code></a>
она делает структуру
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html"><code>BootFrameAllocator</code></a>.
Затем она инициализирует глобальную переменную
<a href="../../doc/kernel/memory/struct.BASE_ADDRESS_SPACE.html"><code>BASE_ADDRESS_SPACE</code></a>
для управления адресным пространством структурой
<a href="../../doc/kernel/memory/struct.AddressSpace.html"><code>AddressSpace</code></a>.
Затем глобальный аллокатор физических фреймов
<a href="../../doc/kernel/memory/struct.FRAME_ALLOCATOR.html"><code>FRAME_ALLOCATOR</code></a>
меняется на структуру
<a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html"><code>MainFrameAllocator</code></a>,
которую возвращает функция
<a href="../../doc/kernel/memory/main_frame_allocator/fn.init.html"><code>main_frame_allocator::init()</code></a>.</p>
<p><code>FrameAllocator::Boot</code> и <code>FrameAllocator::Main</code> — это элементы перечисления</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum FrameAllocator {
    Void,
    Boot(BootFrameAllocator),
    Main(MainFrameAllocator),
}
<span class="boring">}
</span></code></pre></pre>
<p>Они позволяют понять, какой из аллокаторов физических фреймов используется в данный момент.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Временный-аллокатор-физических-фреймов"><a class="header" href="#Временный-аллокатор-физических-фреймов">Временный аллокатор физических фреймов</a></h2>
<p>В этой задаче реализуем простой аллокатор физических фреймов
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html"><code>kernel::memory::boot_frame_allocator::BootFrameAllocator</code></a>.
В качестве структуры данных для учёта свободных фреймов
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html"><code>BootFrameAllocator</code></a>
использует поле
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html#structfield.block"><code>BootFrameAllocator::block</code></a>
типа
<a href="../../doc/ku/memory/block/struct.Block.html"><code>Block</code></a><code>&lt;</code><a href="../../doc/ku/memory/frage/type.Frame.html"><code>Frame</code></a><code>&gt;</code>.
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html#structfield.block"><code>BootFrameAllocator::block</code></a>
содержит полуоткрытый интервал свободных фреймов.</p>
<p>Поле
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html#structfield.initial_block"><code>BootFrameAllocator::initial_block</code></a>
содержит копию стартового значение поля
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html#structfield.block"><code>BootFrameAllocator::block</code></a>.
И не меняется при аллокациях, в отличие от
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html#structfield.block"><code>BootFrameAllocator::block</code></a>.
Оно используется в методе
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html#method.is_managed"><code>BootFrameAllocator::is_managed()</code></a>
для определения, что заданный фрейм принадлежит этому аллокатору, вне зависимости от того был ли он уже аллоцирован или нет.
Дело в том, что
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html"><code>BootFrameAllocator</code></a>
не будет учитывать все доступные физические фреймы, а только некоторый непрерывный их блок.
Потому что есть зарезервированные области физической памяти, которые мы не можем выделять.
А отслеживать несколько областей свободной или занятой памяти
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html"><code>BootFrameAllocator</code></a>
не может в силу своей простоты.</p>
<p>Параметр <code>T</code> обобщённого типа <a href="../../doc/ku/memory/block/struct.Block.html"><code>Block&lt;T&gt;</code></a>
и соответствующее фантомное, не занимающее памяти, поле
<a href="../../doc/ku/memory/block/struct.Block.html#structfield.tag"><code>Block::tag</code></a>
служат той же цели, что и в
<a href="../../doc/ku/memory/addr/struct.Addr.html"><code>Addr</code></a><code>&lt;T: </code><a href="../../doc/ku/memory/addr/trait.Tag.html"><code>Tag</code></a><code>&gt;</code> —
сделать блоки с разными параметрами <code>T</code> несовместимыми.
Поэтому <code>Block&lt;Frame&gt;</code> будет несовместим с <code>Block&lt;Page&gt;</code> и компилятор не даст их перепутать.
Подробнее про тип этого фантомного тега можно посмотреть в документации —
<a href="https://doc.rust-lang.org/nightly/core/marker/struct.PhantomData.html"><code>core::marker::PhantomData</code></a>.</p>
<p>Библиотека <a href="../../doc/bootloader/index.html"><code>bootloader</code></a>, которую мы используем для загрузки ОС,
получает от <a href="https://wiki.osdev.org/BIOS">BIOS</a> или <a href="https://wiki.osdev.org/UEFI">UEFI</a>
информацию о физической памяти компьютера.
Этот процесс состоит из нескольких наслоений легаси.
Подробнее о том, как он устроен можно посмотреть <a href="https://wiki.osdev.org/Detecting_Memory_(x86)">тут</a>.
А ориентировочную карту зарезервированных областей — <a href="https://wiki.osdev.org/Memory_Map_(x86)">тут</a>.
К счастью,
<a href="../../doc/bootloader/index.html"><code>bootloader</code></a>
скрывает от нас это легаси и предоставляет готовую структуру
<a href="../../doc/bootloader/bootinfo/struct.MemoryMap.html"><code>bootloader::bootinfo::MemoryMap</code></a>,
которая описывает карту доступной физической памяти.
Структура <a href="../../doc/bootloader/bootinfo/struct.MemoryMap.html"><code>MemoryMap</code></a>
<a href="../../doc/bootloader/bootinfo/struct.MemoryMap.html#impl-Deref">реализует</a> типаж
<a href="https://doc.rust-lang.org/nightly/core/ops/trait.Deref.html"><code>core::ops::Deref</code></a>,
<a href="../../doc/bootloader/bootinfo/struct.MemoryMap.html#associatedtype.Target">возвращая из него</a>
массив структур
<a href="../../doc/bootloader/bootinfo/struct.MemoryRegion.html"><code>bootloader::bootinfo::MemoryRegion</code></a>.
Это означает, что если мы напишем</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl BootFrameAllocator {
    fn new(memory_map: &amp;MemoryMap) -&gt; Self {
        for region in memory_map.iter() {
            ...
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>переменная <code>region</code> пробежится по всем
<a href="../../doc/bootloader/bootinfo/struct.MemoryRegion.html"><code>MemoryRegion</code></a>
в
<a href="../../doc/bootloader/bootinfo/struct.MemoryMap.html"><code>MemoryMap</code></a>.
В каждом из них есть поле
<a href="../../doc/bootloader/bootinfo/struct.MemoryRegion.html#structfield.region_type"><code>MemoryRegion::region_type</code></a>,
которое равно
<a href="../../doc/bootloader/bootinfo/enum.MemoryRegionType.html#variant.Usable"><code>MemoryRegionType::Usable</code></a>
для незанятых диапазонов физической памяти.
Нас будут интересовать только они.
Кроме того, в
<a href="../../doc/bootloader/bootinfo/struct.MemoryRegion.html"><code>MemoryRegion</code></a>
есть поле
<a href="../../doc/bootloader/bootinfo/struct.MemoryRegion.html#structfield.range"><code>MemoryRegion::range</code></a>
типа
<a href="../../doc/bootloader/bootinfo/struct.FrameRange.html"><code>bootloader::bootinfo::FrameRange</code></a>,
которе устроено аналогично
<a href="../../doc/ku/memory/block/struct.Block.html"><code>Block&lt;Frame&gt;</code></a>
и содержит поля
<a href="../../doc/bootloader/bootinfo/struct.FrameRange.html#structfield.start_frame_number"><code>FrameRange::start_frame_number</code></a> и
<a href="../../doc/bootloader/bootinfo/struct.FrameRange.html#structfield.end_frame_number"><code>FrameRange::end_frame_number</code></a>.
Они соответствуют
<a href="../../doc/ku/memory/block/struct.Block.html#structfield.start"><code>Block::&lt;Frame&gt;::start</code></a> и
<a href="../../doc/ku/memory/block/struct.Block.html#structfield.end"><code>Block::&lt;Frame&gt;::end</code></a>.
Из пары
<a href="../../doc/bootloader/bootinfo/struct.FrameRange.html#structfield.start_frame_number"><code>FrameRange::start_frame_number</code></a> и
<a href="../../doc/bootloader/bootinfo/struct.FrameRange.html#structfield.end_frame_number"><code>FrameRange::end_frame_number</code></a>,
можно сделать соответствующий
<a href="../../doc/ku/memory/block/struct.Block.html"><code>Block::&lt;Frame&gt;</code></a>
с помощью метода
<a href="../../doc/ku/memory/block/struct.Block.html#method.new_u64"><code>Block::&lt;Frame&gt;::new_u64(start, end)</code></a>.</p>
<h3 id="Задача-1--bootframeallocator"><a class="header" href="#Задача-1--bootframeallocator">Задача 1 — <a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html"><code>BootFrameAllocator</code></a></a></h3>
<h4 id="Инициализация"><a class="header" href="#Инициализация">Инициализация</a></h4>
<p>Напишите реализацию <a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html#method.new">метода</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn BootFrameAllocator::new(
    memory_map: &amp;MemoryMap,
) -&gt; BootFrameAllocator
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/boot_frame_allocator.rs"><code>kernel/src/memory/boot_frame_allocator.rs</code></a>.
Он должен вернуть заполненную структуру
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html"><code>BootFrameAllocator</code></a>,
содержащую блок свободных фреймов по информации из <code>memory_map</code>.
Выберете самый большой блок подряд идущих свободных фреймов.</p>
<p>Заметьте, что внутри <code>impl BootFrameAllocator { ... }</code> вы можете называть тип <code>BootFrameAllocator</code> через его синоним <code>Self</code>.</p>
<p>Также обратите внимание, что в отличие от C++, параметр обобщённого типа нужно в общем случае предварять двойным двоеточием — <code>Block::&lt;Frame&gt;</code>.
В некоторых контекстах двойное двоеточие можно опустить и написать как в C++ — <code>Block&lt;Frame&gt;</code>.
Если вы не напишете <code>::</code> в случаях, когда оно обязательно, компилятор выдаст ошибку:</p>
<pre><code class="language-console">error: comparison operators cannot be chained
  --&gt; src/memory/boot_frame_allocator.rs:34:39
   |
34 |                 memory_region = %Block&lt;Frame&gt;::new_u64(start, end),
   |                                       ^     ^
   |
help: use `::&lt;...&gt;` instead of `&lt;...&gt;` to specify type or const arguments
   |
34 |                 memory_region = %Block::&lt;Frame&gt;::new_u64(start, end),
   |                                       ++

</code></pre>
<p>Но чаще всего вам не потребуется указывать шаблонный параметр вообще.
Rust использует
<a href="https://ru.wikipedia.org/wiki/%D0%92%D1%8B%D0%B2%D0%BE%D0%B4_%D1%82%D0%B8%D0%BF%D0%BE%D0%B2#%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A5%D0%B8%D0%BD%D0%B4%D0%BB%D0%B8_%E2%80%94_%D0%9C%D0%B8%D0%BB%D0%BD%D0%B5%D1%80%D0%B0">достаточно мощный алгоритм вывода типов</a>
и если вы напишите что-нибудь вроде</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn new(memory_map: &amp;MemoryMap) -&gt; Self {
    ...
    let block = Block::new_u64(start, end);
    ...
    Self {
        block,
        initial_block: block,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>явно указывать <code>::&lt;Frame&gt;</code> не потребуется.
Если же Rust не сможет вывести опущенный параметр обобщённого типа, он выдаст сообщение об ошибке:</p>
<pre><code class="language-const">error[E0282]: type annotations needed
  --&gt; src/memory/boot_frame_allocator.rs:33:34
   |
33 |                 memory_region = %Block::new_u64(start, end),
   |                                  ^^^^^^^^^^^^^^ cannot infer type for type parameter `T`

For more information about this error, try `rustc --explain E0282`.
</code></pre>
<p>На этом примере также видно, что при инициализации поля структуры из переменной с таким же именем,
<a href="https://doc.rust-lang.ru/book/ch05-01-defining-structs.html#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%BE%D0%BA%D1%80%D0%B0%D1%89%D1%91%D0%BD%D0%BD%D0%BE%D0%B9-%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BF%D0%BE%D0%BB%D1%8F">это имя можно не дублировать</a>.</p>
<p>Теперь должен проходить тест <code>2_mm_1_boot_frame_allocator::sanity_check</code>, но не остальные тесты из <code>2-mm-1-boot-frame-allocator</code>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 2-mm-1-boot-frame-allocator)
...
2_mm_1_boot_frame_allocator::sanity_check-------------------
17:20:21 0 D free_frames = 31290; min_free_frames = 28672; qemu_memory_frames = 32768
17:20:21 0 D managed = 31290; used = 0
2_mm_1_boot_frame_allocator::sanity_check---------- [passed]

2_mm_1_boot_frame_allocator::allocate-----------------------
panicked at 'not implemented', kernel/src/memory/boot_frame_allocator.rs:71:9
--------------------------------------------------- [failed]
17:20:21 0 I exit qemu; exit_code = FAILURE
</code></pre>
<h4 id="Аллокация-физических-фреймов"><a class="header" href="#Аллокация-физических-фреймов">Аллокация физических фреймов</a></h4>
<p>Для аллокации фреймов служат два метода:</p>
<ul>
<li><a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html#method.allocate_block"><code>fn BootFrameAllocator::allocate_block(size: usize) -&gt; Result&lt;Block&lt;Frame&gt;&gt;</code></a> выделяет блок подряд идущих фреймов, достаточный для хранения объекта размером <code>size</code> <strong>байт</strong>.</li>
<li><a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html#method.allocate"><code>fn BootFrameAllocator::allocate() -&gt; Result&lt;Frame&gt;</code></a> выделяет ровно один фрейм.</li>
</ul>
<p>Оба метода заворачивают свой результат в <a href="../../doc/kernel/error/type.Result.html"><code>kernel::error::Result</code></a>.
Если в
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html"><code>BootFrameAllocator</code></a>
осталось меньше свободных фреймов, чем было запрошено, они не меняют состояние
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html#structfield.block"><code>BootFrameAllocator::block</code></a>
и возвращают ошибку
<a href="../../doc/kernel/error/enum.Error.html#variant.NoFrame"><code>kernel::error::Error::NoFrame</code></a>.</p>
<p>Реализуйте <a href="../../doc/ku/memory/block/struct.Block.html#method.tail">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Block::tail(&amp;mut self, count: usize) -&gt; Option&lt;Self&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/memory/block.rs"><code>ku/src/memory/block.rs</code></a>.
Он должен разделить блок <code>self</code> на две дизъюнктные части:</p>
<ul>
<li>новое значение <code>self</code> и</li>
<li>новый <a href="../../doc/ku/memory/block/struct.Block.html"><code>Block</code></a> размером <code>count</code> единиц.</li>
</ul>
<p>То есть, от существующего блока он откусывает хвост с заданным количеством единиц, и возвращает его в виде нового блока <code>Self::new(...)</code>, завернув в
<a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#variant.Some"><code>core::option::Option::Some</code></a>:
<code>Some(Self::new(...))</code>.
Если в исходном блоке нет запрошенного количества, не меняйте его и верните
<a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#variant.None"><code>core::option::Option::None</code></a>, например</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn tail(&amp;mut self, count: usize) -&gt; Option&lt;Self&gt; {
    ...
    return None;
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>или просто <code>None</code>, если это последнее выражение в функции:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn tail(&amp;mut self, count: usize) -&gt; Option&lt;Self&gt; {
    ...
    None
}
<span class="boring">}
</span></code></pre></pre>
<p>Проверьте свою реализацию запустив тест:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 2-mm-1-block)
...
2_mm_1_block::block-----------------------------------------
17:21:00 0 D start = 0; end = 0; block = [0v0, 0v0), size 0 B
17:21:00 0 D start = 0; end = 33; block = [0v0, 0v21), size 33 B
17:21:00 0 D start = 0; end = 66; block = [0v0, 0v42), size 66 B
17:21:00 0 D start = 0; end = 99; block = [0v0, 0v63), size 99 B
17:21:00 0 D start = 25; end = 33; block = [0v19, 0v21), size 8 B
17:21:00 0 D start = 25; end = 66; block = [0v19, 0v42), size 41 B
17:21:00 0 D start = 25; end = 99; block = [0v19, 0v63), size 74 B
17:21:01 0 D start = 50; end = 66; block = [0v32, 0v42), size 16 B
17:21:01 0 D start = 50; end = 99; block = [0v32, 0v63), size 49 B
17:21:01 0 D start = 50; end = 132; block = [0v32, 0v84), size 82 B
17:21:01 0 D start = 75; end = 99; block = [0v4B, 0v63), size 24 B
17:21:01 0 D start = 75; end = 132; block = [0v4B, 0v84), size 57 B
17:21:01 0 D start = 75; end = 165; block = [0v4B, 0vA5), size 90 B
2_mm_1_block::block-------------------------------- [passed]
17:21:01 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<p>Применив <a href="../../doc/ku/memory/block/struct.Block.html#method.tail"><code>Block::tail()</code></a>
к полю
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html#structfield.block"><code>BootFrameAllocator::block</code></a>
реализуйте <a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html#method.allocate_block">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn BootFrameAllocator::allocate_block(
    size: usize,
) -&gt; Result&lt;Block&lt;Frame&gt;&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/boot_frame_allocator.rs"><code>kernel/src/memory/boot_frame_allocator.rs</code></a>.
Превратить
<a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#variant.None"><code>Option::None</code></a>
в
<a href="../../doc/kernel/error/enum.Error.html#variant.NoFrame"><code>Error::NoFrame</code></a>
можно с помощью метода
<a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#method.ok_or"><code>Option::ok_or()</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn allocate_block(&amp;mut self, size: usize) -&gt; Result&lt;Block&lt;Frame&gt;&gt; {
    ...
    tail.ok_or(NoFrame)
}
<span class="boring">}
</span></code></pre></pre>
<p>Если вы забудете превратить <code>Option</code> в <code>Result</code> и используете оператор <code>?</code>, Rust выдаст сообщение об ошибке “the <code>?</code> operator can only be used in a function that returns <code>Result</code> or <code>Option</code>”.</p>
<pre><code>error[E0277]: the `?` operator can only be used in a method that returns `Result` or `Option` (or another type that implements `FromResidual`)
  --&gt; kernel/src/memory/boot_frame_allocator.rs:61:41
   |
59 | /     pub(super) fn allocate_block(&amp;mut self, size: usize) -&gt; Result&lt;Block&lt;Frame&gt;&gt; {
60 | |         ...
61 | |         ...?
   | |            ^ cannot use the `?` operator in a method that returns `Result&lt;Block&lt;Frage&lt;PhysTag&gt;&gt;, ku::Error&gt;`
62 | |     }
   | |_____- this function should return `Result` or `Option` to accept `?`
   |
   = help: the trait `FromResidual&lt;core::option::Option&lt;Infallible&gt;&gt;` is not implemented for `Result&lt;Block&lt;Frage&lt;PhysTag&gt;&gt;, ku::Error&gt;`
   = help: the following other types implement trait `FromResidual&lt;R&gt;`:
             &lt;Result&lt;T, F&gt; as FromResidual&lt;Result&lt;Infallible, E&gt;&gt;&gt;
             &lt;Result&lt;T, F&gt; as FromResidual&lt;Yeet&lt;E&gt;&gt;&gt;

For more information about this error, try `rustc --explain E0277`.
</code></pre>
<p>Аналогичная ошибка будет при применении оператора <code>?</code> к <code>Result</code>, если функция возвращает <code>Option</code>.</p>
<p>Вам может пригодиться функция
<a href="../../doc/kernel/memory/frage/struct.Frage.html#method.count_up"><code>fn Frame::count_up(size: usize) -&gt; usize</code></a>.
Она реализует формулу \( \lceil \frac{\texttt{size}}{\texttt{Frame::SIZE}} \rceil \),
возвращая количество фреймов, которое требуется для хранения <code>size</code> байт.</p>
<p>Используя <a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html#method.allocate_block"><code>BootFrameAllocator::allocate_block()</code></a>
реализуйте <a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html#method.allocate">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn BootFrameAllocator::allocate() -&gt; Result&lt;Frame&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/boot_frame_allocator.rs"><code>kernel/src/memory/boot_frame_allocator.rs</code></a>.</p>
<h3 id="Проверьте-себя"><a class="header" href="#Проверьте-себя">Проверьте себя</a></h3>
<p>Запустите тесты:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 2-mm-1-block --test 2-mm-1-boot-frame-allocator)
...
2_mm_1_block::block-----------------------------------------
17:38:22 0 D start = 0; end = 0; block = [0v0, 0v0), size 0 B
17:38:22 0 D start = 0; end = 33; block = [0v0, 0v21), size 33 B
17:38:22 0 D start = 0; end = 66; block = [0v0, 0v42), size 66 B
17:38:22 0 D start = 0; end = 99; block = [0v0, 0v63), size 99 B
17:38:22 0 D start = 25; end = 33; block = [0v19, 0v21), size 8 B
17:38:22 0 D start = 25; end = 66; block = [0v19, 0v42), size 41 B
17:38:22 0 D start = 25; end = 99; block = [0v19, 0v63), size 74 B
17:38:23 0 D start = 50; end = 66; block = [0v32, 0v42), size 16 B
17:38:23 0 D start = 50; end = 99; block = [0v32, 0v63), size 49 B
17:38:23 0 D start = 50; end = 132; block = [0v32, 0v84), size 82 B
17:38:23 0 D start = 75; end = 99; block = [0v4B, 0v63), size 24 B
17:38:23 0 D start = 75; end = 132; block = [0v4B, 0v84), size 57 B
17:38:23 0 D start = 75; end = 165; block = [0v4B, 0vA5), size 90 B
2_mm_1_block::block-------------------------------- [passed]
17:38:23 0 I exit qemu; exit_code = SUCCESS
...
2_mm_1_boot_frame_allocator::sanity_check-------------------
17:38:25 0 D free_frames = 31306; min_free_frames = 28672; qemu_memory_frames = 32768
17:38:25 0 D managed = 31306; used = 0
2_mm_1_boot_frame_allocator::sanity_check---------- [passed]

2_mm_1_boot_frame_allocator::allocate-----------------------
17:38:25 0 D frames = [Frame(32735 @ 0p7FDF000), Frame(32734 @ 0p7FDE000)]
2_mm_1_boot_frame_allocator::allocate-------------- [passed]

2_mm_1_boot_frame_allocator::allocated_frames_are_unique----
17:38:25 0 D free_frames = 31304
17:38:25 0 D prev_frame = 32733 @ 0p7FDD000; frame = 32732 @ 0p7FDC000
17:38:25 0 D prev_frame = 22733 @ 0p58CD000; frame = 22732 @ 0p58CC000
17:38:26 0 D prev_frame = 12733 @ 0p31BD000; frame = 12732 @ 0p31BC000
17:38:26 0 D prev_frame = 2733 @ 0pAAD000; frame = 2732 @ 0pAAC000
2_mm_1_boot_frame_allocator::allocated_frames_are_unique [passed]
17:38:26 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<h3 id="Использование-аллокатора-физических-фреймов"><a class="header" href="#Использование-аллокатора-физических-фреймов">Использование аллокатора физических фреймов</a></h3>
<p>Ядро выделяет физические фреймы с помощью глобальной переменной
<a href="../../doc/kernel/memory/struct.FRAME_ALLOCATOR.html"><code>kernel::memory::FRAME_ALLOCATOR</code></a>.
Это
<a href="../../doc/kernel/memory/enum.FrameAllocator.html"><code>kernel::memory::FrameAllocator</code></a>,
обёрнутый в спинлок
<a href="../../doc/spin/mutex/struct.Mutex.html"><code>spin::mutex::Mutex</code></a> —
<a href="../../doc/spin/mutex/struct.Mutex.html"><code>Mutex</code></a><code>&lt;</code><a href="../../doc/kernel/memory/enum.FrameAllocator.html"><code>FrameAllocator</code></a><code>&gt;</code>.
Чтобы работать с
<a href="../../doc/kernel/memory/struct.FRAME_ALLOCATOR.html"><code>FRAME_ALLOCATOR</code></a>,
нужно сначала захватить блокировку методом
<a href="../../doc/spin/mutex/struct.Mutex.html#method.lock"><code>Mutex::lock()</code></a>,
а затем уже вызвать подходящий метод
<a href="../../doc/kernel/memory/enum.FrameAllocator.html"><code>FrameAllocator</code></a>,
например
<a href="../../doc/kernel/memory/enum.FrameAllocator.html#method.allocate"><code>FrameAllocator::allocate()</code></a>.
Метод
<a href="../../doc/spin/mutex/struct.Mutex.html#method.lock"><code>Mutex::lock()</code></a>
возвращает
<a href="../../doc/spin/mutex/struct.MutexGuard.html"><code>spin::mutex::MutexGuard</code></a>
который:</p>
<ul>
<li>За <a href="../../doc/spin/mutex/struct.MutexGuard.html#impl-Deref">счёт</a> <a href="../../doc/spin/mutex/struct.MutexGuard.html#impl-DerefMut">реализации</a> типажей <a href="https://doc.rust-lang.org/nightly/core/ops/trait.Deref.html"><code>core::ops::Deref</code></a> и <a href="https://doc.rust-lang.org/nightly/core/ops/trait.DerefMut.html"><code>core::ops::DerefMut</code></a> предоставляет прозрачный доступ к внутреннему <a href="../../doc/kernel/memory/enum.FrameAllocator.html"><code>FrameAllocator</code></a>.</li>
<li>При разрушении, например при выходе из своей зоны видимости или <a href="../../doc/spin/mutex/struct.Mutex.html#thread-safety-example">явном вызове <code>drop(guard)</code></a>, автоматически освобождает захваченную блокировку.</li>
</ul>
<p>Пример использования с блокировками, которые освобождаются сразу, в том же выражении, есть в тестах <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/memory.rs"><code>kernel/tests/memory.rs</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let frame = FRAME_ALLOCATOR
        .lock()
        .allocate()
        .expect(&quot;failed to allocate a frame&quot;);

    debug!(?frame);

    FRAME_ALLOCATOR
        .lock()
        .reference(frame);
<span class="boring">}
</span></code></pre></pre>
<p>Сам
<a href="../../doc/kernel/memory/enum.FrameAllocator.html"><code>FrameAllocator</code></a>
определён в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/mod.rs"><code>kernel/src/memory/mod.rs</code></a>
как один из трёх вариантов:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum FrameAllocator {
    Void,
    Boot(BootFrameAllocator),
    Main(MainFrameAllocator),
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><a href="../../doc/kernel/memory/enum.FrameAllocator.html#variant.Void"><code>FrameAllocator::Void</code></a> означает что пока что никакой реализации не доступно и аллокация приведёт к ошибке <a href="../../doc/kernel/error/enum.Error.html#variant.NoFrame"><code>Error::NoFrame</code></a>.</li>
<li><a href="../../doc/kernel/memory/enum.FrameAllocator.html#variant.Boot"><code>FrameAllocator::Boot</code></a> — аллокации фреймов будут происходить из написанного вами в задачах 1 и 2 <a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html"><code>BootFrameAllocator</code></a>.</li>
<li><a href="../../doc/kernel/memory/enum.FrameAllocator.html#variant.Main"><code>FrameAllocator::Main</code></a> — используется основной аллокатор фреймов, который <a href="../../lab/book/2-mm-7-main-frame-allocator.html">вы реализуете позже</a>.</li>
</ul>
<p>Соответственно реализация, например, метода
<a href="../../doc/kernel/memory/enum.FrameAllocator.html#method.allocate"><code>FrameAllocator::allocate()</code></a> —
это простая диспетчеризация:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FrameAllocator {
    ...
    pub fn allocate(&amp;mut self) -&gt; Result&lt;Frame&gt; {
        match self {
            FrameAllocator::Void =&gt; Err(NoFrame),
            FrameAllocator::Boot(boot_allocator) =&gt; boot_allocator.allocate(),
            FrameAllocator::Main(main_allocator) =&gt; main_allocator.allocate(),
        }
    }
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Другие методы
<a href="../../doc/kernel/memory/enum.FrameAllocator.html"><code>FrameAllocator</code></a>
реализованы аналогично.</p>
<p>Если взглянуть на наш план функции
<a href="../../doc/kernel/memory/fn.init.html"><code>kernel::memory::init()</code></a>
ещё раз:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init(boot_info: &amp;'static BootInfo) {
    ...

    *FRAME_ALLOCATOR.lock() = FrameAllocator::Boot(
        BootFrameAllocator::new(&amp;boot_info.memory_map)
    );

    *BASE_ADDRESS_SPACE.lock() = AddressSpace::new(phys2virt);

    *FRAME_ALLOCATOR.lock() = FrameAllocator::Main(
        main_frame_allocator::init(&amp;boot_info.memory_map),
    );

    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Видно, что после строчки <code>*FRAME_ALLOCATOR.lock() = FrameAllocator::Boot(...)</code> становится доступна
аллокация физических фреймов.
Которой пользуются <code>AddressSpace</code> и <code>main_frame_allocator::init()</code>.
А потом глобальный аллокатор переключается на основной: <code>*FRAME_ALLOCATOR.lock() = FrameAllocator::Main(...)</code> и
больше
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html"><code>BootFrameAllocator</code></a>
не используется.</p>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-3"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-3">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/memory/boot_frame_allocator.rs |   45 +++++++++++++++++++++++++++---
 ku/src/memory/block.rs                    |    8 ++++-
 2 files changed, 48 insertions(+), 5 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Виртуальное-адресное-пространство"><a class="header" href="#Виртуальное-адресное-пространство">Виртуальное адресное пространство</a></h2>
<p>Управление виртуальной памятью включает в себя три компонента:</p>
<ul>
<li>Выделение физических фреймов памяти.</li>
<li>Выделение виртуальных страниц адресного пространства.</li>
<li>Поддержание отображения виртуальных страниц в физические фреймы.</li>
</ul>
<p>Представьте себе, что приложение попросило у ядра <code>size</code> байт памяти.
Подсистема памяти может управлять только страницами.
Она не может выдать часть страницы одному процессу, а часть другому, так как права доступа к памяти регулируются с гранулярностью в страницу<sup class="footnote-reference"><a href="#1">1</a></sup>.
Поэтому прежде всего ядро должно посчитать, сколько страниц достаточно для удовлетворения такого запроса —
\( n = \lceil \frac{\texttt{size}}{\texttt{Page::SIZE}} \rceil \), где
<a href="../../doc/ku/memory/frage/struct.Frage.html#associatedconstant.SIZE"><code>Page::SIZE</code></a> —
размер страницы в байтах.
Из-за округления вверх, возможно, придётся выделить чуть больше запрошенного количества байт.</p>
<p>Далее, ядро должно найти \( n \) свободных физических фреймов.
Причём, благодаря собственно виртуальности, не требуется чтобы они были смежными.
Этот этап ядро может сделать лениво, то есть выделять физические фреймы только по мере того как приложение будет обращаться к выделенной памяти.
Для простоты мы не будем реализовывать ленивое выделение физических фреймов.</p>
<p>А вот в виртуальном адресном пространстве нужно найти блок из \( n \) подряд идущих свободных виртуальных страниц.
Потому что ядро должно вернуть запрошенную память непрерывным блоком адресов.
Чтобы приложение могло работать с вернувшимся блоком памяти как с непрерывным массивом размером <code>size</code> байт.
Приложение работает в виртуальных адресах, поэтому именно виртуальные адреса должны идти подряд.</p>
<p>Наконец, ядро должно модифицировать отображение виртуальных страниц в физические фреймы так,
чтобы только что выделенные виртуальные страницы ссылались на выделенные физические фреймы.
Если выделение памяти делается лениво, то отображение нужно модифицировать в два этапа:</p>
<ul>
<li>Пометить в отображении виртуальные страницы как выделенные, но не отображённые на физические фреймы.</li>
<li>Когда приложение обратится к одной из этих страниц, проверить что виртуальная страница действительно была выделена. И если была, то выделить физический фрейм и отобразить виртуальную страницу на него.</li>
</ul>
<p>На данном этапе лабораторки у нас уже есть временный аллокатор физических фреймов.
Займёмся реализацией остальных двух пунктов:</p>
<ul>
<li>Выделением виртуальных страниц адресного пространства.</li>
<li>Поддержанием отображения виртуальных страниц в физические фреймы.</li>
</ul>
<blockquote>
<p><sup class="footnote-reference"><a href="#1">1</a></sup>: В 32–битном защищённом режиме <a href="https://en.wikipedia.org/wiki/X86-64">x86-64</a> доступна сегментация адресного пространства. Она вводит дополнительный механизм контроля доступа к памяти с гранулярностью либо страница, либо байт, в зависимости от настроек сегмента. Этот механизм используется в статьях “Improved Address Space Switching on Pentium Processors by Transparently Multiplexing User Address Spaces” и <a href="https://haeberlen.cis.upenn.edu/papers/smallspaces-tr.pdf">Performance of Address-Space Multiplexing on the Pentium</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Аллокатор-виртуальных-страниц-адресного-пространства"><a class="header" href="#Аллокатор-виртуальных-страниц-адресного-пространства">Аллокатор виртуальных страниц адресного пространства</a></h2>
<p>За выделение последовательно идущих виртуальных страниц отвечает
<a href="../../doc/kernel/memory/page_allocator/struct.PageAllocator.html"><code>kernel::memory::page_allocator::PageAllocator</code></a>.
Он устроен столь же просто, как уже знакомый нам
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html"><code>BootFrameAllocator</code></a>.
У него есть
<a href="../../doc/kernel/memory/page_allocator/struct.PageAllocator.html#structfield.block"><code>PageAllocator::block</code></a> —
<a href="../../doc/ku/memory/block/struct.Block.html"><code>Block&lt;Page&gt;</code></a>,
из которого он выделяет блоки страниц уже реализованной нами функцией
<a href="../../doc/ku/memory/block/struct.Block.html#method.tail"><code>Block::tail()</code></a>.</p>
<p>Инициализировать же
<a href="../../doc/kernel/memory/page_allocator/struct.PageAllocator.html#structfield.block"><code>PageAllocator::block</code></a>
предлагается следующим способом.
Пройдём по таблице страниц корневого уровня.
Пусть, например, оказалось, что запись номер \( 17 \) корневого уровня свободна.
Тогда свободны все виртуальные адреса в полуинтервале
\( [17 \cdot 2^{9 + 9 + 9 + 12}, 18 \cdot 2^{9 + 9 + 9 + 12}) \).
Это дает \( 2^{9 + 9 + 9} \) свободных виртуальных страниц,
то есть 512 GiB адресного пространства на каждую такую запись.
Действительно, каждая запись в узле таблицы страниц на уровне
<a href="../../doc/ku/memory/mmu/constant.PAGE_TABLE_LEAF_LEVEL.html"><code>ku::memory::mmu::PAGE_TABLE_LEAF_LEVEL</code></a><code>== 0</code>
ссылается на виртуальную страницу, то есть ссылается на блок памяти размера 4KiB или \( 2^{12} \) байт.
Каждая запись в узле более высокого уровня ссылается на
<a href="../../doc/ku/memory/mmu/constant.PAGE_TABLE_ENTRY_COUNT.html"><code>ku::memory::mmu::PAGE_TABLE_ENTRY_COUNT</code></a>
записей более низкого уровня.
То есть через неё адресуется в
<a href="../../doc/ku/memory/mmu/constant.PAGE_TABLE_ENTRY_COUNT.html"><code>ku::memory::mmu::PAGE_TABLE_ENTRY_COUNT</code></a><code>== 512</code>,
или в \( 2^{9} \),
раз больше байт.
Поэтому, если
<a href="../../doc/ku/memory/mmu/constant.PAGE_TABLE_ROOT_LEVEL.html"><code>ku::memory::mmu::PAGE_TABLE_ROOT_LEVEL</code></a><code>== 3</code>,
то всего выходит 512 * 512 * 512 * 4KiB = 512 GiB, или \( 2^{9 + 9 + 9 + 12} \) байт.
Найдем в таблице страниц корневого уровня самую длинную последовательность подряд идущих свободных записей —
добудем много подряд идущих свободных виртуальных страниц.
Почти все \( 2^9 \) записи корневого уровня свободны,
а значит получаем почти по 128 TiB непрерывного свободного адресного пространства в каждой из
<a href="../../lab/book/2-mm-1-types.html#%D0%94%D0%B2%D0%B5-%D0%BF%D0%BE%D0%BB%D0%BE%D0%B2%D0%B8%D0%BD%D1%8B-%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B0%D0%B4%D1%80%D0%B5%D1%81%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%B0">двух половин</a>.
При этом рассматривать будем только записи корневого узла таблицы страниц,
спускаться на следующие уровни не будем.</p>
<p>Для простоты реализации
<a href="../../doc/kernel/memory/page_allocator/struct.PageAllocator.html"><code>PageAllocator</code></a>
не умеет ничего освобождать, как и
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html"><code>BootFrameAllocator</code></a>.
Но в отличие от физических фреймов, виртуальных страниц гораздо больше — сотни TiB, и они не потребляют память.
Кроме того, адресное пространство будет отдельное на каждый процесс.
И даже если процесс исчерпает все виртуальные страницы своего адресного пространства,
на другие процессы это не повлияет.
Поэтому с такой реализацией аллокатора страниц проблем не возникнет.
В отличие от
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html"><code>BootFrameAllocator</code></a>,
который нам придётся заменить на
<a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html"><code>MainFrameAllocator</code></a>.</p>
<h3 id="Задача-2--pageallocator"><a class="header" href="#Задача-2--pageallocator">Задача 2 — <a href="../../doc/kernel/memory/page_allocator/struct.PageAllocator.html"><code>PageAllocator</code></a></a></h3>
<h4 id="Инициализация-аллокатора-страниц"><a class="header" href="#Инициализация-аллокатора-страниц">Инициализация аллокатора страниц</a></h4>
<p>Реализуйте вспомогательную <a href="../../doc/kernel/memory/page_allocator/struct.PageAllocator.html#method.find_unused_block">функцию</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn PageAllocator::find_unused_block(page_directory: &amp;PageTable) -&gt; Option&lt;Block&lt;Page&gt;&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/page_allocator.rs"><code>kernel/src/memory/page_allocator.rs</code></a>.
Эта функция принимает на вход таблицу страниц
<a href="../../doc/ku/memory/mmu/type.PageTable.html"><code>ku::memory::mmu::PageTable</code></a>
корневого уровня и должна вернуть блок страниц
<a href="../../doc/ku/memory/block/struct.Block.html"><code>Block&lt;Page&gt;</code></a>,
соответствующий самой длинной последовательности пустых записей в <code>page_directory</code>.
Если все записи заняты, верните <code>None</code>.</p>
<p>Узел дерева многоуровневой таблицы страниц
<a href="../../doc/ku/memory/mmu/type.PageTable.html"><code>PageTable</code></a>
это просто массив из
<a href="../../doc/ku/memory/mmu/constant.PAGE_TABLE_ENTRY_COUNT.html"><code>ku::memory::mmu::PAGE_TABLE_ENTRY_COUNT</code></a>
элементов типа
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html"><code>ku::memory::mmu::PageTableEntry</code></a>.
С
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html"><code>PageTableEntry</code></a>
мы будем ещё много работать.
Пока что скорее всего хватит её метода
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html#method.present"><code>fn PageTableEntry::present(&amp;self) -&gt; bool</code></a>.
Он возвращает <code>true</code>, если запись используется.</p>
<p>Вам может пригодиться константа
<a href="../../doc/ku/memory/mmu/constant.PAGE_TABLE_ROOT_LEVEL.html"><code>ku::memory::mmu::PAGE_TABLE_ROOT_LEVEL</code></a> —
номер корневого уровня таблицы страниц, если считать листьевой уровень
<a href="../../doc/ku/memory/mmu/constant.PAGE_TABLE_LEAF_LEVEL.html"><code>ku::memory::mmu::PAGE_TABLE_LEAF_LEVEL</code></a>
с записями про отдельные страницы нулевым.
Также могут пригодиться и
<a href="../../doc/ku/memory/mmu/index.html#constants">другие константы</a>
из файла <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/memory/mmu.rs"><code>ku/src/memory/mmu.rs</code></a></p>
<p>Вспомните про <a href="2-mm-1-types.html#%D0%94%D0%B2%D0%B5-%D0%BF%D0%BE%D0%BB%D0%BE%D0%B2%D0%B8%D0%BD%D1%8B-%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B0%D0%B4%D1%80%D0%B5%D1%81%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%B0">две половины виртуального адресного пространства</a>.
Используйте только одну из них.
Учтите, что при выборе половины со старшими адресами — <code>0vFFFF_...</code> — читать адреса в логах
может быть менее удобно.</p>
<p>При инициализации ядра
<a href="../../doc/kernel/memory/page_allocator/struct.PageAllocator.html"><code>PageAllocator</code></a>
залогирует примерно такое сообщение:</p>
<pre><code class="language-console">15:08:28 0 I page allocator init; free_page_count = 33822867456; block = [2.000 TiB, 128.000 TiB), size 126.000 TiB
</code></pre>
<h4 id="Аллокация-виртуальных-страниц"><a class="header" href="#Аллокация-виртуальных-страниц">Аллокация виртуальных страниц</a></h4>
<p>Применив <a href="../../doc/ku/memory/block/struct.Block.html#method.tail"><code>Block::tail()</code></a>
к полю
<a href="../../doc/kernel/memory/page_allocator/struct.PageAllocator.html#structfield.block"><code>PageAllocator::block</code></a>
реализуйте <a href="../../doc/kernel/memory/page_allocator/struct.PageAllocator.html#method.allocate">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn PageAllocator::allocate(&amp;mut self, size: usize) -&gt; Result&lt;Block&lt;Page&gt;&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/page_allocator.rs"><code>kernel/src/memory/page_allocator.rs</code></a>.
Она принимает размер <strong>в байтах</strong> и возвращает блок свободных виртуальных страниц
<a href="../../doc/ku/memory/block/struct.Block.html"><code>Block&lt;Page&gt;</code></a>.
Если свободных страниц не хватает, верните ошибку
<a href="../../doc/kernel/error/enum.Error.html#variant.NoPage"><code>kernel::error::Error::NoPage</code></a>.</p>
<p>Вам может пригодиться функция
<a href="../../doc/kernel/memory/frage/struct.Frage.html#method.count_up"><code>fn Page::count_up(size: usize) -&gt; usize</code></a>.
Она реализует формулу \( \lceil \frac{\texttt{size}}{\texttt{Page::SIZE}} \rceil \),
возвращая количество страниц, которое требуется для хранения <code>size</code> байт.
Также может пригодиться метод
<a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#method.ok_or"><code>Option::ok_or()</code></a>:
<code>tail.ok_or(NoPage)</code>.</p>
<p>Метод
<a href="../../doc/kernel/memory/page_allocator/struct.PageAllocator.html#method.allocate"><code>PageAllocator::allocate()</code></a>
похож на уже реализованный вами
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html#method.allocate_block"><code>BootFrameAllocator::allocate_block()</code></a>.</p>
<h3 id="Проверьте-себя-1"><a class="header" href="#Проверьте-себя-1">Проверьте себя</a></h3>
<p>Запустите тесты:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 2-mm-1-block --test 2-mm-2-page-allocator)
...
2_mm_1_block::block-----------------------------------------
18:00:54 0 D start = 0; end = 0; block = [0v0, 0v0), size 0 B
18:00:54 0 D start = 0; end = 33; block = [0v0, 0v21), size 33 B
18:00:54 0 D start = 0; end = 66; block = [0v0, 0v42), size 66 B
18:00:54 0 D start = 0; end = 99; block = [0v0, 0v63), size 99 B
18:00:54 0 D start = 25; end = 33; block = [0v19, 0v21), size 8 B
18:00:54 0 D start = 25; end = 66; block = [0v19, 0v42), size 41 B
18:00:54 0 D start = 25; end = 99; block = [0v19, 0v63), size 74 B
18:00:55 0 D start = 50; end = 66; block = [0v32, 0v42), size 16 B
18:00:55 0 D start = 50; end = 99; block = [0v32, 0v63), size 49 B
18:00:55 0 D start = 50; end = 132; block = [0v32, 0v84), size 82 B
18:00:55 0 D start = 75; end = 99; block = [0v4B, 0v63), size 24 B
18:00:55 0 D start = 75; end = 132; block = [0v4B, 0v84), size 57 B
18:00:55 0 D start = 75; end = 165; block = [0v4B, 0vA5), size 90 B
2_mm_1_block::block-------------------------------- [passed]
18:00:55 0 I exit qemu; exit_code = SUCCESS
...
2_mm_2_page_allocator::sanity_check-------------------------
18:00:57 0 D page_allocator_block = [0v18000000000, 0v7FFFFFFFF000), size 126.500 TiB, Page[~1.500 TiB, ~128.000 TiB)
2_mm_2_page_allocator::sanity_check---------------- [passed]

2_mm_2_page_allocator::allocate_page------------------------
18:00:57 0 D page = Page(34359738366 @ 0v7FFFFFFFE000)
2_mm_2_page_allocator::allocate_page--------------- [passed]

2_mm_2_page_allocator::allocate_two_pages-------------------
18:00:57 0 D pages = [Page(34359738365 @ 0v7FFFFFFFD000), Page(34359738364 @ 0v7FFFFFFFC000)]
2_mm_2_page_allocator::allocate_two_pages---------- [passed]

2_mm_2_page_allocator::allocate_block-----------------------
18:00:57 0 D requested_size = 38.000 KiB; block = [0v7FFFFFFF2000, 0v7FFFFFFFC000), size 40.000 KiB, Page[~128.000 TiB, ~128.000 TiB)
2_mm_2_page_allocator::allocate_block-------------- [passed]
18:00:57 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-4"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-4">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/memory/page_allocator.rs |   32 ++++++++++++++++++++++++++++++--
 1 file changed, 30 insertions(+), 2 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Отображение-виртуальных-страниц-в-физические-фреймы"><a class="header" href="#Отображение-виртуальных-страниц-в-физические-фреймы">Отображение виртуальных страниц в физические фреймы</a></h2>
<p>За это отображение отвечает структура
<a href="../../doc/kernel/memory/mapping/struct.Mapping.html"><code>kernel::memory::mapping::Mapping</code></a>.
Фактически она реализует дерево большой арности — 512, если закрыть глаза на возможность сослаться в узле на любой узел.
Такая возможность используется только в специфических случаях, например для реализации <a href="https://wiki.osdev.org/Page_Tables#Recursive_mapping">рекурсивного отображения</a>.</p>
<p><a href="../../doc/kernel/memory/mapping/struct.Mapping.html"><code>Mapping</code></a> содержит уже немного знакомые нам поля:</p>
<ul>
<li><a href="../../doc/kernel/memory/mapping/struct.Mapping.html#structfield.page_directory"><code>Mapping::page_directory</code></a> типа <a href="../../doc/ku/memory/mmu/type.PageTable.html"><code>PageTable</code></a> — таблица страниц самого верхнего уровня, корневая в дереве.</li>
<li><a href="../../doc/kernel/memory/mapping/struct.Mapping.html#structfield.phys2virt"><code>Mapping::phys2virt</code></a> типа <a href="../../doc/ku/memory/frage/type.Page.html"><code>Page</code></a> — начало “окна”, в которое отображена вся физическая память.</li>
</ul>
<p><a href="../../doc/kernel/memory/mapping/struct.Mapping.html#structfield.phys2virt"><code>Mapping::phys2virt</code></a>
нужен, чтобы с помощью функции</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn phys2virt_map(phys2virt: Page, address: Phys) -&gt; Virt
<span class="boring">}
</span></code></pre></pre>
<p>по заданному физическому адресу, найти куда он отображён в “окне”.
Это потребуется когда нам нужно будет записать в какую-нибудь
<a href="../../doc/ku/memory/mmu/type.PageTable.html"><code>PageTable</code></a>.
Так как в
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html"><code>PageTableEntry</code></a> таблица
<a href="../../doc/ku/memory/mmu/type.PageTable.html"><code>PageTable</code></a> следующего вниз уровня
задаётся именно физическим адресом.</p>
<blockquote>
<p>Подумайте, а можно ли было бы в
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html"><code>PageTableEntry</code></a>
хранить виртуальный адрес
<a href="../../doc/ku/memory/mmu/type.PageTable.html"><code>PageTable</code></a>,
на которую ссылается данная
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html"><code>PageTableEntry</code></a>?</p>
</blockquote>
<p>Отображение виртуальных страниц на физические фреймы:</p>
<p><img src="2-mm-6-address-space-2-virt-to-phys.svg" alt="" /></p>
<p>Про отображение страниц можно почитать на сайте <a href="https://wiki.osdev.org/">osdev</a>, нас интересует 64-битный вариант для x86-64:</p>
<ul>
<li><a href="https://wiki.osdev.org/Memory_management">Memory management</a>.</li>
<li><a href="https://wiki.osdev.org/Paging">Paging</a>.</li>
</ul>
<p>Ещё более подробный и обстоятельный разбор есть в блоге <a href="https://os.phil-opp.com/">Writing an OS in Rust</a>:</p>
<ul>
<li><a href="https://os.phil-opp.com/paging-introduction/">Introduction to Paging</a>, <a href="https://habr.com/ru/post/436606/">перевод</a>.</li>
<li><a href="https://os.phil-opp.com/paging-implementation/">Paging Implementation</a>, <a href="https://habr.com/ru/post/445618/">перевод</a>.</li>
</ul>
<h3 id="Задача-3--mapping"><a class="header" href="#Задача-3--mapping">Задача 3 — <a href="../../doc/kernel/memory/mapping/struct.Mapping.html"><code>Mapping</code></a></a></h3>
<h4 id="Отображение-виртуальных-страниц-на-физические-фреймы"><a class="header" href="#Отображение-виртуальных-страниц-на-физические-фреймы">Отображение виртуальных страниц на физические фреймы</a></h4>
<p>Страничное преобразование устроено как показано на схеме.
Стрелки ведут из физических адресов, хранящихся в регистре
<a href="https://wiki.osdev.org/CPU_Registers_x86#CR3"><code>CR3</code></a>
и в элементах
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html"><code>ku::memory::mmu::PageTableEntry</code></a>
таблиц
<a href="../../doc/ku/memory/mmu/type.PageTable.html"><code>ku::memory::mmu::PageTable</code></a>,
в целевые фреймы и целевой байт.
А пунктиром показано какая часть битового представления виртуального адреса
(<a href="../../doc/ku/memory/addr/type.Virt.html"><code>Virt</code></a>)
используется как индекс в одной из таблиц
<a href="../../doc/ku/memory/mmu/type.PageTable.html"><code>PageTable</code></a>,
либо как смещение внутри целевого фрейма.
Каждая <a href="../../doc/ku/memory/mmu/type.PageTable.html"><code>PageTable</code></a> занимает ровно один фрейм физической памяти.</p>
<p><img src="2-mm-6-address-space-2-translate.svg" alt="" /></p>
<p>Вооружившись этими знаниями, реализуйте <a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.translate">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn Mapping::translate(
    &amp;mut self,
    virt: Virt,
    mut frame_allocator: Option&lt;&amp;mut FrameAllocator&gt;,
    flags: PageTableFlags,
) -&gt; Result&lt;&amp;mut PageTableEntry&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/mapping.rs"><code>kernel/src/memory/mapping.rs</code></a>.
Он принимает на вход</p>
<ul>
<li>Виртуальный адрес <code>virt</code>, который нужно транслировать.</li>
<li>Опциональный аллокатор фреймов <code>frame_allocator</code>.</li>
<li>Флаги <code>flags</code> для промежуточных записей таблиц страниц, если их придётся создавать.</li>
</ul>
<p>И возвращает ссылку на запись
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html"><code>PageTableEntry</code></a>
в
<a href="../../doc/ku/memory/mmu/type.PageTable.html"><code>PageTable</code></a>
листьевого уровня (L0 на схеме),
соответствующую входному виртуальному адресу <code>virt</code>.
Возвращается ссылка на изменяемую
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html"><code>PageTableEntry</code></a>,
а не например
<a href="../../doc/ku/memory/addr/type.Phys.html"><code>Phys</code></a>.
Чтобы вызывающая функция могла потом как-либо модифицировать отображение <code>virt</code> — удалить это отображение, изменить его флаги, поменять физический адрес.
Получить же целевой
<a href="../../doc/ku/memory/addr/type.Phys.html"><code>Phys</code></a>
из возвращённой
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html"><code>PageTableEntry</code></a>
можно в одно действие —
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html#method.phys"><code>PageTableEntry::phys()</code></a>.</p>
<p><a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.translate"><code>Mapping::translate()</code></a>
должен пройти от корневой L3 до листьевой L0 по физическим фреймам, которые возвращает метод
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html#method.frame"><code>fn PageTableEntry::frame() -&gt; Result&lt;Frame&gt;</code></a>
для промежуточных
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html"><code>PageTableEntry</code></a>.
Если какая-то из этих промежуточных
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html"><code>PageTableEntry</code></a>
не отображена на физическую память, то есть два варианта:</p>
<ul>
<li>Входной <code>frame_allocator</code> равен <a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#variant.None"><code>None</code></a>, тогда <a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.translate"><code>Mapping::translate()</code></a> сразу выходит, возвращая ошибку <a href="../../doc/kernel/error/enum.Error.html#variant.NoPage"><code>Error::NoPage</code></a>.</li>
<li>Входной <code>frame_allocator</code> равен <a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#variant.Some"><code>Some</code></a>, тогда <a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.translate"><code>Mapping::translate()</code></a> аллоцирует с его помощью фрейм для недостающей промежуточной <a href="../../doc/ku/memory/mmu/type.PageTable.html"><code>PageTable</code></a>. И очищает её — все записи в ней должны быть равны значению, которое возвращает метод <a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html#method.default"><code>PageTableEntry::default()</code></a>.</li>
</ul>
<p>Вам может пригодиться конструкция <code>frame_allocator.as_mut().ok_or(NoPage)?</code>. В ней
<a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#method.as_mut"><code>Option::as_mut()</code></a>
преобразует <code>&amp;mut Option&lt;FrameAllocator&gt;</code> в <code>Option&lt;&amp;mut FrameAllocator&gt;</code>.
Далее, уже встречавшаяся нам <code>Option::ok_or(NoPage)</code> преобразует
<a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#variant.None"><code>Option::None</code></a>
в
<a href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html#variant.Err"><code>Result::Err(NoPage)</code></a>
а
<a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#variant.Some"><code>Option::Some(frame_allocator)</code></a>
в
<a href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html#variant.Ok"><code>Result::Ok(frame_allocator)</code></a>.
Последним штрихом <code>?</code> разворачивает
<a href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html#variant.Ok"><code>Result::Ok(frame_allocator)</code></a>
в содержащийся внутри <code>&amp;mut FrameAllocator</code>, а
<a href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html#variant.Err"><code>Result::Err</code></a>
прокидывает в вызывающую функцию.
Именно изменяемый <code>&amp;mut FrameAllocator</code> нужен нам чтобы аллоцировать из него фреймы для промежуточных таблиц
<a href="../../doc/ku/memory/mmu/type.PageTable.html"><code>PageTable</code></a>,
если это понадобится.
Ещё один вариант — использовать
<a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#method.as_deref_mut"><code>Option::as_deref_mut()</code></a>
вместо
<a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#method.as_mut"><code>Option::as_mut()</code></a>.</p>
<p>Если во
<a href="../../doc/kernel/memory/enum.FrameAllocator.html"><code>FrameAllocator</code></a>
не окажется свободных фреймов, он вернёт ошибку
<a href="../../doc/kernel/error/enum.Error.html#variant.NoFrame"><code>Error::NoFrame</code></a>,
как мы реализовали в
<a href="../../lab/book/2-mm-5-boot-frame-allocator.html#%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-2--%D0%B0%D0%BB%D0%BB%D0%BE%D0%BA%D0%B0%D1%86%D0%B8%D1%8F-%D1%84%D1%80%D0%B5%D0%B9%D0%BC%D0%BE%D0%B2">задаче 2</a>.
Заметьте, что:</p>
<ul>
<li>Если в <a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.translate"><code>Mapping::translate()</code></a>
не передали <a href="../../doc/kernel/memory/enum.FrameAllocator.html"><code>FrameAllocator</code></a>, она возвращает <a href="../../doc/kernel/error/enum.Error.html#variant.NoPage"><code>Error::NoPage</code></a>. Это означает “виртуальная страница для данного <code>virt</code> не отображена в физическую память”.</li>
<li>А если передали, но он не смог выделить свободный физический фрейм, то <a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.translate"><code>Mapping::translate()</code></a> вернёт ошибку <a href="../../doc/kernel/error/enum.Error.html#variant.NoFrame"><code>kernel::error::Error::NoFrame</code></a>. Это означает “во время исполнения операции понадобилось выделить дополнительный физический фрейм, но свободных фреймов не осталось”.</li>
</ul>
<p>У этих двух ситуаций разный смысл, поэтому
<a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.translate"><code>Mapping::translate()</code></a>
возвращает для них разные значения ошибок.</p>
<p>Если в промежуточной таблице встретилась запись, в которой
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html#method.flags"><code>PageTableEntry::flags()</code></a>
содержит флаг
<a href="../../doc/ku/memory/mmu/struct.PageTableFlags.html#associatedconstant.HUGE_PAGE"><code>PageTableFlags::HUGE_PAGE</code></a>,
верните
<a href="../../doc/kernel/error/enum.Error.html#variant.Unimplemented"><code>Error::Unimplemented</code></a>.
Такая запись не является промежуточной, а задаёт большую страницу, —
<a href="https://en.wikipedia.org/wiki/X86-64#Virtual_address_space_details">x86-64 поддерживает</a> страницы
<a href="https://en.wikipedia.org/wiki/Page_(computer_memory)#Multiple_page_sizes">размеров <code>4 KiB</code>, <code>2 MiB</code> и <code>1 GiB</code></a>.
Мы не будем их поддерживать.
Но они нам будут попадаться, потому что с их помощью
<a href="../../doc/bootloader/index.html">bootloader</a>
отображает всю физическую память в “окно” в виртуальной.
Делается это для экономии физических фреймов на само отображение.</p>
<p>Кроме того, есть ещё такой момент.
Если вызывающая функция захочет отобразить <code>virt</code>, например, с возможностью записи, и установит
соответствующий флаг
<a href="../../doc/ku/memory/mmu/struct.PageTableFlags.html#associatedconstant.WRITABLE"><code>PageTableFlags::WRITABLE</code></a>
только в том элементе
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html"><code>PageTableEntry</code></a>
таблицы L0, которую вернёт
<a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.translate"><code>Mapping::translate()</code></a>,
этого может оказаться недостаточно.
Дело в том, что процессор пересечёт флаги <a href="../../doc/ku/memory/mmu/struct.PageTableFlags.html#associatedconstant.WRITABLE"><code>PageTableFlags::WRITABLE</code></a>
из всех промежуточных
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html"><code>PageTableEntry</code></a>
по схеме <code>И</code>.
И если в какой-то из промежуточных
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html"><code>PageTableEntry</code></a>
флаг
<a href="../../doc/ku/memory/mmu/struct.PageTableFlags.html#associatedconstant.WRITABLE"><code>PageTableFlags::WRITABLE</code></a>
будет сброшен, то запись по виртуальному адресу <code>virt</code> будет запрещена,
несмотря на то что в
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html"><code>PageTableEntry</code></a>
таблицы L0, она разрешена.
Поэтому в промежуточных
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html"><code>PageTableEntry</code></a>
функция
<a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.translate"><code>Mapping::translate()</code></a>
должна будет включить флаги, заданные ей в аргументе <code>flags</code>.
И никакие флаги промежуточных
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html"><code>PageTableEntry</code></a>
она не должна случайно сбросить при этой операции.
Альтернативой было бы либо сразу включать все доступы в промежуточных
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html"><code>PageTableEntry</code></a>,
либо возвращать из
<a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.translate"><code>Mapping::translate()</code></a>
весь набор промежуточных
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html"><code>PageTableEntry</code></a>.
Также заметьте, что включать нужно только флаги доступа, они задаются константой
<a href="../../doc/ku/memory/mmu/constant.FULL_ACCESS.html"><code>ku::memory::mmu::FULL_ACCESS</code></a>.
То есть, включать нужно флаги которые есть в пересечении — <code>flags &amp; FULL_ACCESS</code>.</p>
<p>Выделение физического фрейма под отсутствующую промежуточную таблицу
<a href="../../doc/ku/memory/mmu/type.PageTable.html"><code>PageTable</code></a>
рекомендуется вынести во вспомогательную <a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.map_intermediate">функцию</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Mapping::map_intermediate(
    pte: &amp;mut PageTableEntry,
    flags: PageTableFlags,
    phys2virt: Page,
    frame_allocator: &amp;mut FrameAllocator,
) -&gt; Result&lt;()&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/mapping.rs"><code>kernel/src/memory/mapping.rs</code></a>.</p>
<p>Запись <code>()</code> в её результате означает пустой <a href="https://doc.rust-lang.ru/book/ch03-02-data-types.html#%D0%9A%D0%BE%D1%80%D1%82%D0%B5%D0%B6%D0%B8">кортеж</a>, — это аналог <code>void</code> языка C++.
То есть, функция либо возвращает <code>Ok(())</code>, если она отработала успешно, либо ошибку.
Функция <a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.map_intermediate"><code>Mapping::map_intermediate()</code></a> статическая, она не принимает <code>self</code>.
Чтобы её вызвать нужно явно указать <code>Self::</code> или <code>Mapping::</code>.</p>
<p>При реализации <code>Mapping::translate()</code> и <code>Mapping::map_intermediate()</code> вам также могут пригодиться:</p>
<ul>
<li>Поле <a href="../../doc/kernel/memory/mapping/struct.Mapping.html#structfield.page_directory"><code>Mapping::page_directory</code></a>, оно содержит адрес фрейма корневой таблицы L3, то есть фактически копию регистра <a href="https://wiki.osdev.org/CPU_Registers_x86#CR3"><code>CR3</code></a>.</li>
<li>Константа <a href="../../doc/ku/memory/mmu/constant.PAGE_TABLE_ROOT_LEVEL.html"><code>ku::memory::mmu::PAGE_TABLE_ROOT_LEVEL</code></a> — та самая 3 из обозначения L3 для корневой таблицы страниц — третий уровень считая с нуля.</li>
<li>Константа <a href="../../doc/ku/memory/mmu/constant.PAGE_TABLE_LEAF_LEVEL.html"><code>ku::memory::mmu::PAGE_TABLE_LEAF_LEVEL</code></a> — та самая 0 из обозначения L0 для листьевой таблицы страниц.</li>
<li>Конструкция <code>unsafe { virt_addr.try_into_mut::&lt;PageTable&gt;()? }</code>, которая превращает <a href="../../doc/ku/memory/addr/type.Virt.html"><code>Virt</code></a> в <code>&amp;mut PageTable</code>.</li>
<li>Метод <a href="https://doc.rust-lang.org/nightly/core/primitive.slice.html#method.fill"><code>fill()</code></a> срезов.</li>
<li>Цикл, чтобы обойти уровни таблицы. Для уменьшения потенциальных возможностей совершить ошибку, можно было бы сделать таблицы страниц разных уровней не совместимыми в системе типов, <a href="https://os.phil-opp.com/page-tables/#some-clever-solution">как здесь</a>. Тогда компилятор не дал бы их перепутать в коде. Но такой подход, к сожалению, не даст написать обычный цикл по уровням, только рекурсию на обобщённых функциях или копипасту. Поэтому в Nikka выбор сделан в пользу одного и того же типа для узлов всех уровней.</li>
<li>Итерирование в обратном порядке: <code>for i in (5..10).rev()</code>, или же <code>for i in (5..=10).rev()</code> если <code>10</code> должно быть включительно.</li>
<li>Сохранение в самом начале функции <a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.translate"><code>Mapping::translate()</code></a> значения <code>self.phys2virt</code> в отдельную переменную и использование уже новой переменной, если столкнётесь с излишней консервативностью borrow checker’а, подобного вида:</li>
</ul>
<pre><code class="language-console">error[E0503]: cannot use `self.phys2virt` because it was mutably borrowed
  --&gt; src/memory/mapping.rs:58:65
   |
55 |             let ... = self...;
   |                       ---- borrow of `*self` occurs here
...
58 |                 Self::map_intermediate(..., self.phys2virt, frame_allocator.as_mut().ok_or(NoPage)?)?;
   |                                             ^^^^^^^^^^^^^^ use of borrowed `*self`
...
61 |             if ... {
   |                --- borrow later used here
</code></pre>
<p>Теперь должен проходить тест</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 2-mm-3-translate)
...
2_mm_3_mapping::translate-----------------------------------
18:27:12 0 D pte = PageTableEntry(2613347)
18:27:12 0 D read_ptr = 0xfffff0000027e420; write_ptr = 0x10000201420
18:27:12 0 D write_value = 0; read_value = 0; variable = 0
18:27:12 0 D write_value = 1; read_value = 1; variable = 1
18:27:12 0 D write_value = 2; read_value = 2; variable = 2
18:27:12 0 D write_value = 3; read_value = 3; variable = 3
18:27:12 0 D write_value = 4; read_value = 4; variable = 4
2_mm_3_mapping::translate-------------------------- [passed]

2_mm_3_mapping::map_intermediate----------------------------
18:27:12 0 D page = Page(34359738366 @ 0v7FFFFFFFE000)
18:27:12 0 D pte = PageTableEntry(0)
2_mm_3_mapping::map_intermediate------------------- [passed]
18:27:12 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<p>А вот для проверки копирования и удаления виртуальных отображений
нам понадобится основной аллокатор физических фреймов.
Поэтому тесты для них придётся отложить.</p>
<h4 id="Создание-полной-копии-виртуального-отображения"><a class="header" href="#Создание-полной-копии-виртуального-отображения">Создание полной копии виртуального отображения</a></h4>
<p>В будущем, при создании нового процесса, нам понадобится скопировать существующий
<a href="../../doc/kernel/memory/mapping/struct.Mapping.html"><code>Mapping</code></a>
в новый.
Это делает метод
<a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.duplicate"><code>Mapping::duplicate()</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn duplicate(&amp;self) -&gt; Result&lt;Self&gt; {
    let mut result = Self::new(Frame::zero(), self.phys2virt);
    result.page_directory = Self::duplicate_page_table(&amp;mut result, self, self.page_directory, PAGE_TABLE_ROOT_LEVEL)?;
    Ok(result)
}
<span class="boring">}
</span></code></pre></pre>
<p>Основную работу он перекладывает на рекурсивный метод
<a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.duplicate_page_table"><code>Mapping::duplicate_page_table()</code></a>,
запуская корневой вызов рекурсии.</p>
<p>Реализуйте <a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.duplicate_page_table">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Mapping::duplicate_page_table(
    &amp;self,
    dst: &amp;mut Mapping,
    src_frame: Frame,
    level: u32,
) -&gt; Result&lt;Frame&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/mapping.rs"><code>kernel/src/memory/mapping.rs</code></a>
сейчас, пока помните как устроено страничное отображение.
Он принимает на вход:</p>
<ul>
<li>Новое отображение <code>dst</code>, которое мы создаём как копию исходного.</li>
<li>Исходное отображение <code>self</code>.</li>
<li>Исходный узел <code>PageTable</code> таблицы страниц в виде содержащего его фрейма <code>src_frame</code>.</li>
<li>Уровень этого узла <code>level</code> от <a href="../../doc/ku/memory/mmu/constant.PAGE_TABLE_ROOT_LEVEL.html"><code>PAGE_TABLE_ROOT_LEVEL = 3</code></a>
до <a href="../../doc/ku/memory/mmu/constant.PAGE_TABLE_LEAF_LEVEL.html"><code>PAGE_TABLE_LEAF_LEVEL = 0</code></a>.</li>
</ul>
<p>И должен создать копию заданного <code>src_frame</code> узла.
Возвращает он либо эту копию, либо возникшую в процессе работы ошибку.
Этот метод копирует только страничное отображение, то есть все <code>PageTable</code> уровней L3–L0,
но не пользовательские фреймы, на которые указывает это отображение.
То есть, должно получиться отображение,
которое переводит те же виртуальные адреса в те же физические адреса.
Разделяя таким образом пользовательскую часть физической память,
но дублируя физическую память под само страничное отображение (<code>PageTable</code> уровней L3–L0).
Если бы <code>PageTable</code> разделяли ту же физическую память, то уже после того как копирование отработало,
модификации исходного <code>self</code> приводили бы к модификации <code>dst</code> и наоборот.
А это не то что нам нужно.
Это означает, что</p>
<ul>
<li><code>PageTable</code> уровней L3–L1 включительно нужно пересоздать, заполняя их <code>PageTableEntry</code> результатами рекурсивных вызовов <code>Mapping::duplicate_page_table()</code>.</li>
<li>А вот <code>PageTable</code> уровня L0 нужно просто скопировать как есть, их записи <code>PageTableEntry</code> должны вести в те же физические фреймы, что и в исходном отображении <code>self</code>. Но только если соответствующая запись ведёт на страницу, принадлежащую ядру. Ссылки уровня L0 на страницы, принадлежащие пользователю — <code>PageTableFlags::USER_ACCESSIBLE</code>, — копировать не нужно.</li>
<li>На этот раз <code>PageTableFlags::HUGE_PAGE</code> нужно корректно обработать. Это означает, что рекурсивно спускаться в записи <code>PageTableEntry</code> для которых этот флаг включён не нужно. С этими записями нужно поступить как с записями на уровне L0, — скопировать в точности из <code>self</code>.</li>
<li>Не используемые записи в новых <a href="../../doc/ku/memory/mmu/type.PageTable.html"><code>PageTable</code></a> нужно почистить, как и в <a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.map_intermediate"><code>Mapping::map_intermediate()</code></a>.</li>
</ul>
<p>Для физических фреймов, на которые указывают скопированные записи листьевого уровня L0, нужно вызвать
<a href="../../doc/kernel/memory/enum.FrameAllocator.html#method.reference"><code>FrameAllocator::reference()</code></a>.
Этот метод увеличивает число ссылок на физический фрейм.
И позволяет понять, что физический фрейм нельзя считать свободным пока оба отображения <code>self</code> и <code>dst</code> существуют.
А ведь именно указанные фреймы мы разделяем, используя сразу в обоих отображениях.
Для выделения новых физических фреймов используйте
<a href="../../doc/kernel/memory/enum.FrameAllocator.html#method.allocate"><code>FrameAllocator::allocate()</code></a>.
В обоих случаях обращайтесь к глобальному
<a href="../../doc/kernel/memory/struct.FRAME_ALLOCATOR.html"><code>FRAME_ALLOCATOR</code></a>.</p>
<p>Также вам могут пригодиться методы</p>
<ul>
<li><a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.page_table_ref"><code>unsafe fn Mapping::page_table_ref(&amp;self, frame: Frame) -&gt; &amp;PageTable</code></a> и</li>
<li><a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.page_table_mut"><code>unsafe fn Mapping::page_table_mut(&amp;mut self, frame: Frame) -&gt; &amp;mut PageTable</code></a>.</li>
</ul>
<p>Они позволяют интерпретировать заданный физический фрейм <code>frame</code> как узел <code>PageTable</code> таблицы страниц.
И различаются только возможностью менять эту таблицу.</p>
<p>Учтите, что в рекурсивный вызов передаётся изменяемая ссылка <code>dst: &amp;mut Mapping</code>.
А значит, в момент рекурсивного вызова не должно быть живых локальных переменных ссылающихся на <code>dst</code> прямо или косвенно.
Rust не даст скомпилировать такой код из-за нарушения <a href="https://doc.rust-lang.ru/book/ch04-00-understanding-ownership.html">владения</a> <code>dst</code>, —
только одна из функций, вызывающая или вызываемая, может эксклюзивно заимствовать <code>dst</code> в каждый момент времени.
А <a href="https://doc.rust-lang.ru/book/ch04-02-references-and-borrowing.html#%D0%98%D0%B7%D0%BC%D0%B5%D0%BD%D1%8F%D0%B5%D0%BC%D1%8B%D0%B5-%D1%81%D1%81%D1%8B%D0%BB%D0%BE%D1%87%D0%BD%D1%8B%D0%B5-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5">изменяемая ссылка и означает эксклюзивность заимствования</a>.</p>
<h4 id="Удаление-виртуального-отображения"><a class="header" href="#Удаление-виртуального-отображения">Удаление виртуального отображения</a></h4>
<p>Раз есть способ создать новое отображение, которое расходует физические фреймы, значит должен быть и способ удалить его, вернув эти фреймы в систему.
Это делает реализация типажа <a href="https://doc.rust-lang.org/nightly/core/ops/trait.Drop.html"><code>core::ops::Drop</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Drop for Mapping {
    fn drop(&amp;mut self) {
        assert!(Self::current_page_directory() != self.page_directory);

        if self.is_valid() {
            self.drop_page_table(self.page_directory, PAGE_TABLE_ROOT_LEVEL);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>В строчке <code>assert!(Self::current_page_directory() != self.page_directory)</code> проверяется, что мы не пытаемся удалить отображение, которое в данный момент загружено в регистр
<a href="https://wiki.osdev.org/CPU_Registers_x86#CR3"><code>CR3</code></a>
и является активным виртуальным пространством.
Далее вся работа перекладывается на рекурсивный метод
<a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.drop_page_table"><code>Mapping::drop_page_table()</code></a>.</p>
<p>Реализуйте <a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.drop_page_table">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Mapping::drop_page_table(
    &amp;mut self,
    src_frame: Frame,
    level: u32,
)
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/mapping.rs"><code>kernel/src/memory/mapping.rs</code></a>.</p>
<p>Для освобождения фреймов используйте
<a href="../../doc/kernel/memory/enum.FrameAllocator.html#method.deallocate"><code>FrameAllocator::deallocate()</code></a>,
он уменьшит количество ссылок на фрейм и освободит его, когда ссылок не останется.
Перед освобождением фрейма, занятого под одну из <code>PageTable</code>, то есть из записей <code>PageTableEntry</code> уровней L3–L1,
нужно спуститься в этот фрейм, рекурсивно вызвав <code>Mapping::drop_page_table()</code>.
Пользовательские фреймы нужно освобождать так же как и фреймы, занятые под <code>PageTable</code>.
А вот с записями у которых включён флаг <code>PageTableFlags::HUGE_PAGE</code> делать ничего не нужно — ни освобождать, ни спускаться в них рекурсивно.</p>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-5"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-5">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/memory/mapping.rs |   88 +++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 84 insertions(+), 4 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Высокоуровневый-интерфейс-управления-адресным-пространством"><a class="header" href="#Высокоуровневый-интерфейс-управления-адресным-пространством">Высокоуровневый интерфейс управления адресным пространством</a></h2>
<p>Всё управление адресным пространством инкапсулировано в структуре
<a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html"><code>kernel::memory::address_space::AddressSpace</code></a>.
Её поле
<a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#structfield.mapping"><code>AddressSpace::mapping</code></a>
служит для модификации отображения страниц и <a href="../../lab/book/2-mm-6-address-space-2-translate.html">реализовано вами ранее</a>.
А поле
<a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#structfield.page_allocator"><code>AddressSpace::page_allocator</code></a> —
для выделения виртуальных страниц внутри этого адресного пространства.
И тоже <a href="../../lab/book/2-mm-6-address-space-1-allocation.html">уже реализовано</a>.</p>
<h3 id="Задача-4--высокоуровневый-интерфейс-управления-адресным-пространством"><a class="header" href="#Задача-4--высокоуровневый-интерфейс-управления-адресным-пространством">Задача 4 — высокоуровневый интерфейс управления адресным пространством</a></h3>
<h4 id="Отображение-виртуальной-страницы-на-физический-фрейм"><a class="header" href="#Отображение-виртуальной-страницы-на-физический-фрейм">Отображение виртуальной страницы на физический фрейм</a></h4>
<p>Реализуйте <a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.map_page_to_frame">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn AddressSpace::map_page_to_frame(
    &amp;mut self,
    page: Page,
    frame: Frame,
    flags: PageTableFlags,
) -&gt; Result&lt;()&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/address_space.rs"><code>kernel/src/memory/address_space.rs</code></a>.
Он должен отобразить заданную виртуальную страницу <code>page</code> на заданный физический фрейм <code>frame</code> с указанными флагами доступа <code>flags</code>.
Используйте
<a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.translate"><code>Mapping::translate()</code></a>
и
<a href="../../doc/kernel/memory/struct.FRAME_ALLOCATOR.html"><code>FRAME_ALLOCATOR</code></a>.
Вам может пригодиться метод
<a href="../../doc/kernel/memory/mmu/struct.PageTableEntry.html#method.set_frame"><code>PageTableEntry::set_frame()</code></a>.
Увеличивать количество ссылок на <code>frame</code> не нужно, это задача вызывающей функции.
Дело в том, что нам иногда захочется использовать
<a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.map_page_to_frame"><code>AddressSpace::map_page_to_frame()</code></a>
для отображения зарезервированных физических фреймов, про которые
<a href="../../doc/kernel/memory/enum.FrameAllocator.html"><code>FrameAllocator</code></a>
ничего не знает и не отслеживает количество ссылок на них.
Например, это делает метод
<a href="../../doc/kernel/smp/local_apic/struct.LocalApic.html#method.map"><code>kernel::smp::local_apic::LocalApic::map()</code></a>,
инициализирующий работу с
<a href="https://wiki.osdev.org/APIC">контроллером прерываний APIC</a>
методом ввода–вывода через память
(<a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">Memory-mapped I/O</a>).</p>
<p>Если <code>page</code> уже была отображена, то старое отображение удаляется,
если только при этом не произойдёт замена прав доступа к странице с
“только для ядра” на “доступно в пользовательском пространстве” —
<a href="../../doc/ku/memory/mmu/struct.PageTableFlags.html#associatedconstant.USER_ACCESSIBLE"><code>PageTableFlags::USER_ACCESSIBLE</code></a>.
В случае попытки такой замены отображение не меняется, а возвращается ошибка
<a href="../../doc/kernel/error/enum.Error.html#variant.PermissionDenied"><code>Error::PermissionDenied</code></a>.
Если же отображение <code>page</code> поменялось, старый физический фрейм освобождается,
если на него не осталось других ссылок.
Удалить старый маппинг можно с помощью метода
<a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.unmap_pte"><code>AddressSpace::unmap_pte()</code></a>.</p>
<p>Используя
<a href="../../doc/kernel/memory/enum.FrameAllocator.html#method.allocate"><code>FrameAllocator::allocate()</code></a>
из глобального
<a href="../../doc/kernel/memory/struct.FRAME_ALLOCATOR.html"><code>FRAME_ALLOCATOR</code></a>
и
<a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.map_page_to_frame"><code>AddressSpace::map_page_to_frame()</code></a>
реализуйте <a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.map_page">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn AddressSpace::map_page(
    &amp;mut self,
    page: Page,
    flags: PageTableFlags,
) -&gt; Result&lt;Frame&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/address_space.rs"><code>kernel/src/memory/address_space.rs</code></a>.
Он отличается от
<a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.map_page_to_frame"><code>AddressSpace::map_page_to_frame()</code></a>
только тем, что не принимает <code>frame</code>, а выделяет его сам.</p>
<h4 id="Удаление-отображения-заданной-страницы"><a class="header" href="#Удаление-отображения-заданной-страницы">Удаление отображения заданной страницы</a></h4>
<p>Реализуйте <a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.unmap_page">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn AddressSpace::unmap_page(
    &amp;mut self,
    page: Page,
) -&gt; Result&lt;()&gt;
<span class="boring">}
</span></code></pre></pre>
<p>и его вспомогательный <a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.unmap_pte">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn AddressSpace::unmap_pte(
    page: Page,
    pte: &amp;mut PageTableEntry,
) -&gt; Result&lt;()&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/address_space.rs"><code>kernel/src/memory/address_space.rs</code></a>.
Воспользуйтесь
<a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.translate"><code>Mapping::translate()</code></a>,
теперь в качестве <code>flags</code> ему можно передать пустой набор флагов
<a href="../../doc/kernel/memory/mmu/struct.PageTableFlags.html#method.empty"><code>PageTableFlags::empty()</code></a>.</p>
<p><strong>Важно</strong> сбросить запись в
<a href="https://ru.wikipedia.org/wiki/%D0%91%D1%83%D1%84%D0%B5%D1%80_%D0%B0%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B9_%D1%82%D1%80%D0%B0%D0%BD%D1%81%D0%BB%D1%8F%D1%86%D0%B8%D0%B8">буфере ассоциативной трансляции</a>
(<a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer">Translation lookaside buffer</a>,
<a href="https://wiki.osdev.org/TLB">TLB</a>)
касающуюся <code>page</code>.
Иначе процессор может использовать старую закешерованную в TLB запись, когда обратится по адресу внутри <code>page</code> в следующий раз.
А это может быть как уже совершенно другой физический фрейм, так и намеренно не отображённая на физическую память страница.
Выглядеть с вашей точки зрения это будет так: вы обращаетесь по некоторому адресу, а там находится совсем не то что вы ожидаете.
Даже отладчик будет показывать вам то же самое, что вы ожидаете.
А вот процессор будет читать и писать совсем в другую физическую память.
Это приведёт к трудно отлаживаемым
<a href="https://ru.wikipedia.org/wiki/%D0%93%D0%B5%D0%B9%D0%B7%D0%B5%D0%BD%D0%B1%D0%B0%D0%B3">гейзенбагам</a>.
Для сброса нужной записи TLB поможет функция
<a href="../../doc/kernel/memory/mmu/fn.flush.html">kernel::memory::mmu::flush()</a>.</p>
<p>Также вам пригодятся</p>
<ul>
<li><a href="../../doc/kernel/memory/enum.FrameAllocator.html#method.deallocate"><code>FrameAllocator::deallocate()</code></a> и</li>
<li><a href="../../doc/kernel/memory/mmu/struct.PageTableEntry.html#method.clear"><code>PageTableEntry::clear()</code></a>.</li>
</ul>
<h3 id="Изучите-как-устроены-отображения-целых-блоков"><a class="header" href="#Изучите-как-устроены-отображения-целых-блоков">Изучите как устроены отображения целых блоков</a></h3>
<p>Посмотрите на методы</p>
<ul>
<li><a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.map_block"><code>unsafe fn AddressSpace::map_block(&amp;mut self, pages: Block&lt;Page&gt;, flags: PageTableFlags) -&gt; Result&lt;()&gt;</code></a> и</li>
<li><a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.unmap_block"><code>unsafe fn AddressSpace::unmap_block(&amp;mut self, pages: Block&lt;Page&gt;) -&gt; Result&lt;()&gt;</code></a>.</li>
</ul>
<p>Их код и назначение должны быть уже понятны.</p>
<h3 id="Изучите-как-устроены-отображения-срезов"><a class="header" href="#Изучите-как-устроены-отображения-срезов">Изучите как устроены отображения срезов</a></h3>
<p>С помощью реализованных вами функций <a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.map_slice_uninit">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn AddressSpace::map_slice_uninit&lt;T&gt;(
    &amp;mut self,
    len: usize,
    flags: PageTableFlags,
) -&gt; Result&lt;&amp;'static mut [MaybeUninit&lt;T&gt;]&gt;
<span class="boring">}
</span></code></pre></pre>
<p>выделяет срез неинициализированной памяти
<a href="https://doc.rust-lang.org/nightly/core/mem/union.MaybeUninit.html"><code>core::mem::MaybeUninit</code></a>,
достаточный для <code>len</code> элементов типа <code>T</code>.
Так как он пользуется выделением виртуальных страниц и физических фреймов,
каждый вызов расходует целое число фреймов.
То есть, выделение через него срезов маленького размера в байтах неэффективно.
В результате вернётся срез с большим, чем было запрошено, количеством элементов —
сколько поместилось в аллоцированном наборе страниц.</p>
<p><a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.map_slice">Метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn AddressSpace::map_slice&lt;T, F: Fn() -&gt; T&gt;(
    &amp;mut self,
    len: usize,
    flags: PageTableFlags,
    default: F,
) -&gt; Result&lt;&amp;'static mut [T]&gt;
<span class="boring">}
</span></code></pre></pre>
<p>дополнительно параметризован
<a href="https://doc.rust-lang.ru/book/ch13-01-closures.html">замыканием</a>
типажа
<a href="https://doc.rust-lang.org/nightly/core/ops/trait.Fn.html"><code>core::ops::Fn</code></a>.
Возвращаемый им срез уже инициализирован значениями, которые возвращает замыкание <code>default</code>.</p>
<p><a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.map_slice_zeroed">Метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn AddressSpace::map_slice_zeroed&lt;T&gt;(
    &amp;mut self,
    len: usize,
    flags: PageTableFlags,
) -&gt; Result&lt;&amp;'static mut [T]&gt;
<span class="boring">}
</span></code></pre></pre>
<p>не принимает значение для инициализации, а инициализирует память нулями.
<code>unsafe</code> означает, что вызывающая функция должна гарантировать, что <a href="https://doc.rust-lang.org/nightly/core/mem/union.MaybeUninit.html#example-2">нулевые байты являются корректным значением</a> для типа <code>T</code>.</p>
<p><a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.unmap_slice">Метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn AddressSpace::unmap_slice&lt;T&gt;(
    &amp;mut self,
    slice: &amp;mut [T],
) -&gt; Result&lt;()&gt;
<span class="boring">}
</span></code></pre></pre>
<p>удаляет отображение страниц под заданным срезом.
Он проверяет, что срез действительно занимает свои страницы целиком.
<code>unsafe</code> означает, что вызывающая функция должна гарантировать, что <code>slice</code> больше не будет использоваться.</p>
<h3 id="Проверьте-себя-2"><a class="header" href="#Проверьте-себя-2">Проверьте себя</a></h3>
<p>Запустите тест:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 2-mm-4-map)
...
2_mm_4_interface::map_slice---------------------------------
19:10:06 0 D slice = [0v7FFFFEFFF000, 0v7FFFFFFFF000), size 16.000 MiB, Virt[~128.000 TiB, ~128.000 TiB)
2_mm_4_interface::map_slice------------------------ [passed]
19:10:09.133 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<p>Как и в случае копирования и удаления виртуальных отображений для проверки метода
<a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.unmap_slice"><code>AddressSpace::unmap_slice()</code></a>
нам понадобится основной аллокатор физических фреймов.
Поэтому тест для него придётся отложить.</p>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-6"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-6">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/memory/address_space.rs |   20 +++++++++++++++++---
 1 file changed, 17 insertions(+), 3 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Основной-аллокатор-физических-фреймов"><a class="header" href="#Основной-аллокатор-физических-фреймов">Основной аллокатор физических фреймов</a></h2>
<p>Приступим к реализации основного аллокатора физических фреймов
<a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html"><code>kernel::memory::main_frame_allocator::MainFrameAllocator</code></a>.</p>
<p>Он построен на описателе физического фрейма
<a href="../../doc/kernel/memory/main_frame_allocator/enum.FrameInfo.html"><code>kernel::memory::main_frame_allocator::FrameInfo</code></a>.
Это <a href="https://doc.rust-lang.ru/book/ch06-01-defining-an-enum.html">перечисление</a> с вариантами:</p>
<ul>
<li><a href="../../doc/kernel/memory/main_frame_allocator/enum.FrameInfo.html#variant.Absent"><code>FrameInfo::Absent</code></a> — этого физического фрейма нет в компьютере или же он зарезервирован, например <a href="https://en.wikipedia.org/wiki/BIOS">BIOS</a> или загрузчиком <a href="../../doc/bootloader/index.html">bootloader</a>.</li>
<li><a href="../../doc/kernel/memory/main_frame_allocator/enum.FrameInfo.html#variant.Free"><code>FrameInfo::Free</code></a> — этот физический фрейм свободен. Содержит поле <a href="../../doc/kernel/memory/main_frame_allocator/enum.FrameInfo.html#variant.Free.field.next_free"><code>FrameInfo::Free::next_free</code></a> с номером следующего свободного фрейма, либо <code>None</code> если это последний элемент списка. То есть, описатели свободных фреймов провязаны в односвязный <a href="https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D1%80%D1%83%D0%B7%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA">интрузивный список</a> с номерами вместо указателей.</li>
<li><a href="../../doc/kernel/memory/main_frame_allocator/enum.FrameInfo.html#variant.Used"><code>FrameInfo::Used</code></a> — этот физический фрейм занят. Содержит поле <a href="../../doc/kernel/memory/main_frame_allocator/enum.FrameInfo.html#variant.Used.field.reference_count"><code>FrameInfo::Used::reference_count</code></a> с количеством ссылок на описываемый фрейм.</li>
</ul>
<p>В
<a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html"><code>MainFrameAllocator</code></a>
все описатели физических фреймов собраны в поле
<a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html#structfield.frame_info"><code>MainFrameAllocator::frame_info</code></a>.
Это срез <code>&amp;[FrameInfo]</code> достаточного размера, чтобы хранить описатели всех физических фреймов, доступных в компьютере.
Как вы можете догадаться, этот срез выделяется с помощью
<a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.map_slice"><code>AddressSpace::map_slice()</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let frame_count = total_frames(memory_map);
let frame_info = BASE_ADDRESS_SPACE
    .lock()
    .map_slice(frame_count, KERNEL_RW, || FrameInfo::Absent)
    .expect(&quot;failed to allocate memory for MainFrameAllocator metadata&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>А количество необходимых записей <code>frame_count</code> вычисляется с помощью знакомой вам
<a href="../../doc/bootloader/bootinfo/struct.MemoryMap.html"><code>bootloader::bootinfo::MemoryMap</code></a>.
Эта инициализация происходит в
<a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html#method.new"><code>MainFrameAllocator::new()</code></a>.</p>
<p>Поле
<a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html#structfield.free_frame"><code>MainFrameAllocator::free_frame</code></a>
содержит голову списка свободных фреймов.
А поле
<a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html#structfield.free_count"><code>MainFrameAllocator::free_count</code></a> —
их количество.</p>
<h3 id="Задача-5--mainframeallocator"><a class="header" href="#Задача-5--mainframeallocator">Задача 5 — <a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html"><code>MainFrameAllocator</code></a></a></h3>
<h4 id="Инициализация-описателей-фреймов"><a class="header" href="#Инициализация-описателей-фреймов">Инициализация описателей фреймов</a></h4>
<p>Реализуйте <a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html#method.init_frame_info">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn MainFrameAllocator::init_frame_info(
    &amp;mut self,
    memory_map: &amp;MemoryMap,
    boot_frame_allocator: &amp;BootFrameAllocator,
)
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/main_frame_allocator.rs"><code>kernel/src/memory/main_frame_allocator.rs</code></a>.
Пройдите по <code>memory_map</code> с картой памяти <a href="../../doc/bootloader/bootinfo/struct.MemoryMap.html"><code>MemoryMap</code></a>,
аналогично тому как вы делали в
<a href="../../lab/book/2-mm-5-boot-frame-allocator.html#%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-1--%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-bootframeallocatornew">задаче 1</a>.
Обратите внимание, что на вход метод принимает неизменяемый <code>boot_frame_allocator</code>.
Так как он неизменяемый, выделить с его помощью память не получится.
Он нужен для того, чтобы проверить, принадлежит ли данный фрейм аллокатору <code>boot_frame_allocator</code> или нет с помощью метода
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html#method.is_managed"><code>BootFrameAllocator::is_managed()</code></a>.</p>
<ul>
<li>Если тип региона памяти не является <a href="../../doc/bootloader/bootinfo/enum.MemoryRegionType.html#variant.Usable"><code>MemoryRegionType::Usable</code></a>, пометьте фрейм как <a href="../../doc/kernel/memory/main_frame_allocator/enum.FrameInfo.html#variant.Absent"><code>FrameInfo::Absent</code></a>. В этом случае можно просто ничего не делать. Как вы видели, <a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html#method.new"><code>MainFrameAllocator::new()</code></a> при аллокации среза <a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html#structfield.frame_info"><code>MainFrameAllocator::frame_info</code></a> инициализирует его значением <a href="../../doc/kernel/memory/main_frame_allocator/enum.FrameInfo.html#variant.Absent"><code>FrameInfo::Absent</code></a>.</li>
<li>Если фрейм принадлежит <code>boot_frame_allocator</code>, пометьте его как занятый — <a href="../../doc/kernel/memory/main_frame_allocator/enum.FrameInfo.html#variant.Used"><code>FrameInfo::Used</code></a>, — со счётчиком использований равным 1.</li>
<li>В остальных случаях, пометьте фреймы из <a href="../../doc/bootloader/bootinfo/enum.MemoryRegionType.html#variant.Usable"><code>Usable</code></a> регионов как <a href="../../doc/kernel/memory/main_frame_allocator/enum.FrameInfo.html#variant.Free"><code>FrameInfo::Free</code></a> и провяжите их в односвязный список.</li>
</ul>
<p>Количество найденных свободных фреймов сохраните в
<a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html#structfield.free_count"><code>MainFrameAllocator::free_count</code></a>.</p>
<p>Вам могут пригодиться функции</p>
<ul>
<li><a href="../../doc/ku/memory/frage/struct.Frage.html#method.from_index"><code>ku::memory::frage::Frame::from_index()</code></a>.</li>
<li><a href="../../doc/ku/memory/size/fn.into_usize.html"><code>ku::memory::size::into_usize()</code></a>.</li>
<li><a href="https://doc.rust-lang.org/nightly/core/mem/fn.replace.html"><code>core::mem::replace()</code></a>.</li>
</ul>
<h4 id="Аллокация-фрейма"><a class="header" href="#Аллокация-фрейма">Аллокация фрейма</a></h4>
<p>Реализуйте <a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html#method.allocate">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn MainFrameAllocator::allocate(&amp;mut self) -&gt; Result&lt;Frame&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/main_frame_allocator.rs"><code>kernel/src/memory/main_frame_allocator.rs</code></a>.
Он аллоцирует и возвращает свободный фрейм.
Как обычно, верните ошибку
<a href="../../doc/kernel/error/enum.Error.html#variant.NoFrame"><code>Error::NoFrame</code></a>,
если свободных физических фреймов не осталось.
Чтобы долго не искать, используйте фрейм из головы списка свободных —
<a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html#structfield.free_frame"><code>MainFrameAllocator::free_frame</code></a>.
Также обновите количество оставшихся свободных фреймов <a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html#structfield.free_count"><code>MainFrameAllocator::free_count</code></a>.</p>
<p>На всякий случай можно перепроверить, что
<a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html#structfield.free_frame"><code>MainFrameAllocator::free_frame</code></a>
соответствует записи в
<a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html#structfield.frame_info"><code>MainFrameAllocator::frame_info</code></a>,
являющейся
<a href="../../doc/kernel/memory/main_frame_allocator/enum.FrameInfo.html#variant.Free"><code>FrameInfo::Free</code></a>.
И запаниковать, если это не так:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>panic!(&quot;your {} message {:?}&quot;, ...);
<span class="boring">}
</span></code></pre></pre>
<h4 id="Освобождение-фрейма"><a class="header" href="#Освобождение-фрейма">Освобождение фрейма</a></h4>
<p>Реализуйте <a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html#method.deallocate">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn MainFrameAllocator::deallocate(
    &amp;mut self,
    frame: Frame,
)
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/main_frame_allocator.rs"><code>kernel/src/memory/main_frame_allocator.rs</code></a>.
Он уменьшает количество ссылок на данный <code>frame</code> и помечает его как
<a href="../../doc/kernel/memory/main_frame_allocator/enum.FrameInfo.html#variant.Free"><code>FrameInfo::Free</code></a>,
если ссылок не осталось.
<code>unsafe</code> означает, что вызывающая функция должна гарантировать, что если ссылок на <code>frame</code> не осталось, то он больше не будет использоваться и, в частности, не участвует ни в одном
<a href="../../doc/kernel/memory/mapping/struct.Mapping.html"><code>Mapping</code></a>.
Если <code>frame</code> уже является
<a href="../../doc/kernel/memory/main_frame_allocator/enum.FrameInfo.html#variant.Free"><code>FrameInfo::Free</code></a>,
стоит запаниковать.</p>
<p>Однако освобождение фрейма, который помечен как
<a href="../../doc/kernel/memory/main_frame_allocator/enum.FrameInfo.html#variant.Absent"><code>FrameInfo::Absent</code></a> —
корректная ситуация, паниковать не нужно.
Дело в том, что зарезервированные фреймы, которые мы так помечаем в
<a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html#method.init_frame_info"><code>MainFrameAllocator::init_frame_info()</code></a>
могут быть отображены в память загрузчиком
<a href="../../doc/bootloader/index.html">bootloader</a>.
И при копировании и освобождении
<a href="../../doc/kernel/memory/mapping/struct.Mapping.html"><code>Mapping</code></a>
мы можем попытаться поменять количество ссылок на них.
В этом случае ничего делать не нужно, фрейм должен остаться
<a href="../../doc/kernel/memory/main_frame_allocator/enum.FrameInfo.html#variant.Absent"><code>FrameInfo::Absent</code></a>
и не должен попасть в список свободных.
Так как может быть много разных причин почему он не был
<a href="../../doc/bootloader/bootinfo/enum.MemoryRegionType.html#variant.Usable"><code>MemoryRegionType::Usable</code></a>.
Например, он может соответствовать микросхеме
<a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%BD%D0%BE%D0%B5_%D0%B7%D0%B0%D0%BF%D0%BE%D0%BC%D0%B8%D0%BD%D0%B0%D1%8E%D1%89%D0%B5%D0%B5_%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%BE">постоянного запоминающего устройства</a>,
которая позволяет только читать данные, и не может быть использован ядром для произвольных данных.</p>
<p>То же самое относится к фреймам, номера которых выходят за границы среза
<a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html#structfield.frame_info"><code>MainFrameAllocator::frame_info</code></a>, —
могут иметься зарезервированные участки памяти, которые находятся по очень большим адресам.
Один из таких участков — область ввода–вывода через память (<a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">Memory-mapped I/O</a>) для управления <a href="https://wiki.osdev.org/APIC">контроллером прерываний APIC</a>:</p>
<pre><code class="language-console">15:08:28 0 I acpi_info = AcpiInfo { local_apic_address: Phys(0pFEE00000), bsp_id: 0, ap_ids: [1, 2, 3] }
15:08:28 0 I Local APIC init; cpu = 0; cpu_count = 4; local_apic_address = 0pFEE00000
</code></pre>
<p>Обратите внимание на физический адрес в районе 4 GiB — <code>local_apic_address = 0pFEE00000</code>.
Поэтому функция
<a href="../../doc/kernel/memory/main_frame_allocator/fn.total_frames.html"><code>kernel::memory::main_frame_allocator::total_frames()</code></a>
игнорирует не
<a href="../../doc/bootloader/bootinfo/enum.MemoryRegionType.html#variant.Usable"><code>Usable</code></a> регионы,
чтобы не нужно было выделять огромный срез
<a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html#structfield.frame_info"><code>MainFrameAllocator::frame_info</code></a>,
который может просто не поместится в память,
и будет содержать в основном
<a href="../../doc/kernel/memory/main_frame_allocator/enum.FrameInfo.html#variant.Absent"><code>Absent</code></a> записи.</p>
<h4 id="Увеличение-счётчика-использований-фрейма"><a class="header" href="#Увеличение-счётчика-использований-фрейма">Увеличение счётчика использований фрейма</a></h4>
<p>Реализуйте <a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html#method.reference">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn MainFrameAllocator::reference(
    &amp;mut self,
    frame: Frame,
)
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/main_frame_allocator.rs"><code>kernel/src/memory/main_frame_allocator.rs</code></a>.
Он наоборот, увеличивает количество ссылок на заданный <code>frame</code>.
Если <code>frame</code> является
<a href="../../doc/kernel/memory/main_frame_allocator/enum.FrameInfo.html#variant.Free"><code>FrameInfo::Free</code></a>,
стоит запаниковать.
Как и для
<a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html#method.deallocate"><code>MainFrameAllocator::deallocate()</code></a>,
если фрейм
<a href="../../doc/kernel/memory/main_frame_allocator/enum.FrameInfo.html#variant.Absent"><code>FrameInfo::Absent</code></a>
или выходит за границы среза
<a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html#structfield.frame_info"><code>MainFrameAllocator::frame_info</code></a> —
это допустимая ситуация, в которой ничего делать не нужно.</p>
<h4 id="Перенесение-свободных-фреймов-из-bootframeallocator-в-mainframeallocator"><a class="header" href="#Перенесение-свободных-фреймов-из-bootframeallocator-в-mainframeallocator">Перенесение свободных фреймов из <a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html"><code>BootFrameAllocator</code></a> в <a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html"><code>MainFrameAllocator</code></a></a></h4>
<p>Финальный штрих — реализация <a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html#method.move_free_frames">метода</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn MainFrameAllocator::move_free_frames(
    &amp;mut self,
    mut src: BootFrameAllocator,
)
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/main_frame_allocator.rs"><code>kernel/src/memory/main_frame_allocator.rs</code></a>.
Он переносит все фреймы, которые на данный момент принадлежат
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html"><code>BootFrameAllocator</code></a>
и являются свободными, под управление
<a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html"><code>MainFrameAllocator</code></a>.</p>
<p>Для этого аллоцируйте все фреймы, оставшиеся в
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html"><code>BootFrameAllocator</code></a>.
Это можно сделать за один вызов метода
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html#method.allocate_block"><code>BootFrameAllocator::allocate_block()</code></a>,
если передать в него весь оставшийся в
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html"><code>BootFrameAllocator</code></a>
свободный размер — <code>src.count() * Frame::SIZE</code>.
Затем деаллоцируйте эти фреймы в
<a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html"><code>MainFrameAllocator</code></a>
методом
<a href="../../doc/kernel/memory/main_frame_allocator/struct.MainFrameAllocator.html#method.deallocate"><code>MainFrameAllocator::deallocate()</code></a>.</p>
<p>Обратите внимание на сигнатуру <code>fn move_free_frames(..., src: BootFrameAllocator)</code>.
Она означает, что функция поглощает аргумент <code>src</code>, так как он передаётся по значению, а не по ссылке.
Вместе с тем фактом, что
<a href="../../doc/kernel/memory/boot_frame_allocator/struct.BootFrameAllocator.html"><code>BootFrameAllocator</code></a>
не является
<a href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html">core::marker::Copy</a>
типом,
это приводит к уничтожению <code>src</code> при выходе из <code>move_free_frames()</code>.
Так что Rust не даст случайно воспользоваться исходным <code>src</code>
после вызова <code>move_free_frames(src, ...)</code>.
В терминах C++ здесь работает семантика перемещения.</p>
<h3 id="Проверьте-себя-3"><a class="header" href="#Проверьте-себя-3">Проверьте себя</a></h3>
<p>Наконец можно проверить не только основной аллокатор фреймов,
но также копирование и удаление виртуальных отображений и метод
<a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.unmap_slice"><code>AddressSpace::unmap_slice()</code></a>.
Запустите тест:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 2-mm-5-main-frame-allocator)
...
2_mm_5_main_frame_allocator::sanity_check-------------------
19:31:13 0 D free_frames = 31452; min_free_frames = 28672; qemu_memory_frames = 32768
2_mm_5_main_frame_allocator::sanity_check---------- [passed]

2_mm_5_main_frame_allocator::basic_frame_allocator_functions
19:31:13 0 D frames = [Frame(32540 @ 0p7F1C000), Frame(32539 @ 0p7F1B000)]
19:31:13 0 D reallocate_last_freed_frame = Frame(32540 @ 0p7F1C000)
2_mm_5_main_frame_allocator::basic_frame_allocator_functions [passed]

2_mm_5_main_frame_allocator::allocated_frames_are_unique----
19:31:13 0 D free_frames = 31390
19:31:13 0 D free_frames = 0
19:31:15.579 0 D free_frames = 31390
2_mm_5_main_frame_allocator::allocated_frames_are_unique [passed]

2_mm_5_main_frame_allocator::shared_memory------------------
19:31:15.613 0 D frame = Frame(32479 @ 0p7EDF000)
19:31:15.617 0 D pages = [Page(34359738111 @ 0v7FFFFFEFF000), Page(34359738112 @ 0v7FFFFFF00000)]
19:31:15.627 0 D write_ptr = 0x7ffffff00000; read_ptr = 0x7fffffeff000
19:31:15.633 0 D write_value = 0; read_value = 0
19:31:15.637 0 D write_value = 1; read_value = 1
19:31:15.643 0 D write_value = 2; read_value = 2
2_mm_5_main_frame_allocator::shared_memory--------- [passed]

2_mm_5_main_frame_allocator::duplicate_and_drop_mapping-----
19:31:15.695 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
19:31:15.705 0 I duplicate; address_space = &quot;process&quot; @ 0p7EDF000
19:31:15.709 0 D ptes = [PageTableEntry(2613347), PageTableEntry(2613347)]
19:31:15.715 0 D pte_addresses = [Virt(0vFFFFF000005BB008), Virt(0vFFFFF00007EE7008)]
19:31:15.725 0 I drop; address_space = &quot;process&quot; @ 0p7EDF000
2_mm_5_main_frame_allocator::duplicate_and_drop_mapping [passed]
19:31:15.761 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-7"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-7">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/memory/main_frame_allocator.rs |  116 ++++++++++++++++++++++++++++--
 1 file changed, 111 insertions(+), 5 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Проверьте-себя-4"><a class="header" href="#Проверьте-себя-4">Проверьте себя</a></h2>
<p>После того как вы полностью реализуете работу с памятью, проверьте себя.
Запустите интеграционные тесты командой <code>cargo test --test 2-mm-*</code>
в директории <code>kernel</code> репозитория.
Вы должны увидеть что-то вроде</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 2-mm-*)
    Finished test [unoptimized + debuginfo] target(s) in 0.08s
     Running tests/2-mm-1-block.rs (/home/sergey/tmp/shad-os/target/kernel/debug/deps/2_mm_1_block-f2c7db20fb3d2656)
Building bootloader
   Compiling bootloader v0.9.22 (/home/sergey/.cargo/registry/src/github.com-1ecc6299db9ec823/bootloader-0.9.22)
    Finished release [optimized + debuginfo] target(s) in 0.95s
Running: `qemu-system-x86_64 -drive format=raw,file=/home/sergey/tmp/shad-os/target/kernel/debug/deps/bootimage-2_mm_1_block-f2c7db20fb3d2656.bin -no-reboot -m size=128M -smp cpus=4 -device isa-debug-exit,iobase=0xF4,iosize=0x04 -serial stdio -display none`
19:38:12 0 I RTC init; acknowledged_settings = USE_24_HOUR_FORMAT | UPDATE_ENDED_INTERRUPT
19:38:12 0 I time init
19:38:12 0 I Nikka booted; now = 2022-10-09 19:38:12 UTC; tsc = Tsc(2295235227)
19:38:12 0 I GDT init
19:38:12 0 I interrupts init
running 1 tests

2_mm_1_block::block-----------------------------------------
19:38:12 0 D start = 0; end = 0; block = [0v0, 0v0), size 0 B
19:38:12 0 D start = 0; end = 33; block = [0v0, 0v21), size 33 B
19:38:12 0 D start = 0; end = 66; block = [0v0, 0v42), size 66 B
19:38:12 0 D start = 0; end = 99; block = [0v0, 0v63), size 99 B
19:38:12 0 D start = 25; end = 33; block = [0v19, 0v21), size 8 B
19:38:12 0 D start = 25; end = 66; block = [0v19, 0v42), size 41 B
19:38:12 0 D start = 25; end = 99; block = [0v19, 0v63), size 74 B
19:38:13 0 D start = 50; end = 66; block = [0v32, 0v42), size 16 B
19:38:13 0 D start = 50; end = 99; block = [0v32, 0v63), size 49 B
19:38:13 0 D start = 50; end = 132; block = [0v32, 0v84), size 82 B
19:38:13 0 D start = 75; end = 99; block = [0v4B, 0v63), size 24 B
19:38:13 0 D start = 75; end = 132; block = [0v4B, 0v84), size 57 B
19:38:13 0 D start = 75; end = 165; block = [0v4B, 0vA5), size 90 B
2_mm_1_block::block-------------------------------- [passed]
19:38:13 0 I exit qemu; exit_code = SUCCESS
     Running tests/2-mm-1-boot-frame-allocator.rs (/home/sergey/tmp/shad-os/target/kernel/debug/deps/2_mm_1_boot_frame_allocator-687c8353e5574705)
Building bootloader
   Compiling bootloader v0.9.22 (/home/sergey/.cargo/registry/src/github.com-1ecc6299db9ec823/bootloader-0.9.22)
    Finished release [optimized + debuginfo] target(s) in 0.96s
Running: `qemu-system-x86_64 -drive format=raw,file=/home/sergey/tmp/shad-os/target/kernel/debug/deps/bootimage-2_mm_1_boot_frame_allocator-687c8353e5574705.bin -no-reboot -m size=128M -smp cpus=4 -device isa-debug-exit,iobase=0xF4,iosize=0x04 -serial stdio -display none`
19:38:15 0 I RTC init; acknowledged_settings = USE_24_HOUR_FORMAT | UPDATE_ENDED_INTERRUPT
19:38:15 0 I time init
19:38:15 0 I Nikka booted; now = 2022-10-09 19:38:15 UTC; tsc = Tsc(2230097572)
19:38:15 0 I GDT init
19:38:15 0 I interrupts init
19:38:15 0 I phys2virt = Page(4503595332403200 @ 0vFFFFF00000000000)
19:38:15 0 I init; frame_allocator = &quot;boot&quot;; block = [0p5AB000, 0p7FE0000), size 122.207 MiB; free_frame_count = 31285
19:38:15 0 I memory init; duration = 17.297 ms
running 3 tests

2_mm_1_boot_frame_allocator::sanity_check-------------------
19:38:15 0 D free_frames = 31285; min_free_frames = 28672; qemu_memory_frames = 32768
19:38:15 0 D managed = 31285; used = 0
2_mm_1_boot_frame_allocator::sanity_check---------- [passed]

2_mm_1_boot_frame_allocator::allocate-----------------------
19:38:15 0 D frames = [Frame(32735 @ 0p7FDF000), Frame(32734 @ 0p7FDE000)]
2_mm_1_boot_frame_allocator::allocate-------------- [passed]

2_mm_1_boot_frame_allocator::allocated_frames_are_unique----
19:38:15 0 D free_frames = 31283
19:38:15 0 D prev_frame = 32733 @ 0p7FDD000; frame = 32732 @ 0p7FDC000
19:38:15 0 D prev_frame = 22733 @ 0p58CD000; frame = 22732 @ 0p58CC000
19:38:16 0 D prev_frame = 12733 @ 0p31BD000; frame = 12732 @ 0p31BC000
19:38:16 0 D prev_frame = 2733 @ 0pAAD000; frame = 2732 @ 0pAAC000
2_mm_1_boot_frame_allocator::allocated_frames_are_unique [passed]
19:38:16 0 I exit qemu; exit_code = SUCCESS
     Running tests/2-mm-2-page-allocator.rs (/home/sergey/tmp/shad-os/target/kernel/debug/deps/2_mm_2_page_allocator-0d16673aec3ec8e4)
Building bootloader
   Compiling bootloader v0.9.22 (/home/sergey/.cargo/registry/src/github.com-1ecc6299db9ec823/bootloader-0.9.22)
    Finished release [optimized + debuginfo] target(s) in 0.97s
Running: `qemu-system-x86_64 -drive format=raw,file=/home/sergey/tmp/shad-os/target/kernel/debug/deps/bootimage-2_mm_2_page_allocator-0d16673aec3ec8e4.bin -no-reboot -m size=128M -smp cpus=4 -device isa-debug-exit,iobase=0xF4,iosize=0x04 -serial stdio -display none`
19:38:17 0 I RTC init; acknowledged_settings = USE_24_HOUR_FORMAT | UPDATE_ENDED_INTERRUPT
19:38:17 0 I time init
19:38:17 0 I Nikka booted; now = 2022-10-09 19:38:17 UTC; tsc = Tsc(2240178158)
19:38:17 0 I GDT init
19:38:17 0 I interrupts init
19:38:17 0 I phys2virt = Page(4503595332403200 @ 0vFFFFF00000000000)
19:38:17 0 I init; frame_allocator = &quot;boot&quot;; block = [0p5AA000, 0p7FE0000), size 122.211 MiB; free_frame_count = 31286
19:38:17 0 I page allocator init; free_page_count = 33957085184; block = [0v18000000000, 0v10000000000000000), size 126.500 TiB
19:38:17 0 I init; address_space = &quot;base&quot; @ 0p1000
19:38:17 0 I drop; address_space = &quot;invalid&quot; @ 0p0
19:38:17 0 I memory init; duration = 32.639 ms
running 4 tests

2_mm_2_page_allocator::sanity_check-------------------------
19:38:17 0 D page_allocator_block = [0v18000000000, 0v7FFFFFFFF000), size 126.500 TiB, Page[~1.500 TiB, ~128.000 TiB)
2_mm_2_page_allocator::sanity_check---------------- [passed]

2_mm_2_page_allocator::allocate_page------------------------
19:38:17 0 D page = Page(34359738366 @ 0v7FFFFFFFE000)
2_mm_2_page_allocator::allocate_page--------------- [passed]

2_mm_2_page_allocator::allocate_two_pages-------------------
19:38:17 0 D pages = [Page(34359738365 @ 0v7FFFFFFFD000), Page(34359738364 @ 0v7FFFFFFFC000)]
2_mm_2_page_allocator::allocate_two_pages---------- [passed]

2_mm_2_page_allocator::allocate_block-----------------------
19:38:17 0 D requested_size = 38.000 KiB; block = [0v7FFFFFFF2000, 0v7FFFFFFFC000), size 40.000 KiB, Page[~128.000 TiB, ~128.000 TiB)
2_mm_2_page_allocator::allocate_block-------------- [passed]
19:38:17 0 I exit qemu; exit_code = SUCCESS
     Running tests/2-mm-3-mapping.rs (/home/sergey/tmp/shad-os/target/kernel/debug/deps/2_mm_3_mapping-792b889b8b2abc13)
Building bootloader
   Compiling bootloader v0.9.22 (/home/sergey/.cargo/registry/src/github.com-1ecc6299db9ec823/bootloader-0.9.22)
    Finished release [optimized + debuginfo] target(s) in 0.94s
Running: `qemu-system-x86_64 -drive format=raw,file=/home/sergey/tmp/shad-os/target/kernel/debug/deps/bootimage-2_mm_3_mapping-792b889b8b2abc13.bin -no-reboot -m size=128M -smp cpus=4 -device isa-debug-exit,iobase=0xF4,iosize=0x04 -serial stdio -display none`
19:38:19 0 I RTC init; acknowledged_settings = USE_24_HOUR_FORMAT | UPDATE_ENDED_INTERRUPT
19:38:19 0 I time init
19:38:19 0 I Nikka booted; now = 2022-10-09 19:38:19 UTC; tsc = Tsc(2260321974)
19:38:19 0 I GDT init
19:38:19 0 I interrupts init
19:38:19 0 I phys2virt = Page(4503595332403200 @ 0vFFFFF00000000000)
19:38:19 0 I init; frame_allocator = &quot;boot&quot;; block = [0p5AA000, 0p7FE0000), size 122.211 MiB; free_frame_count = 31286
19:38:19 0 I page allocator init; free_page_count = 33957085184; block = [0v18000000000, 0v10000000000000000), size 126.500 TiB
19:38:19 0 I init; address_space = &quot;base&quot; @ 0p1000
19:38:19 0 I drop; address_space = &quot;invalid&quot; @ 0p0
19:38:19 0 I memory init; duration = 17.655 ms
running 2 tests

2_mm_3_mapping::translate-----------------------------------
19:38:19 0 D pte = PageTableEntry(2613347)
19:38:19 0 D read_ptr = 0xfffff0000027e420; write_ptr = 0x10000201420
19:38:19 0 D write_value = 0; read_value = 0; variable = 0
19:38:19 0 D write_value = 1; read_value = 1; variable = 1
19:38:19 0 D write_value = 2; read_value = 2; variable = 2
19:38:19 0 D write_value = 3; read_value = 3; variable = 3
19:38:19 0 D write_value = 4; read_value = 4; variable = 4
2_mm_3_mapping::translate-------------------------- [passed]

2_mm_3_mapping::map_intermediate----------------------------
19:38:19 0 D page = Page(34359738366 @ 0v7FFFFFFFE000)
19:38:19 0 D pte = PageTableEntry(0)
2_mm_3_mapping::map_intermediate------------------- [passed]
19:38:19 0 I exit qemu; exit_code = SUCCESS
     Running tests/2-mm-4-interface.rs (/home/sergey/tmp/shad-os/target/kernel/debug/deps/2_mm_4_interface-eb5fc3d25a039e4c)
Building bootloader
   Compiling bootloader v0.9.22 (/home/sergey/.cargo/registry/src/github.com-1ecc6299db9ec823/bootloader-0.9.22)
    Finished release [optimized + debuginfo] target(s) in 0.93s
Running: `qemu-system-x86_64 -drive format=raw,file=/home/sergey/tmp/shad-os/target/kernel/debug/deps/bootimage-2_mm_4_interface-eb5fc3d25a039e4c.bin -no-reboot -m size=128M -smp cpus=4 -device isa-debug-exit,iobase=0xF4,iosize=0x04 -serial stdio -display none`
19:38:21 0 I RTC init; acknowledged_settings = USE_24_HOUR_FORMAT | UPDATE_ENDED_INTERRUPT
19:38:21 0 I time init
19:38:21 0 I Nikka booted; now = 2022-10-09 19:38:21 UTC; tsc = Tsc(2289679569)
19:38:21 0 I GDT init
19:38:21 0 I interrupts init
19:38:21 0 I phys2virt = Page(4503595332403200 @ 0vFFFFF00000000000)
19:38:21 0 I init; frame_allocator = &quot;boot&quot;; block = [0p5A9000, 0p7FE0000), size 122.215 MiB; free_frame_count = 31287
19:38:21 0 I page allocator init; free_page_count = 33957085184; block = [0v18000000000, 0v10000000000000000), size 126.500 TiB
19:38:21 0 I init; address_space = &quot;base&quot; @ 0p1000
19:38:21 0 I drop; address_space = &quot;invalid&quot; @ 0p0
19:38:21 0 I memory init; duration = 32.833 ms
running 1 tests

2_mm_4_interface::map_slice---------------------------------
19:38:22 0 D slice = [0v7FFFFEFFF000, 0v7FFFFFFFF000), size 16.000 MiB, Virt[~128.000 TiB, ~128.000 TiB)
2_mm_4_interface::map_slice------------------------ [passed]
19:38:25.077 0 I exit qemu; exit_code = SUCCESS
     Running tests/2-mm-5-main-frame-allocator.rs (/home/sergey/tmp/shad-os/target/kernel/debug/deps/2_mm_5_main_frame_allocator-5e980c813edc491b)
Building bootloader
   Compiling bootloader v0.9.22 (/home/sergey/.cargo/registry/src/github.com-1ecc6299db9ec823/bootloader-0.9.22)
    Finished release [optimized + debuginfo] target(s) in 0.94s
Running: `qemu-system-x86_64 -drive format=raw,file=/home/sergey/tmp/shad-os/target/kernel/debug/deps/bootimage-2_mm_5_main_frame_allocator-5e980c813edc491b.bin -no-reboot -m size=128M -smp cpus=4 -device isa-debug-exit,iobase=0xF4,iosize=0x04 -serial stdio -display none`
19:38:26 0 I RTC init; acknowledged_settings = USE_24_HOUR_FORMAT | UPDATE_ENDED_INTERRUPT
19:38:26 0 I time init
19:38:26 0 I Nikka booted; now = 2022-10-09 19:38:26 UTC; tsc = Tsc(2328791295)
19:38:26 0 I GDT init
19:38:26 0 I interrupts init
19:38:26 0 I phys2virt = Page(4503595332403200 @ 0vFFFFF00000000000)
19:38:26 0 I init; frame_allocator = &quot;boot&quot;; block = [0p5C2000, 0p7FE0000), size 122.117 MiB; free_frame_count = 31262
19:38:26 0 I page allocator init; free_page_count = 33957085184; block = [0v18000000000, 0v10000000000000000), size 126.500 TiB
19:38:26 0 I init; address_space = &quot;base&quot; @ 0p1000
19:38:26 0 I drop; address_space = &quot;invalid&quot; @ 0p0
19:38:26 0 I available memory; total = 127.875 MiB; usable = 123.621 MiB; total_frames = 32736; usable_frames = 31647
19:38:26 0 D frame info mapped; frame_allocator = &quot;main&quot;; duration = 21.447 ms
19:38:26 0 D frame info init; frame_allocator = &quot;main&quot;; duration = 64.325 ms
19:38:26 0 D move free frames from the boot frame allocator; frame_allocator = &quot;main&quot;; free_frame_count = 31067
19:38:26 0 I drop; frame_allocator = &quot;boot&quot;; block = [0p5C2000, 0p5C2000), size 0 B; leaked_frame_count = 0
19:38:26 0 D moved all free frames; frame_allocator = &quot;main&quot;; duration = 93.900 ms
19:38:27 0 I init; frame_allocator = &quot;main&quot;; free_frame_count = 31452; duration = 205.386 ms
19:38:27 0 I memory init; duration = 237.945 ms
running 5 tests

2_mm_5_main_frame_allocator::sanity_check-------------------
19:38:27 0 D free_frames = 31452; min_free_frames = 28672; qemu_memory_frames = 32768
2_mm_5_main_frame_allocator::sanity_check---------- [passed]

2_mm_5_main_frame_allocator::basic_frame_allocator_functions
19:38:27 0 D frames = [Frame(32540 @ 0p7F1C000), Frame(32539 @ 0p7F1B000)]
19:38:27 0 D reallocate_last_freed_frame = Frame(32540 @ 0p7F1C000)
2_mm_5_main_frame_allocator::basic_frame_allocator_functions [passed]

2_mm_5_main_frame_allocator::allocated_frames_are_unique----
19:38:27 0 D free_frames = 31390
19:38:27 0 D free_frames = 0
19:38:29.579 0 D free_frames = 31390
2_mm_5_main_frame_allocator::allocated_frames_are_unique [passed]

2_mm_5_main_frame_allocator::shared_memory------------------
19:38:29.613 0 D frame = Frame(32479 @ 0p7EDF000)
19:38:29.617 0 D pages = [Page(34359738111 @ 0v7FFFFFEFF000), Page(34359738112 @ 0v7FFFFFF00000)]
19:38:29.627 0 D write_ptr = 0x7ffffff00000; read_ptr = 0x7fffffeff000
19:38:29.633 0 D write_value = 0; read_value = 0
19:38:29.639 0 D write_value = 1; read_value = 1
19:38:29.643 0 D write_value = 2; read_value = 2
2_mm_5_main_frame_allocator::shared_memory--------- [passed]

2_mm_5_main_frame_allocator::duplicate_and_drop_mapping-----
19:38:29.695 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
19:38:29.703 0 I duplicate; address_space = &quot;process&quot; @ 0p7EDF000
19:38:29.709 0 D ptes = [PageTableEntry(2613347), PageTableEntry(2613347)]
19:38:29.715 0 D pte_addresses = [Virt(0vFFFFF000005BB008), Virt(0vFFFFF00007EE7008)]
19:38:29.725 0 I drop; address_space = &quot;process&quot; @ 0p7EDF000
2_mm_5_main_frame_allocator::duplicate_and_drop_mapping [passed]
19:38:29.761 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<p>В случае ошибки вы увидите что-нибудь вроде</p>
<pre><code class="language-console">...
panicked at 'called `Result::unwrap()` on an `Err` value: NoFrame', src/memory/main_frame_allocator.rs:49:14
--------------------------------------------------- [failed]
21:41:55 0 I exit qemu; exit_code = FAILURE
error: test failed, to rerun pass '--bin kernel'
</code></pre>
<p>Но учтите, что тесты не могут покрывать всё.
Так что даже если они прошли успешно, возможно код содержит ошибки,
которые проявят себя позже в следующих лабораторных работах.
Чтобы повысить свою уверенность, что этого не произойдёт,
добавьте собственные тесты, а также внимательно перечитайте свой код и код вокруг.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Процессы"><a class="header" href="#Процессы">Процессы</a></h2>
<p>В этой лабораторке нужно будет добавить в Nikka пользовательские процессы.
А именно, написать код инициализации и загрузки процесса в память,
а также передачу управления пользовательскому коду.</p>
<h3 id="Структура-кода-работы-с-пользовательскими-процессами-в-nikka"><a class="header" href="#Структура-кода-работы-с-пользовательскими-процессами-в-nikka">Структура кода работы с пользовательскими процессами в Nikka</a></h3>
<p>Код работы с пользовательскими процессами в ядре собран в модуль <a href="../../doc/kernel/process/index.html"><code>kernel::process</code></a> в директории <code>kernel/src/process</code>:</p>
<ul>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/mod.rs"><code>kernel/src/process/mod.rs</code></a> — корневая часть модуля <a href="../../doc/kernel/process/index.html"><code>kernel::process</code></a>. Содержит функцию <a href="../../doc/kernel/process/fn.init.html"><code>fn kernel::process::init()</code></a>, инициализирующую работу с процессами. Она вызывает функции инициализации своих подсистем — системных вызовов, таблицы процессов, планировщика.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/elf.rs"><code>kernel/src/process/elf.rs</code></a> — содержит функцию загрузки ELF–файла в память <a href="../../doc/kernel/process/elf/fn.load.html"><code>fn kernel::process::elf::load()</code></a>.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/process.rs"><code>kernel/src/process/process.rs</code></a> — содержит основную структуру <a href="../../doc/kernel/process/process/struct.Process.html"><code>kernel::process::process::Process</code></a>, описывающую пользовательский процесс.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/registers.rs"><code>kernel/src/process/registers.rs</code></a> — содержит структуру <a href="../../doc/kernel/process/registers/struct.Registers.html"><code>kernel::process::registers::Registers</code></a> для контроля контекста процесса.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/scheduler.rs"><code>kernel/src/process/scheduler.rs</code></a> — планировщик исполнения процессов <a href="../../doc/kernel/process/scheduler/struct.Scheduler.html"><code>kernel::process::scheduler::Scheduler</code></a>.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/syscall.rs"><code>kernel/src/process/syscall.rs</code></a> — содержит функцию <a href="../../doc/kernel/process/syscall/fn.syscall.html"><code>fn kernel::process::syscall::syscall()</code></a>, которая является входной точкой системных вызовов и выполняет их диспетчеризацию. Функции, реализующие разные системные вызовы находятся в этом же файле. Также содержит функцию <a href="../../doc/kernel/process/syscall/fn.init.html"><code>fn kernel::process::syscall::init()</code></a> инициализации системных вызовов.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/table.rs"><code>kernel/src/process/table.rs</code></a> — содержит таблицу процессов <a href="../../doc/kernel/process/table/struct.Table.html"><code>kernel::process::table::Table</code></a>.</li>
</ul>
<p>Код, который используется и в ядре и в пространстве пользователя, собран в модуль <a href="../../doc/ku/process/index.html"><code>ku::process</code></a> в директории <code>ku/src/process</code>:</p>
<ul>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/process/mod.rs"><code>ku/src/process/mod.rs</code></a> — корневая часть модуля <a href="../../doc/ku/process/index.html"><code>ku::process</code></a>.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/process/trap_info.rs"><code>ku/src/process/trap_info.rs</code></a> — содержит структуру <a href="../../doc/ku/process/trap_info/struct.TrapInfo.html"><code>ku::process::trap_info::TrapInfo</code></a>, которая передаёт из режима ядра в режим пользователя информацию о возникшем прерывании.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/process/mini_context.rs"><code>ku/src/process/mini_context.rs</code></a> — содержит структуру <a href="../../doc/ku/process/mini_context/struct.MiniContext.html"><code>ku::process::mini_context::MiniContext</code></a>, которая инкапсулирует минимальный контекст исполнения — регистры <code>RIP</code> и <code>RSP</code>.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/process/pid.rs"><code>ku/src/process/pid.rs</code></a> — содержит структуру <a href="../../doc/ku/process/pid/enum.Pid.html"><code>ku::process::pid::Pid</code></a>, которая описывает идентификатор процесса.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/process/syscall.rs"><code>ku/src/process/syscall.rs</code></a> — модуль <a href="../../doc/ku/process/syscall/index.html"><code>ku::process::syscall</code></a>, содержит константы для системных вызовов.</li>
</ul>
<h3 id="Ориентировочный-объём-работ-этой-лабораторки-2"><a class="header" href="#Ориентировочный-объём-работ-этой-лабораторки-2">Ориентировочный объём работ этой лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/memory/address_space.rs |   22 +++++-
 kernel/src/process/elf.rs          |   71 +++++++++++++++++++-
 kernel/src/process/registers.rs    |   63 +++++++++++++++++-
 kernel/src/process/syscall.rs      |  127 ++++++++++++++++++++++++++++++++++---
 user/lib/src/syscall.rs            |   54 +++++++++++++++
 5 files changed, 319 insertions(+), 18 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Загрузка-процесса-в-память"><a class="header" href="#Загрузка-процесса-в-память">Загрузка процесса в память</a></h2>
<p>У нас ещё нет файловой системы.
Поэтому пока код пользовательских программ линкуется прямо в бинарник ядра макросом
<a href="https://doc.rust-lang.org/core/macro.include_bytes.html"><code>core::include_bytes!()</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const LOOP_ELF: &amp;[u8] = include_bytes!(&quot;../../../user/loop/target/kernel/debug/loop&quot;);
process::create(LOOP_ELF);
<span class="boring">}
</span></code></pre></pre>
<p>Первой нашей задачей будет распарсить
<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF–файл</a>
с помощью библиотеки
<a href="../../doc/xmas_elf/index.html"><code>xmas_elf</code></a> и построить его образ в памяти.
Нам достаточно <a href="https://wiki.osdev.org/ELF#Loading_ELF_Binaries">простейшей реализации</a>,
которая поддерживает только статические ELF–файлы,
без <a href="https://wiki.osdev.org/ELF#Relocation">релокаций</a>, обработки
<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#Section_header">секций</a> и символов.
Она содержится в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/elf.rs"><code>kernel/src/process/elf.rs</code></a>.
Основной является <a href="../../doc/kernel/process/elf/fn.load.html">функция</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn kernel::process::elf::load(
    address_space: &amp;mut AddressSpace,
    file: &amp;[u8],
) -&gt; Result&lt;Virt&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Она принимает на вход</p>
<ul>
<li>Адресное пространство <code>address_space</code> процесса, куда нужно загрузить его образ. Для упрощения реализации функции<a href="../../doc/kernel/process/elf/fn.load.html"><code>load()</code></a>, вызывающая её функция гарантирует, что <code>address_space</code> является текущим адресным пространством.</li>
<li>Срез <code>file</code> с записанным в памяти ELF–файлом процесса.</li>
</ul>
<p>Из <code>file</code> она создаёт объект <a href="../../doc/xmas_elf/struct.ElfFile.html"><code>xmas_elf::ElfFile</code></a>,
проходится по его
<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#Program_header">сегментам</a> итератором
<a href="../../doc/xmas_elf/struct.ElfFile.html#method.program_iter"><code>ElfFile::program_iter()</code></a>
и загружает в память те из них, у которых тип
<a href="../../doc/xmas_elf/program/enum.ProgramHeader.html#method.get_type"><code>ProgramHeader::get_type()</code></a>
является загружаемым —
<a href="../../doc/xmas_elf/program/enum.Type.html#variant.Load"><code>Type::Load</code></a>.
После загрузки она возвращает точку входа в загруженную программу
<a href="../../doc/xmas_elf/header/enum.HeaderPt2.html#method.entry_point"><code>HeaderPt2::entry_point()</code></a>
в виде виртуального адреса
<a href="../../doc/ku/memory/addr/type.Virt.html"><code>Virt</code></a>.</p>
<p>Для загрузки сегмента файла она пользуется вспомогательной <a href="../../doc/kernel/process/elf/fn.load_program_header.html">функцией</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn kernel::process::elf::load_program_header(
    address_space: &amp;mut AddressSpace,
    program_header: &amp;ProgramHeader,
    file: &amp;[u8],
    mapped_end: &amp;mut Virt,
) -&gt; Result&lt;()&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Функция <a href="../../doc/kernel/process/elf/fn.load_program_header.html"><code>load_program_header()</code></a>
загружает в память заданный <code>program_header</code>, поддерживая <code>mapped_end</code> —
адрес до которого (не включительно) память для загружаемого процесса уже аллоцирована.</p>
<p>Отслеживать конец аллоцированной части памяти <code>mapped_end</code> нужно,
так как аллоцировать и отображать память можно только постранично,
а сегменты ELF–файла могут быть невыровнены по границе страницы.
И несколько сегментов могут задевать одну и ту же страницу.
При загрузке первого из них
<a href="../../doc/kernel/process/elf/fn.load_program_header.html"><code>load_program_header()</code></a>
отобразит эту страницу в память и обновит <code>mapped_end</code>.
А при загрузке последующих, по значению <code>mapped_end</code> она поймёт, что отображать страницу в память уже не нужно
и достаточно только записать в неё очередную порцию данных из ELF–файла.</p>
<p>Таким образом,
<a href="../../doc/kernel/process/elf/fn.load_program_header.html"><code>load_program_header()</code></a>
делает две вещи:</p>
<ul>
<li>Расширяет отображённое в память пространство процесса.</li>
<li>Копирует содержимое очередного сегмента <code>program_header</code> в память по адресу <a href="../../doc/xmas_elf/program/enum.ProgramHeader.html#method.virtual_addr"><code>ProgramHeader::virtual_addr()</code></a>. Этот сегмент записан в срезе <code>file</code> по смещению <a href="../../doc/xmas_elf/program/enum.ProgramHeader.html#method.offset"><code>ProgramHeader::offset()</code></a>.</li>
</ul>
<p>Обратите внимание на то, что размер сегмента в файле
<a href="../../doc/xmas_elf/program/enum.ProgramHeader.html#method.file_size"><code>ProgramHeader::file_size()</code></a>
может быть меньше чем его размер в памяти
<a href="../../doc/xmas_elf/program/enum.ProgramHeader.html#method.mem_size"><code>ProgramHeader::mem_size()</code></a>.
Тогда дополнительные байты памяти нужно занулить.
Этого требует формат ELF — там может, например, располагаться секция
<a href="https://en.wikipedia.org/wiki/.bss"><code>.bss</code></a>,
предназначенная для неинициализированных или инициализированных нулями статических переменных.
Также обратите внимание, что отображать в память образ процесса нужно с флагом
<a href="../../doc/ku/memory/mmu/struct.PageTableFlags.html#associatedconstant.USER_ACCESSIBLE"><code>PageTableFlags::USER_ACCESSIBLE</code></a>,
иначе он просто не заработает в пространстве пользователя,
вызвав исключение доступа к памяти — Page Fault.</p>
<p>Для расширения отображения,
<a href="../../doc/kernel/process/elf/fn.load_program_header.html"><code>load_program_header()</code></a>
прибегает к помощи вспомогательной
<a href="../../doc/kernel/process/elf/fn.extend_mapping.html">функции</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn kernel::process::elf::extend_mapping(
    address_space: &amp;mut AddressSpace,
    memory_block: &amp;Block&lt;Virt&gt;,
    flags: Flags,
    mapped_end: &amp;mut Virt,
) -&gt; Result&lt;()&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Кроме уже знакомых нам аргументов, функция
<a href="../../doc/kernel/process/elf/fn.extend_mapping.html"><code>extend_mapping()</code></a>
принимает</p>
<ul>
<li>Описатель блока виртуальной памяти <code>memory_block</code> для очередного сегмента ELF–файла.</li>
<li>Флаги <code>flags</code> этого сегмента — <a href="../../doc/xmas_elf/program/enum.ProgramHeader.html#method.flags"><code>ProgramHeader::flags()</code></a>.</li>
</ul>
<p>Для вычисления <code>memory_block</code> используется вспомогательная <a href="../../doc/kernel/process/elf/fn.memory_block.html">функция</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn kernel::process::elf::memory_block(
    program_header: &amp;ProgramHeader,
) -&gt; Result&lt;Block&lt;Virt&gt;&gt;
<span class="boring">}
</span></code></pre></pre>
<h3 id="Задача-1--загрузка-elfфайла"><a class="header" href="#Задача-1--загрузка-elfфайла">Задача 1 — загрузка ELF–файла</a></h3>
<p>Реализуйте указанные функции.
Вам могут пригодиться:</p>
<ul>
<li>Метод <a href="../../doc/ku/memory/block/struct.Block.html#method.enclosing"><code>fn Block::&lt;Virt&gt;::enclosing() -&gt; Block&lt;Page&gt;</code></a>, который для заданного блока виртуальных адресов возвращает минимальный содержащий его блок страниц виртуальной памяти.</li>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.try_into_mut_slice"><code>Block::&lt;Virt&gt;::try_into_mut_slice()</code></a>.</li>
<li>Метод <a href="https://doc.rust-lang.org/nightly/core/primitive.slice.html#method.fill"><code>fill()</code></a> <a href="https://doc.rust-lang.ru/book/ch04-03-slices.html">срезов</a>.</li>
<li><a href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html#method.map_err"><code>Result::map_err()</code></a> для преобразования одного типа ошибки в другой.</li>
<li><a href="../../doc/ku/memory/addr/struct.Addr.html#method.new_u64"><code>Virt::new_u64()</code></a>.</li>
<li><a href="../../doc/ku/memory/size/fn.into_usize.html"><code>ku::memory::size::into_usize()</code></a>.</li>
</ul>
<h3 id="Дополнительные-материалы-про-elfфайлы"><a class="header" href="#Дополнительные-материалы-про-elfфайлы">Дополнительные материалы про ELF–файлы</a></h3>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Executable and Linkable Format</a></li>
<li><a href="https://wiki.osdev.org/ELF">ELF</a></li>
<li><a href="https://www.uclibc.org/docs/elf-64-gen.pdf">ELF-64 Object File Format</a></li>
</ul>
<h3 id="Проверьте-себя-5"><a class="header" href="#Проверьте-себя-5">Проверьте себя</a></h3>
<p>Запустите тест <code>3-process-1-elf</code> из файла
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/3-process-1-elf.rs"><code>kernel/tests/3-process-1-elf.rs</code></a>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 3-process-1-elf)
...
3_process_1_elf::create_process--------------------------------
18:36:10 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
18:36:10 0 I duplicate; address_space = &quot;process&quot; @ 0p7F1C000
18:36:10 0 I switch to; address_space = &quot;process&quot; @ 0p7F1C000
18:36:10 0 D extend mapping; block = [0v10000000, 0v10006E04), size 27.504 KiB; page_block = [0v10000000, 0v10007000), size 28.000 KiB; flags =   R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
18:36:10 0 D elf loadable program header; file_block = [0v2017A0, 0v2085A4), size 27.504 KiB; memory_block = [0v10000000, 0v10006E04), size 27.504 KiB; flags =   R
18:36:10 0 D extend mapping; block = [0v10007000, 0v1004EBA2), size 286.908 KiB; page_block = [0v10007000, 0v1004F000), size 288.000 KiB; flags = X R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
18:36:10 0 D elf loadable program header; file_block = [0v2085B0, 0v250342), size 287.393 KiB; memory_block = [0v10006E10, 0v1004EBA2), size 287.393 KiB; flags = X R
18:36:10 0 D elf loadable program header; file_block = [0v250348, 0v250438), size 240 B; memory_block = [0v1004EBA8, 0v1004EC98), size 240 B; flags =  WR
18:36:10 0 D extend mapping; block = [0v1004F000, 0v10054980), size 22.375 KiB; page_block = [0v1004F000, 0v10055000), size 24.000 KiB; flags =  WR; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
18:36:10 0 D elf loadable program header; file_block = [0v250438, 0v2560F8), size 23.188 KiB; memory_block = [0v1004EC98, 0v10054980), size 23.227 KiB; flags =  WR
18:36:10 0 I switch to; address_space = &quot;base&quot; @ 0p1000
18:36:10 0 I loaded ELF file; context = { rip: 0v10006EC0, rsp: 0v7F7FFFFFF000 }; file_size = 5.279 MiB; process = { pid: &lt;current&gt;, address_space: &quot;process&quot; @ 0p7F1C000, { rip: 0v10006EC0, rsp: 0v7F7FFFFFF000 } }
18:36:10 0 I user process page table entry; entry_point = 0v10006EC0; frame = Frame(32512 @ 0p7F00000); flags = PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED | DIRTY
18:36:10 0 D process_frames = 126
18:36:10 0 I drop; address_space = &quot;process&quot; @ 0p7F1C000
3_process_1_elf::create_process----------------------- [passed]

3_process_1_elf::create_process_failure------------------------
18:36:11 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
18:36:11 0 I duplicate; address_space = &quot;process&quot; @ 0p7F1C000
18:36:11 0 I switch to; address_space = &quot;process&quot; @ 0p7F1C000
18:36:11 0 I switch to; address_space = &quot;base&quot; @ 0p1000
18:36:11 0 I drop the current address space; address_space = &quot;process&quot; @ 0p7F1C000; switch_to = &quot;base&quot; @ 0p1000
18:36:11 0 I expected a process creation failure; error = Elf(&quot;File is shorter than the first ELF header part&quot;)
3_process_1_elf::create_process_failure--------------- [passed]
18:36:11 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-8"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-8">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/process/elf.rs |   71 +++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 67 insertions(+), 4 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Проверки-доступа-процесса-к-памяти"><a class="header" href="#Проверки-доступа-процесса-к-памяти">Проверки доступа процесса к памяти</a></h2>
<p>В системных вызовах код пользователя будет передавать в ядро области памяти, описываемые <code>Block&lt;Virt&gt;</code>.
И код ядра должен будет что-то сделать с указанной памятью,
иногда читая или записывая в неё.</p>
<p>Ядро не может доверять коду пользователя, поэтому перед чтением или записью в такие области памяти,
оно должно проверить, есть ли у пользователя соответствующий доступ.
За выполнение всех нужных проверок, не только указанного типа,
отвечают функции системных вызовов в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/syscall.rs"><code>kernel/src/process/syscall.rs</code></a>, —
это граница между кодом пользователя и кодом ядра.</p>
<p>А за фактическую реализацию проверок доступа к памяти отвечают методы в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/address_space.rs"><code>kernel/src/memory/address_space.rs</code></a>:</p>
<ul>
<li><a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.check_permission"><code>kernel::memory::address_space::AddressSpace::check_permission&lt;T&gt;()</code></a> — проверяет доступность памяти на чтение.</li>
<li><a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.check_permission_mut"><code>kernel::memory::address_space::AddressSpace::check_permission_mut&lt;T&gt;()</code></a> — проверяет доступность памяти на запись.</li>
</ul>
<p>Оба метода принимают на вход <code>Block&lt;Virt&gt;</code>, а возвращают либо ошибку доступа
<a href="../../doc/kernel/error/enum.Error.html#variant.PermissionDenied"><code>Error::PermissionDenied</code></a>,
либо неизменяемый срез <code>&amp;[T]</code> и изменяемый <code>&amp;mut [T]</code> соответственно.
Для перевода <code>Block&lt;Virt&gt;</code> в срезы они пользуются методами
<a href="../../doc/ku/memory/block/struct.Block.html#method.try_into_slice"><code>Block::&lt;Virt&gt;::try_into_slice()</code></a> и
<a href="../../doc/ku/memory/block/struct.Block.html#method.try_into_mut_slice"><code>Block::&lt;Virt&gt;::try_into_mut_slice()</code></a>.
Которые выполняют дополнительные проверки — что <code>Block&lt;Virt&gt;</code> имеет допустимый адрес, а не
<a href="https://doc.rust-lang.org/nightly/core/ptr/fn.null.html"><code>core::ptr::null()</code></a>,
что он выровнен подходящим для <code>T</code> образом и имеет подходящий для хранения <code>[T]</code> размер.</p>
<p>Основную же работу по проверке доступа к виртуальным адресам они перекладывают на вспомогательный метод</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn AddressSpace::check_permission_common(
    &amp;mut self,
    block: &amp;Block&lt;Virt&gt;,
    flags: PageTableFlags,
) -&gt; Result&lt;()&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Он должен пройтись по всем страницам заданного <code>block</code>, проверяя что они отображены в адресное пространство <code>self</code>
с флагами <code>PageTableFlags::PRESENT</code>, <code>PageTableFlags::USER_ACCESSIBLE</code> и заданными на вход <code>flags</code> одновременно.</p>
<h3 id="Задача-2--проверка-доступа-к-памяти"><a class="header" href="#Задача-2--проверка-доступа-к-памяти">Задача 2 — проверка доступа к памяти</a></h3>
<p>Реализуйте методы <a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.check_permission_common"><code>AddressSpace::check_permission_common()</code></a>, <a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.check_permission"><code>AddressSpace::check_permission&lt;T&gt;()</code></a> и <a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.check_permission_mut"><code>AddressSpace::check_permission_mut&lt;T&gt;()</code></a> в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/address_space.rs"><code>kernel/src/memory/address_space.rs</code></a>.</p>
<p>Вам могут пригодиться</p>
<ul>
<li>Метод <a href="../../doc/ku/memory/block/struct.Block.html#method.enclosing"><code>fn Block::&lt;Virt&gt;::enclosing() -&gt; Block&lt;Page&gt;</code></a>, который для заданного блока виртуальных адресов возвращает минимальный содержащий его блок страниц виртуальной памяти.</li>
<li>Метод <a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.translate"><code>Mapping::translate()</code></a>.</li>
<li>Метод <a href="../../doc/ku/memory/mmu/struct.PageTableFlags.html#method.contains"><code>PageTableFlags::contains()</code></a>.</li>
<li><a href="../../doc/ku/memory/block/struct.Block.html#impl-IntoIterator-for-Block%3CT%3E">Итерирование</a> по страницам блока с помощью вызова <a href="../../doc/ku/memory/block/struct.Block.html#method.into_iter"><code>Block::&lt;Page&gt;::into_iter()</code></a>.</li>
</ul>
<h3 id="Проверьте-себя-6"><a class="header" href="#Проверьте-себя-6">Проверьте себя</a></h3>
<p>Запустите тест <code>3-process-2-permission-checks</code> из файлa
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/3-process-2-permission-checks.rs"><code>kernel/tests/3-process-2-permission-checks.rs</code></a>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 3-process-2-permission-checks)
...
3_process_2_permission_checks::user_rw--------------------------
19:41:36 0 D pages = [0v7FFFFFF3B000, 0v7FFFFFF3F000), size 16.000 KiB
3_process_2_permission_checks::user_rw----------------- [passed]

3_process_2_permission_checks::non_present----------------------
19:41:36 0 D pages = [0v7FFFFFF37000, 0v7FFFFFF3B000), size 16.000 KiB
3_process_2_permission_checks::non_present------------- [passed]

3_process_2_permission_checks::stress---------------------------
19:41:36 0 D pages = [0v7FFFFFF36000, 0v7FFFFFF37000), size 4.000 KiB
19:41:37.093 0 D pages = [0v7FFFFFF34000, 0v7FFFFFF36000), size 8.000 KiB
19:41:39.177 0 D pages = [0v7FFFFFF31000, 0v7FFFFFF34000), size 12.000 KiB
19:41:48.835 0 D pages = [0v7FFFFFF2D000, 0v7FFFFFF31000), size 16.000 KiB
3_process_2_permission_checks::stress------------------ [passed]
19:42:18.721 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-9"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-9">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/memory/address_space.rs |   22 +++++++++++++++++++---
 1 file changed, 19 insertions(+), 3 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Переход-в-режим-пользователя"><a class="header" href="#Переход-в-режим-пользователя">Переход в режим пользователя</a></h2>
<p>После того как мы загрузили пользовательский процесс в память,
можно запустить его.
Для это требуется не только перейти на его точку входа, но и переключить процессор в непривилегированный режим — в
<a href="https://en.wikipedia.org/wiki/Protection_ring">кольцо защиты</a> 3.
Иначе пользовательский процесс сможет испортить код или данные ядра и других процессов.
Есть <a href="https://wiki.osdev.org/Getting_to_Ring_3">несколько вариантов</a> сделать это.
Воспользуемся инструкцией
<a href="https://www.felixcloutier.com/x86/iret:iretd:iretq"><code>iretq</code></a>.</p>
<h3 id="Состояние-регистров-пользовательского-процесса"><a class="header" href="#Состояние-регистров-пользовательского-процесса">Состояние регистров пользовательского процесса</a></h3>
<p>Состояние регистров пользовательского процесса хранится в структуре
<a href="../../doc/kernel/process/registers/struct.Registers.html"><code>kernel::process::registers::Registers</code></a>.
Для использования
<a href="https://www.felixcloutier.com/x86/iret:iretd:iretq"><code>iretq</code></a>
нам понадобится её поле
<a href="../../doc/kernel/process/registers/struct.Registers.html#structfield.user_context"><code>Registers::user_context</code></a>.
Оно является структурой
<a href="../../doc/kernel/process/registers/struct.ModeContext.html"><code>kernel::process::registers::ModeContext</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub(crate) struct ModeContext {
    rip: Virt,
    cs: usize,
    rflags: RFlags,
    rsp: Virt,
    ss: usize,
}
<span class="boring">}
</span></code></pre></pre>
<p>Которая имеет ровно такое представление в памяти, какого требует инструкция
<a href="https://www.felixcloutier.com/x86/iret:iretd:iretq"><code>iretq</code></a>.
Если регистр <code>RSP</code> указывает на адрес
<a href="../../doc/kernel/process/registers/struct.ModeContext.html"><code>ModeContext</code></a>
в момент выполнения инструкции
<a href="https://www.felixcloutier.com/x86/iret:iretd:iretq"><code>iretq</code></a>,
процессор загрузит</p>
<ul>
<li>поле <a href="../../doc/kernel/process/registers/struct.ModeContext.html#structfield.rip"><code>ModeContext::rip</code></a> в регистр адреса команды <code>RIP</code>,</li>
<li>поле <a href="../../doc/kernel/process/registers/struct.ModeContext.html#structfield.cs"><code>ModeContext::cs</code></a> в регистр сегмента кода <code>CS</code>,</li>
<li>поле <a href="../../doc/kernel/process/registers/struct.ModeContext.html#structfield.rflags"><code>ModeContext::rflags</code></a> в регистр флагов <code>RFLAGS</code>,</li>
<li>поле <a href="../../doc/kernel/process/registers/struct.ModeContext.html#structfield.rsp"><code>ModeContext::rsp</code></a> в регистр адреса стека <code>RSP</code>,</li>
<li>поле <a href="../../doc/kernel/process/registers/struct.ModeContext.html#structfield.ss"><code>ModeContext::ss</code></a> в регистр сегмента стека <code>SS</code>.</li>
</ul>
<p>Слово mode в <a href="../../doc/kernel/process/registers/struct.ModeContext.html"><code>ModeContext</code></a>
символизирует тот факт, что эта структура позволяет переключаться между режимами пользователя и ядра.</p>
<p>С помощью метода
<a href="../../doc/kernel/process/registers/struct.ModeContext.html#method.user_context"><code>ModeContext::user_context()</code></a>
заполним эти поля так:</p>
<ul>
<li>Поле <a href="../../doc/kernel/process/registers/struct.ModeContext.html#structfield.rip"><code>ModeContext::rip</code></a> будет содержать точку входа в программу пользователя, которую возвращает функция <a href="../../doc/kernel/process/elf/fn.load.html"><code>kernel::process::elf::load()</code></a>.</li>
<li>Поле <a href="../../doc/kernel/process/registers/struct.ModeContext.html#structfield.cs"><code>ModeContext::cs</code></a> — селектор кода пользователя, который возвращает метод <a href="../../doc/kernel/memory/gdt/struct.SmpGdt.html#method.user_code"><code>kernel::memory::gdt::Gdt::user_code()</code></a>.</li>
<li>Поле <a href="../../doc/kernel/process/registers/struct.ModeContext.html#structfield.rflags"><code>ModeContext::rflags</code></a> будет содержать единственный включённый флаг — <a href="../../doc/ku/process/registers/struct.RFlags.html#associatedconstant.INTERRUPT_FLAG"><code>RFlags::INTERRUPT_FLAG</code></a>. Это требуется чтобы по прерыванию, например, от таймера, процессор вернулся в ядро. И пользовательский код не смог его монополизировать.</li>
<li>Поле <a href="../../doc/kernel/process/registers/struct.ModeContext.html#structfield.rsp"><code>ModeContext::rsp</code></a> будет содержать адрес конца стека пользователя — в <a href="https://en.wikipedia.org/wiki/X86-64">x86-64</a> стек растёт от старших адресов к младшим. Стек для пользовательского процесса выделяет функция <a href="../../doc/kernel/process/fn.create.html"><code>kernel::process::create()</code></a> с помощью метода <a href="../../doc/kernel/memory/stack/struct.Stack.html#method.new"><code>kernel::memory::stack::Stack::new()</code></a>. Метод <a href="../../doc/kernel/memory/stack/struct.Stack.html#method.new"><code>Stack::new()</code></a> аллоцирует <a href="../../doc/kernel/memory/stack/constant.STACK_SIZE.html"><code>kernel::memory::stack::STACK_SIZE</code></a> байт памяти и запрещает доступ к младшим <a href="../../doc/kernel/memory/stack/constant.GUARD_ZONE_SIZE.html"><code>kernel::memory::stack::GUARD_ZONE_SIZE</code></a> байтам из них, чтобы отлавливать переполнение стека. Начальное значение указателя стека возвращает метод <a href="../../doc/kernel/memory/stack/struct.Stack.html#method.pointer"><code>Stack::pointer()</code></a>.</li>
<li>Поле <a href="../../doc/kernel/process/registers/struct.ModeContext.html#structfield.ss"><code>ModeContext::ss</code></a> будет содержать селектор данных пользователя, который возвращает метод <a href="../../doc/kernel/memory/gdt/struct.SmpGdt.html#method.user_data"><code>kernel::memory::gdt::Gdt::user_data()</code></a>.</li>
</ul>
<p>Конкретные значения остальных полей структуры
<a href="../../doc/kernel/process/registers/struct.Registers.html"><code>Registers</code></a>,
в которых хранятся регистры общего назначения кроме <code>RSP</code>, нас пока не интересуют.</p>
<h3 id="Задача-3--переключение-процессора-в-режим-пользователя-и-возврат-из-него"><a class="header" href="#Задача-3--переключение-процессора-в-режим-пользователя-и-возврат-из-него">Задача 3 — переключение процессора в режим пользователя и возврат из него</a></h3>
<p>Само переключение выполняет <a href="../../doc/kernel/process/registers/struct.Registers.html#method.switch_to">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn Registers::switch_to(registers: *const Registers)
<span class="boring">}
</span></code></pre></pre>
<p>Для его реализации придётся использовать ассемблер, например прибегнуть к макросу
<a href="https://doc.rust-lang.org/core/arch/macro.asm.html"><code>asm!()</code></a>,
документацию на который можно посмотреть в
<a href="https://doc.rust-lang.org/nightly/rust-by-example/unsafe/asm.html">Rust By Example</a> и
<a href="https://doc.rust-lang.org/nightly/reference/inline-assembly.html">The Rust Reference</a>.</p>
<p>Мы не будем явно сохранять контекст ядра.
Пусть это сделает за нас компилятор.
Мы просто укажем ему, что испортили состояние всех регистров, с помощью конструкции <code>lateout(...) _</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asm!(
    &quot;
    ...
    &quot;,
    ...
    lateout(&quot;rax&quot;) _,
    ...
);
<span class="boring">}
</span></code></pre></pre>
<p>Есть надежда, что компилятор тогда не будет сохранять
<a href="https://en.wikipedia.org/wiki/X86_calling_conventions#Callee-saved_%28non-volatile%29_registers">callee-saved</a>
регистры.
Единственное что, он не согласится на порчу регистров <code>RBX</code> и <code>RBP</code>.
Эти регистры мы должны будем сохранить на стеке ядра и восстановить вручную.</p>
<p>Таким образом для переключения в режим пользователя метод
<a href="../../doc/kernel/process/registers/struct.Registers.html#method.switch_to"><code>Registers::switch_to()</code></a>
должен:</p>
<ul>
<li>Сохранить регистры <code>RBX</code> и <code>RBP</code> в стеке ядра.</li>
<li>Сохранить адрес <code>registers</code> в стеке.</li>
<li>Записать текущее состояние стека ядра. В следующей лабораторке мы реализуем это более продвинутым способом. Пока же предлагается положить <code>RSP</code> на стек. После чего сохранить новый указатель на стек, который фактически будет указывать на это сохранённое значение <code>RSP</code>, в базу регистра <code>FS</code>. Это можно сделать с помощью инструкции <a href="https://www.felixcloutier.com/x86/wrmsr">wrmsr</a> процессора. Для неё нужно записать новое значение <code>RSP</code> в регистровую пару <code>EDX:EAX</code> — младшие 32 бита <code>RSP</code> в <code>EAX</code>, а старшие 32 бита <code>RSP</code> в <code>EDX</code>. А также нужно записать идентификатор базы <code>FS</code> как <a href="https://en.wikipedia.org/wiki/Model-specific_register">Model-specific register</a> — константу <a href="../../doc/x86/msr/constant.IA32_FS_BASE.html"><code>x86::msr::IA32_FS_BASE</code></a> — в регистр <code>ECX</code>. После чего вызвать <a href="https://www.felixcloutier.com/x86/wrmsr">wrmsr</a>. Теперь по логическому адресу <code>FS:0</code> будет доступно значение <code>RSP</code> ядра, сохранённое на его стеке.</li>
<li>Запретить прерывания инструкцией <a href="https://www.felixcloutier.com/x86/cli">cli</a> процессора. Мы дальше будем переключать стек и не хотим чтобы прерывание записало адрес возврата в неподходящее место.</li>
<li>Переключить стек, то есть регистр <code>RSP</code>, на заданный ему на вход адрес <code>registers</code>.</li>
<li>Восстановить регистры общего назначения с <code>RAX</code> по <code>R15</code> (кроме <code>RSP</code>) из стека. То есть, на самом деле из структуры <a href="../../doc/kernel/process/registers/struct.Registers.html"><code>Registers</code></a>. На которую он переключил свой стек.</li>
<li>Выполнить инструкцию <a href="https://www.felixcloutier.com/x86/iret:iretd:iretq"><code>iretq</code></a>, чтобы переключиться в контекст пользователя, заданный полем <a href="../../doc/kernel/process/registers/struct.Registers.html#structfield.user_context"><code>Registers::user_context</code></a>. Обратите внимание на суффикс <code>q</code> у <a href="https://www.felixcloutier.com/x86/iret:iretd:iretq"><code>iretq</code></a>. Если его не указать, ассемблер сгенерирует машинный код для другого режима работы процессора и до некоторого момента это будет не заметно, так как делать он будет почти то же самое. А потом в неожиданный момент всё сломается и найти такую ошибку будет тяжело.</li>
</ul>
<p>Последующие инструкции метода
<a href="../../doc/kernel/process/registers/struct.Registers.html#method.switch_to"><code>Registers::switch_to()</code></a>
будут выполняться при возвращении в режим ядра.
Начало этой части метода
<a href="../../doc/kernel/process/registers/struct.Registers.html#method.switch_to"><code>Registers::switch_to()</code></a>
помечено меткой <code>store_user_mode_context</code>.
Парный метод
<a href="../../doc/kernel/process/registers/struct.Registers.html#method.switch_from"><code>Registers::switch_from()</code></a>
просто прыгает на эту метку:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub(super) unsafe extern &quot;C&quot; fn switch_from() -&gt; ! {
    asm!(
        &quot;jmp store_user_mode_context&quot;,
        options(noreturn),
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Когда пользовательский код выполнит системный вызов и процессор окажется в режиме ядра, мы сможем вызвать
<a href="../../doc/kernel/process/registers/struct.Registers.html#method.switch_from"><code>Registers::switch_from()</code></a>
для прекращения исполнения кода пользователя и возврата ровно в тот контекст ядра, который выполнил вызов
<a href="../../doc/kernel/process/registers/struct.Registers.html#method.switch_to"><code>Registers::switch_to()</code></a>.
Например, это может быть контекст планировщика, который продолжит свой цикл исполнения, выберет следующий процесс и переключится уже в него.</p>
<p>Итак, после метки <code>store_user_mode_context</code> метод
<a href="../../doc/kernel/process/registers/struct.Registers.html#method.switch_to"><code>Registers::switch_to()</code></a>
должен:</p>
<ul>
<li>Вспомнить состояние стека ядра. Его можно прочитать по логическому адресу <code>FS:0</code>, так как мы ранее настроили базу <code>FS</code> на то место стека, куда сохранили <code>RSP</code>. Не пытайтесь прочитать из <code>FS</code> инструкцией <a href="https://www.felixcloutier.com/x86/rdmsr">rdmsr</a>, так как это испортит регистры пространства пользователя до того как нам есть куда их сохранить. Если бы мы могли прочитать из <code>FS</code> таким способом, записывать <code>RSP</code> на стек было бы не нужно. Но этот способ нам тут не подходит. Единственное, что мы можем сделать — фактически разыменовать <code>FS</code> читая по логическому адресу <code>FS:0</code>. В котором <code>FS</code> задаёт сегмент, а <code>0</code> — смещение.</li>
<li>Восстановить из стека ядра сохранённый адрес <code>registers</code>.</li>
<li>Переключить стек на этот адрес плюс суммарный размер регистров общего назначения <code>user_registers_size = const mem::size_of::&lt;Registers&gt;() - mem::size_of::&lt;ModeContext&gt;()</code>.</li>
<li>Записать в стек, то есть на самом деле в заданную на вход структуру <a href="../../doc/kernel/process/registers/struct.Registers.html"><code>Registers</code></a>, регистры общего назначения с <code>R15</code> по <code>RAX</code>. В обратном порядке, так как инструкции <code>push</code> и <code>pop</code> должны образовывать правильную скобочную последовательность с именами регистров в качестве типов скобок.</li>
<li>Переключить регистр <code>RSP</code> на стек ядра.</li>
<li>Разрешить прерывания инструкцией <a href="https://www.felixcloutier.com/x86/sti">sti</a> процессора. Мы вернулись на стек ядра и теперь безопасно получить прерывание, что приведёт к записи адреса возврата на стек.</li>
<li>Вытолкнуть из стека ядра сохранённый там адрес <code>registers</code>. Неважно куда, он больше не понадобится.</li>
<li>Восстановить регистры <code>RBX</code> и <code>RBP</code>, помня про правильную скобочную последовательность.</li>
</ul>
<p>Не стоит смешивать в одном макросе <code>asm!()</code> автоматическое выделение регистра компилятором — <code>in(reg)</code>, —
и явное использование фиксированного регистра в какой-либо инструкции вами самостоятельно.
Компилятор не парсит ассемблер и не знает что вы какие-то регистры в нём явно используете.
И, аллоцируя регистр в <code>in(reg)</code>, не может проверить коллизии.
А при коллизии вам гарантируется сложная и продолжительная отладка.
Ещё один источник проблем —
модификация регистра, который вы указали в <code>in(...)</code>, но не указали в <code>lateout(...)</code>.
Из <a href="https://doc.rust-lang.org/nightly/reference/inline-assembly.html#operand-type">документации</a>:</p>
<blockquote>
<p><code>in(&lt;reg&gt;) &lt;expr&gt;</code></p>
<ul>
<li>…</li>
<li>The allocated register must contain the same value at the end of the asm code (except if a <code>lateout</code> is allocated to the same register).</li>
</ul>
</blockquote>
<p>При желании вы можете отступить от предложенной схемы и реализовать любой другой работающий вариант.
Например, регистры общего назначения можно сохранять и восстанавливать командами
<a href="https://www.felixcloutier.com/x86/mov"><code>mov</code></a>.</p>
<blockquote>
<p>Вместо запрета прерываний на время манипуляций со стеком ядра можно было бы
выделить для всех прерываний отдельный стек.
Такой стек должен был бы быть собственным у каждого процессора.
То есть, понадобилось бы сделать каждому процессору свою таблицу прерываний
<a href="../../doc/kernel/interrupts/struct.IDT.html"><code>kernel::interrupts::IDT</code></a>.</p>
</blockquote>
<h3 id="Логирование-в-режиме-пользователя"><a class="header" href="#Логирование-в-режиме-пользователя">Логирование в режиме пользователя</a></h3>
<p>Учтите, что в режиме пользователя структурированное логирование макросами библиотеки
<a href="https://docs.rs/tracing/">tracing</a> —
<code>info!()</code>, <code>debug!()</code> и т.д., пока работать не будет.
В следующей задаче мы сделаем ему временную замену — системный вызов <code>log_value()</code>.
А чтобы заработало привычное структурированное логирование, нужно сделать
<a href="https://sergey-v-galtsev.github.io/labs-description/lab/book/5-um-1-ring-buffer.html">первую часть пятой лабораторки</a>.</p>
<h3 id="Проверьте-себя-7"><a class="header" href="#Проверьте-себя-7">Проверьте себя</a></h3>
<p>Запустите тест <code>3-process-3-user-mode</code> из файла
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/3-process-3-user-mode.rs"><code>kernel/tests/3-process-3-user-mode.rs</code></a>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 3-process-3-user-mode)
...
3_process_3_user_mode::user_mode_page_fault--------------------
19:22:04 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
19:22:04 0 I duplicate; address_space = &quot;process&quot; @ 0p7F1C000
19:22:04 0 I switch to; address_space = &quot;process&quot; @ 0p7F1C000
19:22:04 0 D extend mapping; block = [0v10000000, 0v100074E4), size 29.223 KiB; page_block = [0v10000000, 0v10008000), size 32.000 KiB; flags =   R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
19:22:04 0 D elf loadable program header; file_block = [0v201CE2, 0v2091C6), size 29.223 KiB; memory_block = [0v10000000, 0v100074E4), size 29.223 KiB; flags =   R
19:22:04 0 D extend mapping; block = [0v10008000, 0v10052E9D), size 299.653 KiB; page_block = [0v10008000, 0v10053000), size 300.000 KiB; flags = X R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
19:22:04 0 D elf loadable program header; file_block = [0v2091D2, 0v254B7F), size 302.419 KiB; memory_block = [0v100074F0, 0v10052E9D), size 302.419 KiB; flags = X R
19:22:04 0 D elf loadable program header; file_block = [0v254B82, 0v254C72), size 240 B; memory_block = [0v10052EA0, 0v10052F90), size 240 B; flags =  WR
19:22:04 0 D extend mapping; block = [0v10053000, 0v10058FF0), size 23.984 KiB; page_block = [0v10053000, 0v10059000), size 24.000 KiB; flags =  WR; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
19:22:04 0 D elf loadable program header; file_block = [0v254C72, 0v25ACAA), size 24.055 KiB; memory_block = [0v10052F90, 0v10058FF0), size 24.094 KiB; flags =  WR
19:22:04 0 I switch to; address_space = &quot;base&quot; @ 0p1000
19:22:04 0 I loaded ELF file; context = { rip: 0v10007A90, rsp: 0v7F7FFFFFF000 }; file_size = 5.303 MiB; process = { pid: &lt;current&gt;, address_space: &quot;process&quot; @ 0p7F1C000, { rip: 0v10007A90, rsp: 0v7F7FFFFFF000 } }
19:22:04 0 I user process page table entry; entry_point = 0v10007A90; frame = Frame(32511 @ 0p7EFF000); flags = PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED | DIRTY
19:22:04 0 D process_frames = 130
19:22:04 0 I switch to; address_space = &quot;process&quot; @ 0p7F1C000
19:22:04 0 D entering the user mode; pid = &lt;current&gt;; registers = { rax: 0x0, rdi: 0x7F7FFFFED000, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v10007A90, ss:rsp: 0x001B:0v7F7FFFFFF000, rflags:  } }
19:22:04 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10007A31, ss:rsp: 0x001B:0v0, rflags: ZF PF }
19:22:05 0 D leaving the user mode; pid = &lt;current&gt;
19:22:05 0 I switch to; address_space = &quot;base&quot; @ 0p1000
19:22:05 0 I drop the current address space; address_space = &quot;process&quot; @ 0p7F1C000; switch_to = &quot;base&quot; @ 0p1000
3_process_3_user_mode::user_mode_page_fault----------- [passed]

3_process_3_user_mode::user_context_saved----------------------
19:22:05 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
19:22:05 0 I duplicate; address_space = &quot;process&quot; @ 0p7F1C000
19:22:05 0 I switch to; address_space = &quot;process&quot; @ 0p7F1C000
19:22:05 0 D extend mapping; block = [0v10000000, 0v100074E4), size 29.223 KiB; page_block = [0v10000000, 0v10008000), size 32.000 KiB; flags =   R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
19:22:05 0 D elf loadable program header; file_block = [0v201CE2, 0v2091C6), size 29.223 KiB; memory_block = [0v10000000, 0v100074E4), size 29.223 KiB; flags =   R
19:22:05 0 D extend mapping; block = [0v10008000, 0v10052E9D), size 299.653 KiB; page_block = [0v10008000, 0v10053000), size 300.000 KiB; flags = X R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
19:22:05 0 D elf loadable program header; file_block = [0v2091D2, 0v254B7F), size 302.419 KiB; memory_block = [0v100074F0, 0v10052E9D), size 302.419 KiB; flags = X R
19:22:05 0 D elf loadable program header; file_block = [0v254B82, 0v254C72), size 240 B; memory_block = [0v10052EA0, 0v10052F90), size 240 B; flags =  WR
19:22:05 0 D extend mapping; block = [0v10053000, 0v10058FF0), size 23.984 KiB; page_block = [0v10053000, 0v10059000), size 24.000 KiB; flags =  WR; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
19:22:05 0 D elf loadable program header; file_block = [0v254C72, 0v25ACAA), size 24.055 KiB; memory_block = [0v10052F90, 0v10058FF0), size 24.094 KiB; flags =  WR
19:22:05 0 I switch to; address_space = &quot;base&quot; @ 0p1000
19:22:05 0 I loaded ELF file; context = { rip: 0v10007A90, rsp: 0v7F7FFFFFF000 }; file_size = 5.303 MiB; process = { pid: &lt;current&gt;, address_space: &quot;process&quot; @ 0p7F1C000, { rip: 0v10007A90, rsp: 0v7F7FFFFFF000 } }
19:22:05 0 I user process page table entry; entry_point = 0v10007A90; frame = Frame(32532 @ 0p7F14000); flags = PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED | DIRTY
19:22:05 0 D process_frames = 130
19:22:05 0 I switch to; address_space = &quot;process&quot; @ 0p7F1C000
19:22:05 0 D entering the user mode; pid = &lt;current&gt;; registers = { rax: 0x0, rdi: 0x7F7FFFFED000, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v10007A90, ss:rsp: 0x001B:0v7F7FFFFFF000, rflags:  } }
19:22:05 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10007A31, ss:rsp: 0x001B:0v0, rflags: ZF PF }
19:22:05 0 D leaving the user mode; pid = &lt;current&gt;
19:22:05 0 D user_registers = [77701, 77702, 77703, 77704, 77705, 77706, 77707, 77708, 77709, 77710, 77711, 77712, 77713, 77714, 77715]
19:22:05 0 I switch to; address_space = &quot;base&quot; @ 0p1000
19:22:05 0 I drop the current address space; address_space = &quot;process&quot; @ 0p7F1C000; switch_to = &quot;base&quot; @ 0p1000
3_process_3_user_mode::user_context_saved------------- [passed]
</code></pre>
<p>Если вы получаете Page Fault в ядре при доступе к адресу <code>0vFFFFFFFFFFFFFFF8</code>:</p>
<pre><code>19:53:29 0 E kernel mode trap; trap = &quot;Page Fault&quot;; number = 14; info = { code: 0b10 = non-present page | write | kernel, address: 0vFFFFFFFFFFFFFFF8 }; context = { mode: kernel, cs:rip: 0x0008:0v76FF50, ss:rsp: 0x0010:0v0, rflags: IF }
panicked at 'kernel mode trap #14 - Page Fault
ModeContext { rip: Virt(0v76FF50), cs: 8, rflags: RFlags(514), rsp: Virt(0v0), ss: 16 }', kernel/src/interrupts.rs:408:13
</code></pre>
<p>Это означает, что прерывания разрешаются в неправильный момент, когда ядро ещё не переключилось на свой стек.
В этом логе видно, что <code>RSP</code> нулевой — <code>ss:rsp: 0x0010:0v0</code>.</p>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-10"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-10">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/process/registers.rs |   63 ++++++++++++++++++++++++++++++++++++++--
 1 file changed, 60 insertions(+), 3 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Поддержка-системных-вызовов"><a class="header" href="#Поддержка-системных-вызовов">Поддержка системных вызовов</a></h2>
<p>Для системных вызовов Nikka использует инструкции
<a href="https://wiki.osdev.org/SYSENTER#AMD:_SYSCALL.2FSYSRET"><code>syscall</code> и <code>sysret</code></a>,
<a href="https://en.wikipedia.org/wiki/X86_instruction_listings#Added_with_AMD_K6">добавленные AMD</a>
специально для <a href="https://en.wikipedia.org/wiki/Long_mode">64-битного режима</a>.
Они <a href="https://en.wikipedia.org/wiki/X86-64#Recent_implementations">работают в этом режиме и на процессорах Intel</a>:</p>
<blockquote>
<p>Intel 64 allows SYSCALL/SYSRET only in 64-bit mode (not in compatibility mode), and allows SYSENTER/SYSEXIT in both modes.
AMD64 lacks SYSENTER/SYSEXIT in both sub-modes of long mode.</p>
</blockquote>
<p>То есть, в <a href="https://en.wikipedia.org/wiki/Long_mode">64-битном режиме</a>
инструкции <a href="https://wiki.osdev.org/SYSENTER#AMD:_SYSCALL.2FSYSRET"><code>syscall</code> и <code>sysret</code></a>
переносимы, в отличие от похожих инструкций
<a href="https://wiki.osdev.org/SYSENTER#INTEL:_SYSENTER.2FSYSEXIT"><code>sysenter</code> и <code>sysexit</code></a>.</p>
<p>Прежде чем приступать, изучите документацию производителя процессоров на нужные инструкции:</p>
<ul>
<li><a href="https://www.felixcloutier.com/x86/syscall"><code>syscall</code></a> и</li>
<li><a href="https://www.felixcloutier.com/x86/sysret"><code>sysretq</code></a>,</li>
<li>а также <a href="https://www.felixcloutier.com/x86/sti"><code>sti</code></a>.</li>
</ul>
<h3 id="Задача-4--поддержка-системных-вызовов"><a class="header" href="#Задача-4--поддержка-системных-вызовов">Задача 4 — поддержка системных вызовов</a></h3>
<h4 id="Инициализация-системных-вызовов"><a class="header" href="#Инициализация-системных-вызовов">Инициализация системных вызовов</a></h4>
<p>Реализуйте <a href="../../doc/kernel/process/syscall/fn.init.html">функцию</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn kernel::process::syscall::init()
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/syscall.rs"><code>kernel/src/process/syscall.rs</code></a>.</p>
<p>Она подготавливает процессор к выполнению инструкций
<a href="https://wiki.osdev.org/SYSENTER#AMD:_SYSCALL.2FSYSRET"><code>syscall</code> и <code>sysret</code></a>:</p>
<ul>
<li>Включает бит <a href="../../doc/x86_64/registers/model_specific/struct.EferFlags.html#associatedconstant.SYSTEM_CALL_EXTENSIONS"><code>x86_64::registers::model_specific::EferFlags::SYSTEM_CALL_EXTENSIONS</code></a> в регистре <a href="../../doc/x86_64/registers/model_specific/struct.Efer.html"><code>x86_64::registers::model_specific::Efer</code></a>. А остальные биты оставляет в исходном состоянии.</li>
<li>Записывает в регистр <a href="../../doc/x86_64/registers/model_specific/struct.Star.html"><code>x86_64::registers::model_specific::Star</code></a> методом <a href="../../doc/x86_64/registers/model_specific/struct.Star.html#method.write"><code>Star::write()</code></a> селекторы кода и данных для режимов пользователя и ядра — <a href="../../doc/kernel/memory/gdt/struct.SmpGdt.html#method.user_code"><code>kernel::memory::gdt::Gdt::user_code()</code></a>, <a href="../../doc/kernel/memory/gdt/struct.SmpGdt.html#method.user_data"><code>kernel::memory::gdt::Gdt::user_data()</code></a>, <a href="../../doc/kernel/memory/gdt/struct.SmpGdt.html#method.kernel_code"><code>kernel::memory::gdt::Gdt::kernel_code()</code></a>, <a href="../../doc/kernel/memory/gdt/struct.SmpGdt.html#method.kernel_data"><code>kernel::memory::gdt::Gdt::kernel_data()</code></a>.</li>
<li>Записывает в регистр <a href="../../doc/x86_64/registers/model_specific/struct.LStar.html"><code>x86_64::registers::model_specific::LStar</code></a> виртуальный адрес функции <a href="../../doc/kernel/process/syscall/fn.syscall_trampoline.html"><code>kernel::process::syscall::syscall_trampoline()</code></a>.</li>
<li>Записывает в регистр <a href="../../doc/x86_64/registers/model_specific/struct.SFMask.html"><code>x86_64::registers::model_specific::SFMask</code></a> маску для регистра флагов <code>RFLAGS</code>, которая определяет какие флаги в <code>RFLAGS</code> будут сброшены при входе в системный вызов. Нужно сбросить флаг прерываний. Так как если прерывание возникнет сразу после переключения в ядро и до того как ядро переключится в собственный стек, процессор сохранит контекст прерывания на пользовательский стек. А ему, как мы помним, доверять нельзя. Также предлагается сбросить все остальные флаги, просто для определённости состояния <code>RFLAGS</code> в момент системного вызова.</li>
</ul>
<h4 id="Диспетчеризация-системных-вызовов"><a class="header" href="#Диспетчеризация-системных-вызовов">Диспетчеризация системных вызовов</a></h4>
<p>Реализуйте на ассемблере <a href="../../doc/kernel/process/syscall/fn.syscall_trampoline.html">функцию</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; fn syscall_trampoline() -&gt; !
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/syscall.rs"><code>kernel/src/process/syscall.rs</code></a>.</p>
<p>Она получает управление при выполнении инструкции <code>syscall</code> и должна передать управление в написанную на Rust
<a href="../../doc/kernel/process/syscall/fn.syscall.html">функцию</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
extern &quot;C&quot; fn kernel::process::syscall::syscall(
    // https://wiki.osdev.org/System_V_ABI#x86-64:
    // Parameters to functions are passed in the registers rdi, rsi, rdx, rcx, r8, r9, and further values are passed on the stack in reverse order.
    number: usize, // rdi
    arg0: usize,   // rsi
    arg1: usize,   // rdx
    rip: Virt,     // rcx
    rsp: Virt,     // r8
    arg2: usize,   // r9
    // Stack, push in reverse order.
    arg3: usize,
    arg4: usize,
) -&gt; !
<span class="boring">}
</span></code></pre></pre>
<p>Указание
<a href="https://doc.rust-lang.ru/book/ch19-01-unsafe-rust.html#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-extern-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9-%D0%B4%D0%BB%D1%8F-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0-%D0%B2%D0%BD%D0%B5%D1%88%D0%BD%D0%B5%D0%B3%D0%BE-%D0%BA%D0%BE%D0%B4%D0%B0"><code>extern &quot;C&quot;</code></a>
в её сигнатуре означает, что она подчиняется соглашениям
<a href="https://wiki.osdev.org/System_V_ABI#x86-64">C ABI</a> текущей архитектуры.
Подробно про них можно посмотреть в
<a href="https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-draft.pdf">System V Application Binary InterfaceAMD64 Architecture Processor Supplement</a>.</p>
<p>Аннотация
<a href="https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute"><code>#[no_mangle]</code></a>
означает, что имя функции, доступное в ассемблере будет как написано в коде — <code>syscall</code>.
Иначе оно будет искажено для уникализации, — чтобы не совпадать с таким же именем в другом модуле.
(В C++ искажение имени учитывает ещё и типы аргументов для реализации перегрузки функций.)
Без такой аннотации в ассемблере имя <code>syscall()</code> было бы похоже на
<code>_ZN6kernel7process7syscall7syscall17hc1ae395af68eb49cE</code>.
Программа <code>rustfilt</code> позволяет восстановить искажённое имя:</p>
<pre><code class="language-console">$ rustfilt _ZN6kernel7process7syscall7syscall17hc1ae395af68eb49cE
kernel::process::syscall::syscall
</code></pre>
<p>Чтобы не писать в ассемблере что-нибудь вроде
<code>call _ZN6kernel7process7syscall7syscall17hc1ae395af68eb49cE</code>,
используем аннотацию
<a href="https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute"><code>#[no_mangle]</code></a>.
Но тогда мы сами должны гарантировать уникальность имени, как в ассемблере или C.</p>
<p>На момент входа в <a href="../../doc/kernel/process/syscall/fn.syscall_trampoline.html"><code>syscall_trampoline()</code></a>
регистр <code>RSP</code> указывает на стек пользователя.
Мы не можем ему доверять, — код режима пользователя мог его переполнить, неправильно выровнять, поместить на недоступный для пользователя адрес, например внутрь данных ядра.
Поэтому прежде чем пользоваться стеком,
<a href="../../doc/kernel/process/syscall/fn.syscall_trampoline.html"><code>syscall_trampoline()</code></a>
переключается в стек ядра.
Адрес пользовательского стека — старое значение <code>RSP</code> — она должна передать в функцию
<a href="../../doc/kernel/process/syscall/fn.syscall.html"><code>syscall()</code></a>
в соответствующем <a href="https://wiki.osdev.org/System_V_ABI#x86-64">x86-64 C ABI</a> регистре.</p>
<p>Помните, что благодаря маске в регистре
<a href="../../doc/x86_64/registers/model_specific/struct.SFMask.html"><code>x86_64::registers::model_specific::SFMask</code></a>,
процессор выключил прерывания в момент выполнения инструкции
<a href="https://www.felixcloutier.com/x86/syscall"><code>SYSCALL</code></a>?
Nikka сама по себе не сломается от получения прерывания в момент выполнения системного вызова,
и мы уже на стеке ядра — самое время включить прерывания с помощью инструкции
<a href="https://www.felixcloutier.com/x86/sti"><code>STI</code></a>.
Если же не включить прерывания, можно например пропустить очередной тик RTC, пока будет выполняться системный вызов.
И тогда в логе может быть неверное время.
Например, тут последовательные строки логирования выглядят как будто между ними прошло 15-16 секунд:</p>
<pre><code class="language-console">10:48:24 0 D entering the user mode; pid = 0:4; registers = { rax: 0x0, rdi: 0x7F7FFFFAD000, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v10007550, ss:rsp: 0x001B:0v7F7FFFFFF000, rflags: IF } }
10:48:40.001 0 D leaving the user mode; pid = 0:4
</code></pre>
<p>А на самом деле было пропущено много RTC прерываний.
Вообще, после инициализации RTC было получено только первое прерывание в 10:48:24.
И подсистема времени всё ещё ориентируется на одну единственную базовую точку в
<a href="../../doc/ku/info/struct.SystemInfo.html#structfield.rtc"><code>SystemInfo::rtc</code></a>,
которая этому первому прерыванию соответствует.
И только в 10:48:40 было получено второе прерывание.
А все промежуточные пропали из-за того, что во время исполнения системных вызовов прерывания были отключены.</p>
<p>То что прерывания запрещены до переключения стека, проверяется в тесте <code>3-process-4-syscall</code> из файла
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/3-process-4-syscall.rs"><code>kernel/tests/3-process-4-syscall.rs</code></a>
следующим образом.
Код пользователя из файла
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/user/exit/src/main.rs"><code>user/exit/src/main.rs</code></a>
запускается при запрещённых прерываниях.
Он ждёт 100 миллисекунд, этого должно быть достаточно чтобы накопилось несколько тиков
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">PIT</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Wait for some PIT ticks so an interrupt will be pending on the return to the kernel mode.
// This test is run with interrupts disabled.
// If the kernel enables interrupts before switching the stack it will receive a Page Fault.
time::delay(Duration::milliseconds(100));
<span class="boring">}
</span></code></pre></pre>
<p>А значит, появился сигнал о прерывании.
После этого код пользователя записывает <code>0</code> в <code>RSP</code> и делает системный вызов.
Начинает исполняться код ядра.
И как только он разрешит прерывания, то сразу же получит прерывание от
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">PIT</a>.</p>
<p>Если стек ещё не был переключён, это приведёт к Page Fault из-за того что код пользователя испортил <code>RSP</code>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 3-process-4-syscall)
...
3_process_4_syscall::syscall_exit-----------------------------
...
19:32:14 0 D entering the user mode; pid = 0:0; registers = { rax: 0x0, rdi: 0x7F7FFFFEB000, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v10007BA0, ss:rsp: 0x001B:0v7F7FFFFFF000, rflags:  } }
19:32:14 0 D trap = &quot;Page Fault&quot;; context = { mode: kernel, cs:rip: 0x0008:0v8648E4, ss:rsp: 0x0010:0v0, rflags: IF }; info = { code: 0b11 = protection violation | write | kernel, address: 0vFFFFFFFFFFFFFFF8 }
19:32:14 0 E kernel mode trap; trap = &quot;Page Fault&quot;; number = 14; info = { code: 0b11 = protection violation | write | kernel, address: 0vFFFFFFFFFFFFFFF8 }; context = { mode: kernel, cs:rip: 0x0008:0v8648E4, ss:rsp: 0x0010:0v0, rflags: IF }
panicked at 'kernel mode trap #14 - Page Fault, context: { mode: kernel, cs:rip: 0x0008:0v8648E4, ss:rsp: 0x0010:0v0, rflags: IF }', kernel/src/interrupts.rs:411:13
--------------------------------------------------- [failed]
</code></pre>
<p>Также учтите, что если вы сохранили <code>RSP</code> ядра и настроили базу сегментного регистра <code>FS</code> на него,
как предлагалось в
<a href="../../lab/book/3-process-3-user-mode.html#%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-3--%D0%BF%D0%B5%D1%80%D0%B5%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0-%D0%B2-%D1%80%D0%B5%D0%B6%D0%B8%D0%BC-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F-%D0%B8-%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%82-%D0%B8%D0%B7-%D0%BD%D0%B5%D0%B3%D0%BE">предыдущей задаче</a>,
то восстановление <code>RSP</code> из <code>FS:0</code> приведёт к записи в <code>RSP</code> состояния до сохранения значения <code>RSP</code> на стеке.
То есть, фактически вытолкнет <code>RSP</code> со стека.
Но он нам ещё понадобится.
Поэтому после этого действия нужно либо записать <code>RSP</code> на стек ещё раз,
либо просто отступить в стеке на соответствующее количество байт.
И только после этого уже можно писать в стек часть аргументов функции
<a href="../../doc/kernel/process/syscall/fn.syscall.html"><code>syscall()</code></a>.
Если же вы этого не сделаете, то тест <code>3-process-4-syscall</code> упадёт сразу же после выполнения
системного вызова, когда
<a href="../../doc/kernel/process/registers/struct.Registers.html#method.switch_to"><code>Registers::switch_to()</code></a>
тоже захочет взять из <code>FS:0</code> сохранённый им указатель на стек ядра:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 3-process-4-syscall)
...
3_process_4_syscall::syscall_exit-----------------------------
...
20:46:18 0 I syscall = &quot;exit&quot;; pid = 0:0; code = 3141592653589793238; reason = None
20:46:18 0 D trap = &quot;Page Fault&quot;; context = { mode: kernel, cs:rip: 0x0008:0vCE36E6, ss:rsp: 0x0010:0v0, rflags: IF ZF PF }; info = { code: 0b0 = non-present page | read | kernel, address: 0v0 }
20:46:18 0 E kernel mode trap; trap = &quot;Page Fault&quot;; number = 14; info = { code: 0b0 = non-present page | read | kernel, address: 0v0 }; context = { mode: kernel, cs:rip: 0x0008:0vCE36E6, ss:rsp: 0x0010:0v0, rflags: IF ZF PF }
panicked at 'kernel mode trap #14 - Page Fault, context: { mode: kernel, cs:rip: 0x0008:0vCE36E6, ss:rsp: 0x0010:0v0, rflags: IF ZF PF }', kernel/src/interrupts.rs:411:13
--------------------------------------------------- [failed]
</code></pre>
<p>Это артефакт временного решения, который мы исправим в следующей лабораторке.</p>
<p>После переключения стека, аргументы функции
<a href="../../doc/kernel/process/syscall/fn.syscall.html"><code>syscall()</code></a>,
которые по <a href="https://wiki.osdev.org/System_V_ABI#x86-64">x86-64 C ABI</a>
должны передаваться через стек,
<a href="../../doc/kernel/process/syscall/fn.syscall_trampoline.html"><code>syscall_trampoline()</code></a>
должна записать в стек.
После этого она должна вызвать функцию
<a href="../../doc/kernel/process/syscall/fn.syscall.html"><code>syscall()</code></a>.
Так как
<a href="../../doc/kernel/process/syscall/fn.syscall.html"><code>syscall()</code></a>
не возвращается, сохранять адрес возврата в стеке инструкцией
<a href="https://www.felixcloutier.com/x86/call"><code>call</code></a>
не обязательно, можно сделать
<a href="https://www.felixcloutier.com/x86/jmp"><code>jmp</code></a>.
Но если вы предпочли вариант с
<a href="https://www.felixcloutier.com/x86/jmp"><code>jmp</code></a>,
то скорректируйте значение регистра <code>RSP</code>.
Так как вызываемая функция при поиске аргументов, передаваемых через стек,
пропускает в нём место с адресом возврата.
То есть, считает что адрес возврата был сохранён инструкцией
<a href="https://www.felixcloutier.com/x86/call"><code>call</code></a>.</p>
<p>Реализуйте функцию <a href="../../doc/kernel/process/syscall/fn.syscall.html"><code>syscall()</code></a>.
Она выполняет диспетчеризацию системных вызовов по аргументу <code>number</code>,
передавая в реализующие конкретные системные вызовы функции нужную часть аргументов <code>arg0</code>–<code>arg4</code>.
Пока что нам хватит системных вызовов</p>
<ul>
<li><a href="../../doc/kernel/process/syscall/fn.exit.html"><code>kernel::process::syscall::exit()</code></a> с номером <a href="../../doc/ku/process/syscall/struct.Syscall.html#associatedconstant.EXIT"><code>ku::process::syscall::Syscall::EXIT</code></a> и</li>
<li><a href="../../doc/kernel/process/syscall/fn.log_value.html"><code>kernel::process::syscall::log_value()</code></a> с номером <a href="../../doc/ku/process/syscall/struct.Syscall.html#associatedconstant.LOG_VALUE"><code>ku::process::syscall::Syscall::LOG_VALUE</code></a>.</li>
</ul>
<p>После выполнения функции, реализующей нужный системный вызов,
<a href="../../doc/kernel/process/syscall/fn.syscall.html"><code>syscall()</code></a>
передаёт управление в функцию
<a href="../../doc/kernel/process/syscall/fn.sysret.html"><code>kernel::process::syscall::sysret()</code></a>.</p>
<h4 id="Возврат-из-системного-вызова"><a class="header" href="#Возврат-из-системного-вызова">Возврат из системного вызова</a></h4>
<p>Реализуйте на ассемблере <a href="../../doc/kernel/process/syscall/fn.sysret.html">функцию</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn kernel::process::syscall::sysret(
    context: MiniContext,
    result: Result&lt;SyscallResult&gt;,
) -&gt; !
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/syscall.rs"><code>kernel/src/process/syscall.rs</code></a>.</p>
<p>Она</p>
<ul>
<li>Записывает результат системного вызова <code>result</code> в регистры общего назначения, например в <code>RAX</code>, <code>RDI</code>, <code>RSI</code>, и т.д. Обратите внимание, что признак и код ошибки, если <code>result</code> содержит ошибку, нужно записать в один из регистров — пользовательскому процессу он тоже важен.</li>
<li>Записывает в регистр <code>R11</code> состояние регистра флагов, которое должно быть в пространстве пользователя. Как минимум должен быть установлен <a href="../../doc/ku/process/registers/struct.RFlags.html#associatedconstant.INTERRUPT_FLAG"><code>RFlags::INTERRUPT_FLAG</code></a>, чтобы процесс не мог монополизировать процессор. Но пока что включение прерываний приведёт к нестабильности теста <code>3_process_4_syscall::syscall_log_value</code>. Поэтому предлагается отложить включение <a href="../../doc/ku/process/registers/struct.RFlags.html#associatedconstant.INTERRUPT_FLAG"><code>RFlags::INTERRUPT_FLAG</code></a> до следующей лабораторки, а пока выключить все флаги при возврате в режим пользователя — <a href="../../doc/ku/process/registers/struct.RFlags.html#method.default"><code>RFlags::default()</code></a>.</li>
<li>Записывает адрес возврата в код пользователя в регистр <code>RCX</code>. Функции <a href="../../doc/kernel/process/syscall/fn.syscall_trampoline.html"><code>syscall_trampoline()</code></a>/<a href="../../doc/kernel/process/syscall/fn.syscall.html"><code>syscall()</code></a> получили этот адрес в этом же регистре. И должны были его передать вместе с адресом стека пользователя в аргументе <code>context</code>.</li>
<li>Переключает регистр <code>RSP</code> на стек пользователя.</li>
<li>Зануляет все неиспользованные выше регистры общего назначения, чтобы предотвратить утечку информации из режима ядра в режим пользователя.</li>
<li>Выполняет инструкцию <a href="https://www.felixcloutier.com/x86/sysret"><code>sysretq</code></a>, которая передаёт управление в код пользователя в соответствии с настройками в регистрах <code>Star</code>, <code>R11</code> и <code>RCX</code>. Обратите внимание на суффикс <code>q</code> у <a href="https://www.felixcloutier.com/x86/sysret"><code>sysretq</code></a>. Если его не указать, ассемблер сгенерирует машинный код для другого режима работы процессора и до некоторого момента это будет не заметно, так как делать он будет почти то же самое. А потом в неожиданный момент всё сломается и найти такую ошибку будет тяжело.</li>
</ul>
<h4 id="Системный-вызов-exit"><a class="header" href="#Системный-вызов-exit">Системный вызов <code>exit</code></a></h4>
<p>Реализуйте <a href="../../doc/kernel/process/syscall/fn.exit.html">функцию</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn kernel::process::syscall::exit(
    process: MutexGuard&lt;Process&gt;,
    code: usize,
) -&gt; !
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/syscall.rs"><code>kernel/src/process/syscall.rs</code></a>.</p>
<p>Она выполняет системный вызов <code>exit(code)</code> с одним аргументом <code>code</code>.
Код можно, например, залогировать как
<a href="../../doc/ku/process/syscall/struct.ExitCode.html"><code>ku::process::syscall::ExitCode</code></a>.
Основная же работа этого системного вызова заключается в освобождении слота таблицы процессов методом
<a href="../../doc/kernel/process/table/struct.Table.html#method.free"><code>kernel::process::table::Table::free()</code></a>
и возврате в контекст ядра, из которого пользовательский процесс был запущен.
Это делается статическим методом
<a href="../../doc/kernel/process/process/struct.Process.html#method.sched_yield"><code>kernel::process::process::Process::sched_yield()</code></a>,
которые не возвращают управление, как и сама функция
<a href="../../doc/kernel/process/syscall/fn.exit.html"><code>kernel::process::syscall::exit()</code></a>.</p>
<p>Различие между
<a href="../../doc/kernel/process/process/struct.Process.html#method.leave_user_mode"><code>kernel::process::process::Process::leave_user_mode()</code></a>
и
<a href="../../doc/kernel/process/process/struct.Process.html#method.sched_yield"><code>kernel::process::process::Process::sched_yield()</code></a>
состоит в том, что первая сохраняет контекст пользователя.
Пользовательский код готов к системному вызову и тому что тот испортит регистры.
Поэтому контракт такой, что всё нужное ему состояние при системных вызовах он сохраняет сам.
А
<a href="../../doc/kernel/process/process/struct.Process.html#method.leave_user_mode"><code>kernel::process::process::Process::leave_user_mode()</code></a>
пригодится чтобы принудительно вытеснять процесс в произвольные моменты времени,
когда он к этому не готов.</p>
<h4 id="Системный-вызов-log_value"><a class="header" href="#Системный-вызов-log_value">Системный вызов <code>log_value</code></a></h4>
<p>Реализуйте <a href="../../doc/kernel/process/syscall/fn.log_value.html">функцию</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn kernel::process::syscall::log_value(
    process: MutexGuard&lt;Process&gt;,
    str_start: usize,
    str_end: usize,
    value: usize,
) -&gt; Result&lt;SyscallResult&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/syscall.rs"><code>kernel/src/process/syscall.rs</code></a>.</p>
<p>Это системный вызов, который принимает три аргумента.
В аргументах <code>str_start</code> и <code>str_end</code> передаётся начало и конец строки типа <a href="https://doc.rust-lang.org/nightly/core/primitive.str.html"><code>&amp;str</code></a>, а в <code>value</code> — произвольное число.</p>
<p>Для проверки корректности пары <code>str_start</code> и <code>str_end</code> вам пригодятся функции
<a href="../../doc/ku/memory/block/struct.Block.html#method.from_index"><code>ku::memory::block::Block::&lt;Virt&gt;::from_index()</code></a>,
<a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.check_permission"><code>kernel::memory::address_space::AddressSpace::check_permission()</code></a> и
<a href="https://doc.rust-lang.org/nightly/core/str/fn.from_utf8.html"><code>core::str::from_utf8()</code></a>.
Если хотя бы одна из них вернула ошибку, прокиньте её оператором <code>?</code> в функцию
<a href="../../doc/kernel/process/syscall/fn.syscall.html"><code>syscall()</code></a>,
чтобы она через функцию
<a href="../../doc/kernel/process/syscall/fn.sysret.html"><code>sysret()</code></a>
вернула эту ошибку в код пользователя.
Ошибку <a href="https://doc.rust-lang.org/nightly/core/str/struct.Utf8Error.html"><code>core::str::Utf8Error</code></a>
можно преобразовать, например, в
<a href="../../doc/ku/error/enum.Error.html#variant.InvalidArgument"><code>ku::error::Error::InvalidArgument</code></a>.</p>
<p>Далее системный вызов
<a href="../../doc/kernel/process/syscall/fn.log_value.html"><code>log_value()</code></a>
делает свою основную работу — логирует получившуюся строку и <code>value</code>.
Вам будет удобнее пользоваться
<a href="../../doc/kernel/process/syscall/fn.log_value.html"><code>log_value()</code></a>
, если вы залогируете <code>value</code> и в десятичном, и в шестнадцатеричном виде.
После этого системный вызов возвращает управление.</p>
<p>С помощью этого системного вызова тест <code>3-process-4-syscall</code> из файла
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/3-process-4-syscall.rs"><code>kernel/tests/3-process-4-syscall.rs</code></a>
проверяет возможность чтения системного времени из непривилегированного режима пользователя.
Код в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/user/log_value/src/main.rs"><code>user/log_value/src/main.rs</code></a>
выполняет вызов <code>time::now()</code> и логирует полученное количество секунд с unix-эпохи:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let now = time::now();
let timestamp = now.timestamp().try_into().unwrap();

if syscall::log_value(&quot;user space can read the system time&quot;, timestamp).is_err() {
    generate_page_fault();
}
<span class="boring">}
</span></code></pre></pre>
<p>Должно залогироваться что-то подобное:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 3-process-4-syscall)
...
3_process_4_syscall::syscall_log_value------------------------
...
04:30:41 0 D entering the user mode; pid = 0:0; registers = { rax: 0x0, rdi: 0x7F7FFFFEB000, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v10008BD0, ss:rsp: 0x001B:0v7F7FFFFFF000, rflags:  } }
04:30:41 0 I user space can read the system time; value = 1666585841; hex_value = 0x635614F1; pid = 0:0
...
</code></pre>
<p>Если в первой лабораторке вы попытались воспользоваться
<a href="https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf">приёмом “read-dont-modify-write”</a>,
то в режиме пользователя и вызов <code>time::delay()</code> из
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/user/exit/src/main.rs"><code>user/exit/src/main.rs</code></a>
и вызов <code>time::now()</code> из
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/user/log_value/src/main.rs"><code>user/log_value/src/main.rs</code></a>
получат Page Fault:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 3-process-4-syscall)
...
3_process_4_syscall::syscall_exit-----------------------------
...
04:55:08 0 D entering the user mode; pid = 0:0; registers = { rax: 0x0, rdi: 0x7F7FFFFEB000, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v10007BB0, ss:rsp: 0x001B:0v7F7FFFFFF000, rflags:  } }
04:55:08 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000E09C, ss:rsp: 0x001B:0v7F7FFFFFEA78, rflags: PF }; info = { code: 0b111 = protection violation | write | user, address: 0v7F7FFFFEC038 }
04:55:08 0 D leaving the user mode; pid = 0:0
panicked at 'if the Page Fault was in the kernel mode, probably the `syscall` instruction is not initialized or the kernel has not switched to its own stack; if it was in the user mode, maybe the time functions from the first lab use `read-dont-modify-write` construction', kernel/tests/3-process-4-syscall.rs:71:5
--------------------------------------------------- [failed]
</code></pre>
<h4 id="Пользовательская-сторона-системного-вызова"><a class="header" href="#Пользовательская-сторона-системного-вызова">Пользовательская сторона системного вызова</a></h4>
<p>Реализуйте <a href="../../doc/lib/syscall/fn.syscall.html">функцию</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lib::syscall::syscall(
    number: usize,
    arg0: usize,
    arg1: usize,
    arg2: usize,
    arg3: usize,
    arg4: usize,
) -&gt; Result&lt;(usize, usize)&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/user/lib/src/syscall.rs"><code>user/lib/src/syscall.rs</code></a>.</p>
<p>Она работает в режиме пользователя.
Её задача:</p>
<ul>
<li>Сохранить регистры <code>RBX</code> и <code>RBP</code> на стеке.</li>
<li>Передать свои аргументы через регистры, в которых их ожидают функции
<a href="../../doc/kernel/process/syscall/fn.syscall_trampoline.html"><code>kernel::process::syscall::syscall_trampoline()</code></a> и
<a href="../../doc/kernel/process/syscall/fn.syscall.html"><code>kernel::process::syscall::syscall()</code></a>.</li>
<li>Запустить инструкцию <a href="https://www.felixcloutier.com/x86/syscall"><code>syscall</code></a>, которая выполнит требуемый системный вызов.</li>
<li>Восстановить <code>RBX</code> и <code>RBP</code>.</li>
<li>Вернуть наружу результаты системного вызова из регистров, в которые их сохранила функция <a href="../../doc/kernel/process/syscall/fn.sysret.html"><code>kernel::process::syscall::sysret()</code></a>.</li>
<li>Неиспользованные регистры общего назначения она должна пометить как испорченные уже знакомой конструкцией <code>lateout(...) _,</code>.</li>
</ul>
<h3 id="Проверьте-себя-8"><a class="header" href="#Проверьте-себя-8">Проверьте себя</a></h3>
<p>Запустите тест <code>3-process-4-syscall</code> из файла
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/3-process-4-syscall.rs"><code>kernel/tests/3-process-4-syscall.rs</code></a>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 3-process-4-syscall)
...
3_process_4_syscall::syscall_exit-----------------------------
05:13:26 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
05:13:26 0 I duplicate; address_space = &quot;process&quot; @ 0p7F1B000
05:13:26 0 I switch to; address_space = &quot;process&quot; @ 0p7F1B000
05:13:26 0 D extend mapping; block = [0v10000000, 0v10007624), size 29.535 KiB; page_block = [0v10000000, 0v10008000), size 32.000 KiB; flags =   R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
05:13:26 0 D elf loadable program header; file_block = [0v201741, 0v208D65), size 29.535 KiB; memory_block = [0v10000000, 0v10007624), size 29.535 KiB; flags =   R
05:13:26 0 D extend mapping; block = [0v10008000, 0v100547AD), size 305.919 KiB; page_block = [0v10008000, 0v10055000), size 308.000 KiB; flags = X R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
05:13:26 0 D elf loadable program header; file_block = [0v208D71, 0v255EEE), size 308.372 KiB; memory_block = [0v10007630, 0v100547AD), size 308.372 KiB; flags = X R
05:13:26 0 D elf loadable program header; file_block = [0v255EF1, 0v255FE1), size 240 B; memory_block = [0v100547B0, 0v100548A0), size 240 B; flags =  WR
05:13:26 0 D extend mapping; block = [0v10055000, 0v1005AAC0), size 22.688 KiB; page_block = [0v10055000, 0v1005B000), size 24.000 KiB; flags =  WR; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
05:13:26 0 D elf loadable program header; file_block = [0v255FE1, 0v25C1D9), size 24.492 KiB; memory_block = [0v100548A0, 0v1005AAC0), size 24.531 KiB; flags =  WR
05:13:26 0 I switch to; address_space = &quot;base&quot; @ 0p1000
05:13:26 0 I loaded ELF file; context = { rip: 0v10007BA0, rsp: 0v7F7FFFFFF000 }; file_size = 5.372 MiB; process = { pid: &lt;current&gt;, address_space: &quot;process&quot; @ 0p7F1B000, { rip: 0v10007BA0, rsp: 0v7F7FFFFFF000 } }
05:13:26 0 I user process page table entry; entry_point = 0v10007BA0; frame = Frame(32507 @ 0p7EFB000); flags = PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED | DIRTY
05:13:26 0 I switch to; address_space = &quot;0:0&quot; @ 0p7F1B000
05:13:26 0 D entering the user mode; pid = 0:0; registers = { rax: 0x0, rdi: 0x7F7FFFFEB000, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v10007BA0, ss:rsp: 0x001B:0v7F7FFFFFF000, rflags:  } }
05:13:26 0 I syscall = &quot;exit&quot;; pid = 0:0; code = 3141592653589793238; reason = None
05:13:26 0 D leaving the user mode; pid = 0:0
3_process_4_syscall::syscall_exit-------------------- [passed]

3_process_4_syscall::syscall_log_value------------------------
05:13:27 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
05:13:27 0 I duplicate; address_space = &quot;process&quot; @ 0p7E93000
05:13:27 0 I switch to; address_space = &quot;process&quot; @ 0p7E93000
05:13:27 0 D extend mapping; block = [0v10000000, 0v100073F4), size 28.988 KiB; page_block = [0v10000000, 0v10008000), size 32.000 KiB; flags =   R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
05:13:27 0 D elf loadable program header; file_block = [0v760E00, 0v7681F4), size 28.988 KiB; memory_block = [0v10000000, 0v100073F4), size 28.988 KiB; flags =   R
05:13:27 0 D extend mapping; block = [0v10008000, 0v10052422), size 297.033 KiB; page_block = [0v10008000, 0v10053000), size 300.000 KiB; flags = X R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
05:13:27 0 D elf loadable program header; file_block = [0v768200, 0v7B3222), size 300.033 KiB; memory_block = [0v10007400, 0v10052422), size 300.033 KiB; flags = X R
05:13:27 0 D elf loadable program header; file_block = [0v7B3228, 0v7B3318), size 240 B; memory_block = [0v10052428, 0v10052518), size 240 B; flags =  WR
05:13:27 0 D extend mapping; block = [0v10053000, 0v10058680), size 21.625 KiB; page_block = [0v10053000, 0v10059000), size 24.000 KiB; flags =  WR; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
05:13:27 0 D elf loadable program header; file_block = [0v7B3318, 0v7B9458), size 24.312 KiB; memory_block = [0v10052518, 0v10058680), size 24.352 KiB; flags =  WR
05:13:27 0 I switch to; address_space = &quot;base&quot; @ 0p1000
05:13:27 0 I loaded ELF file; context = { rip: 0v10008BD0, rsp: 0v7F7FFFFFF000 }; file_size = 5.374 MiB; process = { pid: &lt;current&gt;, address_space: &quot;process&quot; @ 0p7E93000, { rip: 0v10008BD0, rsp: 0v7F7FFFFFF000 } }
05:13:27 0 I drop; address_space = &quot;0:0&quot; @ 0p7F1B000
05:13:27 0 I user process page table entry; entry_point = 0v10008BD0; frame = Frame(32370 @ 0p7E72000); flags = PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED | DIRTY
05:13:27 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E93000
05:13:27 0 D entering the user mode; pid = 0:0; registers = { rax: 0x0, rdi: 0x7F7FFFFEB000, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v10008BD0, ss:rsp: 0x001B:0v7F7FFFFFF000, rflags:  } }
05:13:27 0 I user space can read the system time; value = 1666588407; hex_value = 0x63561EF7; pid = 0:0
05:13:27 0 I ; value = 0; hex_value = 0x0; pid = 0:0
05:13:27 0 W syscall failed; syscall = Some(LOG_VALUE); number = 1; arg0 = 1; arg1 = 1; arg2 = 0; arg3 = 0; arg4 = 1099513729752; error = PermissionDenied
05:13:27 0 W syscall failed; syscall = Some(LOG_VALUE); number = 1; arg0 = 0; arg1 = 0; arg2 = 0; arg3 = 0; arg4 = 1099513729752; error = Null
05:13:27 0 W syscall failed; syscall = Some(LOG_VALUE); number = 1; arg0 = 268437376; arg1 = 1; arg2 = 0; arg3 = 0; arg4 = 1099513729752; error = InvalidArgument
05:13:27 0 W syscall failed; syscall = Some(LOG_VALUE); number = 1; arg0 = 65536; arg1 = 18446744069414584320; arg2 = 0; arg3 = 0; arg4 = 1099513729752; error = InvalidArgument
05:13:27 0 W syscall failed; syscall = Some(LOG_VALUE); number = 1; arg0 = 18446744073709486080; arg1 = 1048576; arg2 = 0; arg3 = 0; arg4 = 1099513729752; error = Overflow
05:13:27 0 I syscall = &quot;exit&quot;; pid = 0:0; code = 0; reason = Some(OK)
05:13:27 0 D leaving the user mode; pid = 0:0
3_process_4_syscall::syscall_log_value--------------- [passed]
05:13:27 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<p>Если вы увидите в тесте <code>3_process_4_syscall::syscall_log_value</code>
Page Fault на чтении <code>0v1</code> в режиме пользователя (не ядра),
это просто замена <code>panic!()</code> в коде пользователя в тесте.
В логе выше этого Page Fault должно быть написано, что ему не нравится,
если конечно <code>log_value()</code> хоть немного работает.
Например, — <code>expected Err(InvalidArgument), got Ok</code>:</p>
<pre><code class="language-console">...
06:00:33 0 I expected Err(InvalidArgument), got Ok; value = 0; hex_value = 0x0; pid = 0:0
06:00:33 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10012E32, ss:rsp: 0x001B:0v7F7FFFFFEA38, rflags: AF PF }; info = { address: 0v1, code: 0b100 = non-present page | read | user }
06:00:33 0 D leaving the user mode; pid = 0:0
panicked at 'the user mode code has detected an error in syscall::log_value() implementation', kernel/tests/3-process-4-syscall.rs:60:5
--------------------------------------------------- [failed]
</code></pre>
<p>Либо можно по коду теста в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/user/log_value/src/main.rs"><code>user/log_value/src/main.rs</code></a>
посмотреть какая проверка не прошла.</p>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-11"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-11">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/process/syscall.rs |  127 +++++++++++++++++++++++++++++++++++++++---
 user/lib/src/syscall.rs       |   54 +++++++++++++++++
 2 files changed, 173 insertions(+), 8 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Конкурентное-выполнение-задач"><a class="header" href="#Конкурентное-выполнение-задач">Конкурентное выполнение задач</a></h2>
<p>В этой лабораторке нужно будет реализовать конкурентное исполнение на уровне железа, то есть на разных процессорах одновременно.
А также, конкурентное исполнение пользовательских процессов на одном процессоре за счёт разделения его времени работы между ними.</p>
<h3 id="Ориентировочный-объём-работ-этой-лабораторки-3"><a class="header" href="#Ориентировочный-объём-работ-этой-лабораторки-3">Ориентировочный объём работ этой лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/memory/address_space.rs |   22 ++++++
 kernel/src/process/process.rs      |   24 ++++++-
 kernel/src/process/scheduler.rs    |   26 ++++++--
 kernel/src/process/syscall.rs      |   13 +++-
 kernel/src/process/table.rs        |  119 ++++++++++++++++++++++++++++++++++---
 kernel/src/smp/ap_init.rs          |   55 ++++++++++++++++-
 kernel/src/smp/cpu.rs              |   54 ++++++++++++++--
 kernel/src/smp/local_apic.rs       |   19 +++++
 ku/src/allocator/big.rs            |   87 +++++++++++++++++++++++----
 9 files changed, 374 insertions(+), 45 deletions(-)
</code></pre>
<p>Однако, будьте готовы к тому что на написание и отладку
<a href="../../lab/book/4-concurrency-1-smp-3-ap-init.html#%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-4--%D0%BF%D0%B5%D1%80%D0%B5%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-ap-%D0%B2-64-%D0%B1%D0%B8%D1%82%D0%BD%D1%8B%D0%B9-%D1%80%D0%B5%D0%B6%D0%B8%D0%BC">задачи 4</a>
может потребоваться много времени.
Также может потребоваться изучить ассемблер различных режимов работы процессора архитектуры
<a href="https://en.wikipedia.org/wiki/X86-64">x86-64</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Аллокатор-памяти-общего-назначения"><a class="header" href="#Аллокатор-памяти-общего-назначения">Аллокатор памяти общего назначения</a></h2>
<p>В этой части лабораторной работы вам нужно будет провязать
Rust’овский интерфейс аллокатора памяти общего назначения с реализованными во
<a href="../../lab/book/2-mm-0-intro.html">второй лабораторной работе</a>
методами адресного пространства
<a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html"><code>kernel::memory::address_space::AddressSpace</code></a>.</p>
<p>После этого станет доступна
<a href="https://doc.rust-lang.org/nightly/alloc/index.html"><code>alloc</code></a>
часть стандартной библиотеки.
И в последующих задачах лабораторки мы сможем использовать
<a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html"><code>alloc::vec::Vec</code></a>
<a href="https://doc.rust-lang.org/nightly/alloc/collections/vec_deque/struct.VecDeque.html"><code>alloc::collections::vec_deque::VecDeque</code></a>.
Что гораздо удобнее, чем методы семейства
<a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.map_slice"><code>AddressSpace::map_slice()</code></a>.</p>
<h3 id="Типажи-coreallocallocator-и-kuallocatordrydryallocator"><a class="header" href="#Типажи-coreallocallocator-и-kuallocatordrydryallocator">Типажи <a href="https://doc.rust-lang.org/nightly/core/alloc/trait.Allocator.html"><code>core::alloc::Allocator</code></a> и <a href="../../doc/ku/allocator/dry/trait.DryAllocator.html"><code>ku::allocator::dry::DryAllocator</code></a></a></h3>
<p>Прежде всего изучите Rust’овский интерфейс аллокатора памяти общего назначения — типаж
<a href="https://doc.rust-lang.org/nightly/core/alloc/trait.Allocator.html"><code>core::alloc::Allocator</code></a>.
Убедитесь, что вы понимаете:</p>
<ul>
<li>что такое <a href="https://doc.rust-lang.org/nightly/core/alloc/struct.Layout.html"><code>core::alloc::Layout</code></a>;</li>
<li>что такое <a href="https://doc.rust-lang.org/nightly/core/ptr/struct.NonNull.html"><code>core::ptr::NonNull</code></a>;</li>
<li>чем отличаются <code>NonNull&lt;u8&gt;</code> и <code>NonNull&lt;[u8]&gt;</code>.</li>
</ul>
<p>Также изучите типаж
<a href="../../doc/ku/allocator/dry/trait.DryAllocator.html"><code>ku::allocator::dry::DryAllocator</code></a>.
Он очень похож на
<a href="https://doc.rust-lang.org/nightly/core/alloc/trait.Allocator.html"><code>core::alloc::Allocator</code></a>,
и отличается только тем, что:</p>
<ul>
<li>Вместо двух методов <a href="https://doc.rust-lang.org/nightly/core/alloc/trait.Allocator.html#tymethod.allocate"><code>core::alloc::Allocator::allocate()</code></a> и <a href="https://doc.rust-lang.org/nightly/core/alloc/trait.Allocator.html#method.allocate_zeroed"><code>core::alloc::Allocator::allocate_zeroed()</code></a> имеет только один метод <a href="../../doc/ku/allocator/dry/trait.DryAllocator.html#tymethod.dry_allocate"><code>ku::allocator::dry::DryAllocator::dry_allocate()</code></a>, принимающий признак необходимости занулить память <a href="../../doc/ku/allocator/dry/enum.Initialize.html"><code>ku::allocator::dry::Initialize</code></a>. Это сделано, чтобы не дублировать код.</li>
<li>Аналогично вместо двух методов <a href="https://doc.rust-lang.org/nightly/core/alloc/trait.Allocator.html#method.grow"><code>core::alloc::Allocator::grow()</code></a> и <a href="https://doc.rust-lang.org/nightly/core/alloc/trait.Allocator.html#method.grow_zeroed"><code>core::alloc::Allocator::grow_zeroed()</code></a> имеет только один метод <a href="../../doc/ku/allocator/dry/trait.DryAllocator.html#tymethod.dry_grow"><code>ku::allocator::dry::DryAllocator::dry_grow()</code></a>.</li>
</ul>
<h3 id="Типаж-kuallocatorbigbigallocator"><a class="header" href="#Типаж-kuallocatorbigbigallocator">Типаж <a href="../../doc/ku/allocator/big/trait.BigAllocator.html"><code>ku::allocator::big::BigAllocator</code></a></a></h3>
<p>Мы не можем воспользоваться реализацией по умолчанию для методов
<a href="https://doc.rust-lang.org/nightly/core/alloc/trait.Allocator.html#method.grow"><code>Allocator::grow()</code></a>,
<a href="https://doc.rust-lang.org/nightly/core/alloc/trait.Allocator.html#method.grow_zeroed"><code>Allocator::grow_zeroed()</code></a> и
<a href="https://doc.rust-lang.org/nightly/core/alloc/trait.Allocator.html#method.shrink"><code>Allocator::shrink()</code></a>.
Нам придётся переопределять их поведение, потому что мы хотим сделать следующий трюк.
При переаллокации мы не будем копировать содержимое памяти.
А вместо этого поменяем отображение физических фреймов старого блока памяти, на место нового блока памяти.</p>
<p>Естественно, это пройдёт только для блоков памяти, которые выровнены на границы страниц.
Интерфейс аллокации таких блоков памяти задаётся типажом
<a href="../../doc/ku/allocator/big/trait.BigAllocator.html"><code>ku::allocator::big::BigAllocator</code></a>.</p>
<p>План состоит в том, чтобы</p>
<ul>
<li>Для <a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html"><code>kernel::memory::address_space::AddressSpace</code></a> реализовать типаж <a href="../../doc/ku/allocator/big/trait.BigAllocator.html"><code>ku::allocator::big::BigAllocator</code></a>. Этот пункт уже частично сделан, остался один метод — <a href="../../doc/ku/allocator/big/trait.BigAllocator.html#tymethod.remap"><code>BigAllocator::remap()</code></a></li>
<li>Для типажа <a href="../../doc/ku/allocator/big/trait.BigAllocator.html"><code>ku::allocator::big::BigAllocator</code></a> реализовать типаж <a href="../../doc/ku/allocator/dry/trait.DryAllocator.html"><code>ku::allocator::dry::DryAllocator</code></a>.</li>
<li>Определить тип <a href="../../doc/kernel/allocator/memory_allocator/struct.MemoryAllocator.html"><code>kernel::allocator::memory_allocator::MemoryAllocator</code></a> и реализовать для него типаж <a href="https://doc.rust-lang.org/nightly/core/alloc/trait.Allocator.html"><code>core::alloc::Allocator</code></a> через реализованный ранее <a href="../../doc/ku/allocator/dry/trait.DryAllocator.html"><code>ku::allocator::dry::DryAllocator</code></a>. Этот пункт уже сделан в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/allocator/memory_allocator.rs"><code>kernel/src/allocator/memory_allocator.rs</code></a>.</li>
</ul>
<p>После этого станет доступен глобальный аллокатор памяти общего назначения
<a href="../../doc/kernel/allocator/struct.GlobalAllocator.html"><code>kernel::allocator::GlobalAllocator</code></a>.
Он является
<a href="../../doc/kernel/allocator/memory_allocator/struct.MemoryAllocator.html"><code>kernel::allocator::memory_allocator::MemoryAllocator</code></a>
поверх базового адресного пространства
<a href="../../doc/kernel/memory/struct.BASE_ADDRESS_SPACE.html"><code>kernel::memory::BASE_ADDRESS_SPACE</code></a>
и определён в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/allocator/mod.rs"><code>kernel/src/allocator/mod.rs</code></a>.</p>
<h3 id="Статистика-аллокатора-kuallocatorinfoinfo"><a class="header" href="#Статистика-аллокатора-kuallocatorinfoinfo">Статистика аллокатора <a href="../../doc/ku/allocator/info/struct.Info.html"><code>ku::allocator::info::Info</code></a></a></h3>
<p>Для отладки аллокации памяти в коде присутствует сбор статистики про выполняемые аллокатором операции.
Эта статистика доступна в виде структуры <a href="../../doc/ku/allocator/info/struct.Info.html"><code>ku::allocator::info::Info</code></a>.
Её поля означают следующее:</p>
<ul>
<li><a href="../../doc/ku/allocator/info/struct.Info.html#structfield.requested"><code>Info::requested</code></a> — сколько памяти в байтах было запрошено у аллокатора.</li>
<li><a href="../../doc/ku/allocator/info/struct.Info.html#structfield.allocated"><code>Info::allocated</code></a> — сколько памяти в байтах было выделено аллокатором.</li>
<li><a href="../../doc/ku/allocator/info/struct.Info.html#structfield.allocations"><code>Info::allocations</code></a> — количество запросов к аллокатору.</li>
<li><a href="../../doc/ku/allocator/info/struct.Info.html#structfield.pages"><code>Info::pages</code></a> — количество виртуальных страниц, которые аллокатор выделил для удовлетворения запросов.</li>
</ul>
<p>Каждый такой счётчик является структурой
<a href="../../doc/ku/allocator/info/struct.Counter.html"><code>ku::allocator::info::Counter</code></a>,
содержащей положительную и отрицательную компоненту:</p>
<ul>
<li><a href="../../doc/ku/allocator/info/struct.Counter.html#structfield.positive"><code>Counter::positive</code></a> — суммарный размер соответствующего параметра для аллокаций.</li>
<li><a href="../../doc/ku/allocator/info/struct.Counter.html#structfield.negative"><code>Counter::negative</code></a> — суммарный размер соответствующего параметра для деаллокаций.</li>
</ul>
<p>То есть, например <code>info.allocated.positive()</code> выдаёт количество реально выделенных байт, <code>info.pages.negative()</code> выдаёт количество освобождённых при деаллокациях страниц, а <code>info.requested.balance()</code> выдаёт количество байт, которые были запрошена у аллокатора, но ещё не освобождены.</p>
<p>От этих чисел хочется интерпретируемости и соответствия естественным инвариантам.
Если количество аллокаций больше чем деаллокаций, то естественно ожидать, что какая-то память ещё занята.
А в ситуации, когда ещё и на входе и выходе балансы должны быть нулевые, это означает утечку.
Если же деаллокаций больше чем аллокаций в ситуации когда и на входе и выходе балансы должны быть нулевые,
это наталкивает на мысли о наличии какой-то серьёзной ошибки.
В частности, реаллокация учитываются как одна деаллокация полного старого блока плюс одна аллокация полного
нового блока.
Не создавайте несколько деаллокаций по кусочку старого блока при вызовах <code>dry_shrink()</code> или
фиктивных аллокаций нулевого размера.
Это сломает естественные инварианты и интерпретируемость значений
<a href="../../doc/ku/allocator/info/struct.Info.html"><code>ku::allocator::info::Info</code></a>,
а также не пройдёт тесты.</p>
<p>Поэтому обратите внимание, как в
<a href="../../doc/ku/allocator/info/struct.Info.html"><code>ku::allocator::info::Info</code></a>
отслеживаются аллокации и деаллокации, которые выполняет ваш код.
Реализации методов</p>
<ul>
<li><a href="../../doc/ku/allocator/big/trait.BigAllocator.html#tymethod.reserve"><code>ku::allocator::big::BigAllocator::reserve()</code></a>,</li>
<li><a href="../../doc/ku/allocator/big/trait.BigAllocator.html#tymethod.unreserve"><code>ku::allocator::big::BigAllocator::unreserve()</code></a> и</li>
<li><a href="../../doc/ku/allocator/big/trait.BigAllocator.html#tymethod.unreserve"><code>ku::allocator::big::BigAllocator::rereserve()</code></a>
для
<a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html"><code>kernel::memory::address_space::AddressSpace</code></a>
сами обновляют эту статистику.
Вам остаётся только корректно позвать эти методы.</li>
</ul>
<p>В логах эти счётчики будут печататься так:</p>
<pre><code class="language-console">20:26:37 0 D info = { allocations: 9 - 8 = 1, requested: 284.000 KiB - 156.000 KiB = 128.000 KiB, allocated: 284.000 KiB - 156.000 KiB = 128.000 KiB, pages: 71 - 39 = 32, loss: 0 B = 0.000% }
</code></pre>
<p>Это означает, что всего было выполнено <code>9</code> аллокаций и <code>8</code> деаллокаций.
В аллокациях было суммарно запрошено <code>284.000 KiB</code>, а в деаллокациях суммарно было освобождено <code>156.000 KiB</code>,
что даёт текущее запрошенное потребление <code>128.000 KiB</code> в одной оставшейся на данный момент аллокации.
Так как аллокатор постраничный, эти величины совпадают с количеством реально выделенной памяти,
а потери на фрагментацию нулевые.</p>
<h3 id="Задача-1--аллокатор-памяти-общего-назначения"><a class="header" href="#Задача-1--аллокатор-памяти-общего-назначения">Задача 1 — аллокатор памяти общего назначения</a></h3>
<p>Реализуйте метод
<a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.remap"><code>remap()</code></a>
типажа
<a href="../../doc/ku/allocator/big/trait.BigAllocator.html"><code>ku::allocator::big::BigAllocator</code></a>
для
<a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html"><code>kernel::memory::address_space::AddressSpace</code></a>
в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/address_space.rs"><code>kernel/src/memory/address_space.rs</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn remap(&amp;mut self, old_block: Block&lt;Page&gt;, new_block: Block&lt;Page&gt;) -&gt; Result&lt;()&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Он перемещает отображение физических фреймов из <code>old_block</code> в <code>new_block</code>.
Если изначально <code>new_block</code> содержал отображённые страницы,
их отображение удаляется.
Физические фреймы, на которые не осталось других ссылок, освобождаются.
После работы <code>remap()</code> виртуальные адреса <code>old_block</code>
становятся недоступны.
А содержимое памяти, которое ранее было доступно через <code>old_block</code>,
становится доступным через <code>new_block</code>.
Флаги доступа при этом не меняются.</p>
<p>Если <code>old_block</code> и <code>new_block</code> имеют разный размер или пересекаются, метод <code>remap()</code>
возвращает ошибку
<a href="../../doc/ku/error/enum.Error.html#variant.InvalidArgument"><code>Error::InvalidArgument</code></a>.</p>
<p>Реализуйте методы типажа
<a href="../../doc/ku/allocator/dry/trait.DryAllocator.html"><code>ku::allocator::dry::DryAllocator</code></a>
для типа, который уже реализует типаж
<a href="../../doc/ku/allocator/big/trait.BigAllocator.html"><code>ku::allocator::big::BigAllocator</code></a>
в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/allocator/big.rs"><code>ku/src/allocator/big.rs</code></a>.
При этом с виртуальным адресным пространством работайте через
<a href="../../doc/ku/allocator/big/trait.BigAllocator.html#tymethod.reserve"><code>ku::allocator::big::BigAllocator::reserve()</code></a>,
<a href="../../doc/ku/allocator/big/trait.BigAllocator.html#tymethod.unreserve"><code>ku::allocator::big::BigAllocator::unreserve()</code></a> и
<a href="../../doc/ku/allocator/big/trait.BigAllocator.html#tymethod.unreserve"><code>ku::allocator::big::BigAllocator::rereserve()</code></a>.
А чтобы менять его отображение на физическую память, используете
<a href="../../doc/ku/allocator/big/trait.BigAllocator.html#tymethod.map"><code>ku::allocator::big::BigAllocator::map()</code></a>,
<a href="../../doc/ku/allocator/big/trait.BigAllocator.html#tymethod.unmap"><code>ku::allocator::big::BigAllocator::unmap()</code></a>
и
<a href="../../doc/ku/allocator/big/trait.BigAllocator.html#tymethod.remap"><code>ku::allocator::big::BigAllocator::remap()</code></a>.
Естественно, все выдаваемые блоки памяти будут выровнены на границы страниц и по своему адресу и по размеру.</p>
<p>Вам могут пригодиться методы <a href="../../doc/ku/memory/block/struct.Block.html"><code>ku::memory::block::Block</code></a>, например:</p>
<ul>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.count"><code>Block::count()</code></a>,</li>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.from_index"><code>Block::from_index()</code></a>,</li>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.tail"><code>Block::tail()</code></a>,</li>
<li><a href="../../doc/ku/memory/block/struct.Block.html#method.try_into_non_null_slice"><code>Block::try_into_non_null_slice()</code></a>.</li>
</ul>
<p>А также вспомогательные функции, определённые в том же файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/allocator/big.rs"><code>ku/src/allocator/big.rs</code></a>:</p>
<ul>
<li><a href="../../doc/ku/allocator/big/fn.try_into_block.html"><code>ku::allocator::big::try_into_block()</code></a></li>
<li><a href="../../doc/ku/allocator/big/fn.initialize_block.html"><code>ku::allocator::big::initialize_block()</code></a>.</li>
</ul>
<p>В зависимости от вашей реализации <code>dry_shrink()</code>, вам может пригодиться или не пригодиться метод
<a href="../../doc/ku/allocator/big/trait.BigAllocator.html#tymethod.unreserve"><code>BigAllocator::rereserve()</code></a>.</p>
<p>При реализации учтите, что даже если <code>old_layout</code> и <code>new_layout</code> в <code>dry_grow()</code> и <code>dry_shrink()</code> отличаются,
но при этом не отличаются соответствующие им блоки страниц <code>Block&lt;Page&gt;</code>,
то ничего делать не нужно.
Можно вернуть на выход срез со старым адресом, приведённый к новому размеру.
Аналогично, из <code>dry_shrink()</code> вы можете всегда возвращать срез со старым адресом и новым размером.</p>
<h3 id="Проверьте-себя-9"><a class="header" href="#Проверьте-себя-9">Проверьте себя</a></h3>
<p>Запустите тест <code>4-concurrency-1-memory-allocator</code> из файла
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/4-concurrency-1-memory-allocator.rs"><code>kernel/tests/4-concurrency-1-memory-allocator.rs</code></a>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 4-concurrency-1-memory-allocator)
...
4_concurrency_1_memory_allocator::basic---------------------
20:26:36 0 D start_info = { allocations: 0 - 0 = 0, requested: 0 B - 0 B = 0 B, allocated: 0 B - 0 B = 0 B, pages: 0 - 0 = 0, loss: 0 B = 0.000% }
20:26:36 0 D info = { allocations: 1 - 0 = 1, requested: 4.000 KiB - 0 B = 4.000 KiB, allocated: 4.000 KiB - 0 B = 4.000 KiB, pages: 1 - 0 = 1, loss: 0 B = 0.000% }
20:26:36 0 D info_diff = { allocations: 1 - 0 = 1, requested: 4.000 KiB - 0 B = 4.000 KiB, allocated: 4.000 KiB - 0 B = 4.000 KiB, pages: 1 - 0 = 1, loss: 0 B = 0.000% }
20:26:36 0 D end_info = { allocations: 1 - 1 = 0, requested: 4.000 KiB - 4.000 KiB = 0 B, allocated: 4.000 KiB - 4.000 KiB = 0 B, pages: 1 - 1 = 0, loss: 0 B = 0.000% }
20:26:36 0 D end_info_diff = { allocations: 1 - 1 = 0, requested: 4.000 KiB - 4.000 KiB = 0 B, allocated: 4.000 KiB - 4.000 KiB = 0 B, pages: 1 - 1 = 0, loss: 0 B = 0.000% }
4_concurrency_1_memory_allocator::basic------------ [passed]

4_concurrency_1_memory_allocator::shrink_is_not_a_noop------
20:26:36 0 D old_block = [0v7FFFFFF3A000, 0v7FFFFFF3E000), size 16.000 KiB; new_block = [0v7FFFFFF3A000, 0v7FFFFFF3D000), size 12.000 KiB; no_remap_on_shrink = true
4_concurrency_1_memory_allocator::shrink_is_not_a_noop [passed]

4_concurrency_1_memory_allocator::grow_and_shrink-----------
20:26:37 0 D start_info = { allocations: 3 - 3 = 0, requested: 32.000 KiB - 32.000 KiB = 0 B, allocated: 32.000 KiB - 32.000 KiB = 0 B, pages: 8 - 8 = 0, loss: 0 B = 0.000% }
20:26:37 0 D info = { allocations: 9 - 8 = 1, requested: 284.000 KiB - 156.000 KiB = 128.000 KiB, allocated: 284.000 KiB - 156.000 KiB = 128.000 KiB, pages: 71 - 39 = 32, loss: 0 B = 0.000% }
20:26:37 0 D info_diff = { allocations: 6 - 5 = 1, requested: 252.000 KiB - 124.000 KiB = 128.000 KiB, allocated: 252.000 KiB - 124.000 KiB = 128.000 KiB, pages: 63 - 31 = 32, loss: 0 B = 0.000% }
20:26:37 0 D end_info = { allocations: 14 - 14 = 0, requested: 408.000 KiB - 408.000 KiB = 0 B, allocated: 408.000 KiB - 408.000 KiB = 0 B, pages: 102 - 102 = 0, loss: 0 B = 0.000% }
4_concurrency_1_memory_allocator::grow_and_shrink-- [passed]

4_concurrency_1_memory_allocator::paged_realloc_is_cheap----
20:26:37 0 D block = [0v7FFFFFEFA000, 0v7FFFFFEFB000), size 4.000 KiB; frames = [32538 @ 0p7F1A000 -WP]
20:26:37 0 D block = [0v7FFFFFEF7000, 0v7FFFFFEF9000), size 8.000 KiB; frames = [32538 @ 0p7F1A000 -WP, 32537 @ 0p7F19000 -WP]
20:26:37 0 D block = [0v7FFFFFEF2000, 0v7FFFFFEF6000), size 16.000 KiB; frames = [32538 @ 0p7F1A000 -WP, 32537 @ 0p7F19000 -WP, 32539 @ 0p7F1B000 -WP, 32533 @ 0p7F15000 -WP]
20:26:37 0 D block = [0v7FFFFFEE9000, 0v7FFFFFEF1000), size 32.000 KiB; frames = [32538 @ 0p7F1A000 -WP, 32537 @ 0p7F19000 -WP, 32539 @ 0p7F1B000 -WP, 32533 @ 0p7F15000 -WP, 32540 @ 0p7F1C000 -WP, 32535 @ 0p7F17000 -WP, 32536 @ 0p7F18000 -WP, 32525 @ 0p7F0D000 -WP]
20:26:37 0 D block = [0v7FFFFFED8000, 0v7FFFFFEE8000), size 64.000 KiB; frames = [32538 @ 0p7F1A000 -WP, 32537 @ 0p7F19000 -WP, 32539 @ 0p7F1B000 -WP, 32533 @ 0p7F15000 -WP, 32540 @ 0p7F1C000 -WP, 32535 @ 0p7F17000 -WP, 32536 @ 0p7F18000 -WP, 32525 @ 0p7F0D000 -WP, 32534 @ 0p7F16000 -WP, 32527 @ 0p7F0F000 -WP, 32528 @ 0p7F10000 -WP, 32529 @ 0p7F11000 -WP, 32530 @ 0p7F12000 -WP, 32531 @ 0p7F13000 -WP, 32532 @ 0p7F14000 -WP, 32509 @ 0p7EFD000 -WP]
20:26:37 0 D block = [0v7FFFFFED8000, 0v7FFFFFEE7000), size 60.000 KiB; frames = [32538 @ 0p7F1A000 -WP, 32537 @ 0p7F19000 -WP, 32539 @ 0p7F1B000 -WP, 32533 @ 0p7F15000 -WP, 32540 @ 0p7F1C000 -WP, 32535 @ 0p7F17000 -WP, 32536 @ 0p7F18000 -WP, 32525 @ 0p7F0D000 -WP, 32534 @ 0p7F16000 -WP, 32527 @ 0p7F0F000 -WP, 32528 @ 0p7F10000 -WP, 32529 @ 0p7F11000 -WP, 32530 @ 0p7F12000 -WP, 32531 @ 0p7F13000 -WP, 32532 @ 0p7F14000 -WP]
20:26:37 0 D block = [0v7FFFFFED8000, 0v7FFFFFEE6000), size 56.000 KiB; frames = [32538 @ 0p7F1A000 -WP, 32537 @ 0p7F19000 -WP, 32539 @ 0p7F1B000 -WP, 32533 @ 0p7F15000 -WP, 32540 @ 0p7F1C000 -WP, 32535 @ 0p7F17000 -WP, 32536 @ 0p7F18000 -WP, 32525 @ 0p7F0D000 -WP, 32534 @ 0p7F16000 -WP, 32527 @ 0p7F0F000 -WP, 32528 @ 0p7F10000 -WP, 32529 @ 0p7F11000 -WP, 32530 @ 0p7F12000 -WP, 32531 @ 0p7F13000 -WP]
20:26:37 0 D block = [0v7FFFFFED8000, 0v7FFFFFEE5000), size 52.000 KiB; frames = [32538 @ 0p7F1A000 -WP, 32537 @ 0p7F19000 -WP, 32539 @ 0p7F1B000 -WP, 32533 @ 0p7F15000 -WP, 32540 @ 0p7F1C000 -WP, 32535 @ 0p7F17000 -WP, 32536 @ 0p7F18000 -WP, 32525 @ 0p7F0D000 -WP, 32534 @ 0p7F16000 -WP, 32527 @ 0p7F0F000 -WP, 32528 @ 0p7F10000 -WP, 32529 @ 0p7F11000 -WP, 32530 @ 0p7F12000 -WP]
20:26:37 0 D block = [0v7FFFFFED8000, 0v7FFFFFEE4000), size 48.000 KiB; frames = [32538 @ 0p7F1A000 -WP, 32537 @ 0p7F19000 -WP, 32539 @ 0p7F1B000 -WP, 32533 @ 0p7F15000 -WP, 32540 @ 0p7F1C000 -WP, 32535 @ 0p7F17000 -WP, 32536 @ 0p7F18000 -WP, 32525 @ 0p7F0D000 -WP, 32534 @ 0p7F16000 -WP, 32527 @ 0p7F0F000 -WP, 32528 @ 0p7F10000 -WP, 32529 @ 0p7F11000 -WP]
20:26:37 0 D block = [0v7FFFFFED8000, 0v7FFFFFEE3000), size 44.000 KiB; frames = [32538 @ 0p7F1A000 -WP, 32537 @ 0p7F19000 -WP, 32539 @ 0p7F1B000 -WP, 32533 @ 0p7F15000 -WP, 32540 @ 0p7F1C000 -WP, 32535 @ 0p7F17000 -WP, 32536 @ 0p7F18000 -WP, 32525 @ 0p7F0D000 -WP, 32534 @ 0p7F16000 -WP, 32527 @ 0p7F0F000 -WP, 32528 @ 0p7F10000 -WP]
20:26:37 0 D block = [0v7FFFFFED8000, 0v7FFFFFEE2000), size 40.000 KiB; frames = [32538 @ 0p7F1A000 -WP, 32537 @ 0p7F19000 -WP, 32539 @ 0p7F1B000 -WP, 32533 @ 0p7F15000 -WP, 32540 @ 0p7F1C000 -WP, 32535 @ 0p7F17000 -WP, 32536 @ 0p7F18000 -WP, 32525 @ 0p7F0D000 -WP, 32534 @ 0p7F16000 -WP, 32527 @ 0p7F0F000 -WP]
20:26:37 0 D block = [0v7FFFFFED8000, 0v7FFFFFEE1000), size 36.000 KiB; frames = [32538 @ 0p7F1A000 -WP, 32537 @ 0p7F19000 -WP, 32539 @ 0p7F1B000 -WP, 32533 @ 0p7F15000 -WP, 32540 @ 0p7F1C000 -WP, 32535 @ 0p7F17000 -WP, 32536 @ 0p7F18000 -WP, 32525 @ 0p7F0D000 -WP, 32534 @ 0p7F16000 -WP]
20:26:37 0 D block = [0v7FFFFFED8000, 0v7FFFFFEE0000), size 32.000 KiB; frames = [32538 @ 0p7F1A000 -WP, 32537 @ 0p7F19000 -WP, 32539 @ 0p7F1B000 -WP, 32533 @ 0p7F15000 -WP, 32540 @ 0p7F1C000 -WP, 32535 @ 0p7F17000 -WP, 32536 @ 0p7F18000 -WP, 32525 @ 0p7F0D000 -WP]
20:26:37 0 D block = [0v7FFFFFED8000, 0v7FFFFFEDF000), size 28.000 KiB; frames = [32538 @ 0p7F1A000 -WP, 32537 @ 0p7F19000 -WP, 32539 @ 0p7F1B000 -WP, 32533 @ 0p7F15000 -WP, 32540 @ 0p7F1C000 -WP, 32535 @ 0p7F17000 -WP, 32536 @ 0p7F18000 -WP]
20:26:37 0 D block = [0v7FFFFFED8000, 0v7FFFFFEDE000), size 24.000 KiB; frames = [32538 @ 0p7F1A000 -WP, 32537 @ 0p7F19000 -WP, 32539 @ 0p7F1B000 -WP, 32533 @ 0p7F15000 -WP, 32540 @ 0p7F1C000 -WP, 32535 @ 0p7F17000 -WP]
20:26:37 0 D block = [0v7FFFFFED8000, 0v7FFFFFEDD000), size 20.000 KiB; frames = [32538 @ 0p7F1A000 -WP, 32537 @ 0p7F19000 -WP, 32539 @ 0p7F1B000 -WP, 32533 @ 0p7F15000 -WP, 32540 @ 0p7F1C000 -WP]
20:26:37 0 D block = [0v7FFFFFED8000, 0v7FFFFFEDC000), size 16.000 KiB; frames = [32538 @ 0p7F1A000 -WP, 32537 @ 0p7F19000 -WP, 32539 @ 0p7F1B000 -WP, 32533 @ 0p7F15000 -WP]
20:26:37 0 D block = [0v7FFFFFED8000, 0v7FFFFFEDB000), size 12.000 KiB; frames = [32538 @ 0p7F1A000 -WP, 32537 @ 0p7F19000 -WP, 32539 @ 0p7F1B000 -WP]
20:26:37 0 D block = [0v7FFFFFED8000, 0v7FFFFFEDA000), size 8.000 KiB; frames = [32538 @ 0p7F1A000 -WP, 32537 @ 0p7F19000 -WP]
20:26:37 0 D block = [0v7FFFFFED8000, 0v7FFFFFED9000), size 4.000 KiB; frames = [32538 @ 0p7F1A000 -WP]
20:26:37 0 D block = [0v1000, 0v1000), size 0 B; frames = []
4_concurrency_1_memory_allocator::paged_realloc_is_cheap [passed]
20:26:37 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-12"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-12">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/memory/address_space.rs |   22 ++++++++-
 ku/src/allocator/big.rs            |   87 +++++++++++++++++++++++++++++++------
 2 files changed, 95 insertions(+), 14 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Поддержка-нескольких-процессоров--symmetric-multiprocessing-smp"><a class="header" href="#Поддержка-нескольких-процессоров--symmetric-multiprocessing-smp">Поддержка нескольких процессоров — Symmetric multiprocessing (SMP)</a></h2>
<p>В этой части лабораторке нужно будет реализовать управление процессорами в симметричной архитектуре.
Для вашего удобства, часть разбита на три задачи, которые нужно делать по порядку:</p>
<ul>
<li>Работа с local APIC.</li>
<li>Состояние каждого процессора.</li>
<li>Загрузка Application Processor.</li>
</ul>
<p>В <a href="https://en.wikipedia.org/wiki/X86-64">x86-64</a> <a href="https://en.wikipedia.org/wiki/Multiprocessing">многопроцессорность</a> выполнена либо в модели
<a href="https://en.wikipedia.org/wiki/Symmetric_multiprocessing">SMP</a> (Symmetric Multiprocessing), либо
<a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA</a> (Non-uniform memory access).
В обоих случаях все процессоры, как правило, одинаковые и выполняют один и тот же код операционной системы.
Тем не менее во время загрузки сперва работает только один процессор, называемый Bootstrap Processor (BP).
Какой именно это будет процессор, определяется железом.
После того как ОС загрузилась на BP, она может запустить остальные процессоры, которые именуются Application Processors (AP).
Чтобы запустить AP, операционная система c процессора BP посылает AP прерывание с помощью
local <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">Advanced Programmable Interrupt Controller</a> (local APIC, LAPIC).</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/1/1c/SMP_-_Symmetric_Multiprocessor_System.svg" alt="" /></p>
<h3 id="Код-работы-с-smp-в-nikka-собран-в-модуль-kernelsmp-в-директории-kernelsrcsmp"><a class="header" href="#Код-работы-с-smp-в-nikka-собран-в-модуль-kernelsmp-в-директории-kernelsrcsmp">Код работы с SMP в Nikka собран в модуль <a href="../../doc/kernel/smp/index.html"><code>kernel::smp</code></a> в директории <code>kernel/src/smp</code></a></h3>
<ul>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/smp/mod.rs"><code>kernel/src/smp/mod.rs</code></a> — корневая часть модуля <a href="../../doc/kernel/smp/index.html"><code>kernel::smp</code></a>. Содержит функцию <a href="../../doc/kernel/smp/fn.init.html"><code>fn kernel::smp::init(boot_info: &amp;'static BootInfo)</code></a>, инициализирующую работу с SMP. Основную часть работы она перекладывает на внутреннюю функцию <a href="../../doc/kernel/smp/fn.init_smp.html"><code>fn kernel::smp::init_smp(phys2virt: Page) -&gt; Result&lt;()&gt;</code></a>.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/smp/acpi_info.rs"><code>kernel/src/smp/acpi_info.rs</code></a> — обвязка внешней библиотеки <a href="../../doc/acpi/index.html"><code>acpi</code></a>, которая используется для получения информации о конфигурации оборудования из таблиц, предоставляемых BIOS.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/smp/ap_init.rs"><code>kernel/src/smp/ap_init.rs</code></a> — код инициализации Application Processors.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/smp/cpu.rs"><code>kernel/src/smp/cpu.rs</code></a> — код для работы с вектором структур <a href="../../doc/kernel/smp/cpu/struct.Cpu.html"><code>kernel::smp::cpu::Cpu</code></a>, каждая из которых принадлежит своему процессору системы.</li>
<li><a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/smp/local_apic.rs"><code>kernel/src/smp/local_apic.rs</code></a> — код работы с local APIC.</li>
</ul>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-13"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-13">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/smp/ap_init.rs    |   55 ++++++++++++++++++++++++++++++++++++++++---
 kernel/src/smp/cpu.rs        |   54 +++++++++++++++++++++++++++++++++++-------
 kernel/src/smp/local_apic.rs |   19 +++++++++++++-
 3 files changed, 115 insertions(+), 13 deletions(-)
</code></pre>
<p>Однако, будьте готовы к тому что на написание и отладку
<a href="../../lab/book/4-concurrency-1-smp-3-ap-init.html#%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-4--%D0%BF%D0%B5%D1%80%D0%B5%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-ap-%D0%B2-64-%D0%B1%D0%B8%D1%82%D0%BD%D1%8B%D0%B9-%D1%80%D0%B5%D0%B6%D0%B8%D0%BC">задачи 4</a>
может потребоваться много времени.
Также может потребоваться изучить ассемблер различных режимов работы процессора архитектуры
<a href="https://en.wikipedia.org/wiki/X86-64">x86-64</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Работа-с-local-apic"><a class="header" href="#Работа-с-local-apic">Работа с local APIC</a></h2>
<p>В Nikka функционал для работы с LAPIC реализован в структуре
<a href="../../doc/kernel/smp/local_apic/struct.LocalApic.html"><code>kernel::smp::local_apic::LocalApic</code></a>
в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/smp/local_apic.rs"><code>kernel/src/smp/local_apic.rs</code></a>.
В частности, у него есть такие статические методы:</p>
<ul>
<li><a href="../../doc/kernel/smp/local_apic/struct.LocalApic.html#method.init"><code>LocalApic::init()</code></a> инициализирует local APIC, например включает прерывание таймера.</li>
<li><a href="../../doc/kernel/smp/local_apic/struct.LocalApic.html#method.id"><code>LocalApic::id()</code></a> позволяет узнать идентификатор local APIC и текущего CPU.</li>
<li><a href="../../doc/kernel/smp/local_apic/struct.LocalApic.html#method.send_init"><code>LocalApic::send_init()</code></a> пошлёт прерывание на AP, предназначенное для его инициализации.</li>
<li><a href="../../doc/kernel/smp/local_apic/struct.LocalApic.html#method.get"><code>LocalApic::get()</code></a> возвращает структуру <a href="../../doc/kernel/smp/local_apic/struct.LocalApic.html"><code>LocalApic</code></a> данного CPU.</li>
</ul>
<h3 id="Задача-2--инициализация-работы-с-localapic"><a class="header" href="#Задача-2--инициализация-работы-с-localapic">Задача 2 — инициализация работы с <code>LocalApic</code></a></h3>
<p>Интерфейс для работы с local APIC в <a href="https://en.wikipedia.org/wiki/X86-64">x86-64</a> представляет собой выровненную область размером 4 килобайта в физической памяти — один физический фрейм.
Такой тип интерфейса называется
<a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">Memory–mapped I/O</a> (MMIO).
Чтобы пользоваться MMIO нужно, во-первых, замапить его физический адрес в текущее виртуальное адресное пространство.
А во-вторых, указать процессору, что данный диапазон памяти не нужно кешировать.
Для этого требуется выставить флаги
<a href="../../doc/ku/memory/mmu/struct.PageTableFlags.html#associatedconstant.NO_CACHE"><code>PageTableFlags::NO_CACHE</code></a> и
<a href="../../doc/ku/memory/mmu/struct.PageTableFlags.html#associatedconstant.WRITE_THROUGH"><code>PageTableFlags::WRITE_THROUGH</code></a> в
<a href="../../doc/ku/memory/mmu/struct.PageTableEntry.html"><code>PageTableEntry</code></a>.</p>
<p>Каждый процессор имеет собственный local APIC, потому он и называется локальным (local).
LAPIC находится на том же кристалле, что и процессор и связан с ним выделенным каналом.
А физические адреса всех LAPIC в системе совпадают.
Когда процессор обращается по физическому адресу, относящемуся к LAPIC, он использует этот выделенный канал.
И это обращение не видят другие процессоры и LAPIC в системе.
Поэтому конфликта из-за одинаковых физических адресов не происходит.
Наоборот, совпадение физических адресов всех LAPIC удобно для программиста.
Например, если программе нужно понять, на каком именно CPU она сейчас запущена —
достаточно прочитать идентификатор LAPIC и CPU по определённому физическому адресу области MMIO LAPIC.
Это и делает метод
<a href="../../doc/kernel/smp/local_apic/struct.LocalApic.html#method.id"><code>LocalApic::id()</code></a>.</p>
<p>Физический адрес MMIO для local APIC можно узнать вызвав метод
<a href="../../doc/kernel/smp/acpi_info/struct.AcpiInfo.html#method.local_apic_address"><code>kernel::smp::acpi_info::AcpiInfo::local_apic_address()</code></a>.
А виртуальный адрес можно было бы выбрать произвольно.
Но ядро должно этот адрес где-то запомнить, чтобы использовать для обращений в дальнейшем.
Для простоты, запишем этот адрес прямо в код.
Для этого, заведём статическую переменную
<a href="../../doc/kernel/smp/local_apic/static.LOCAL_APIC.html"><code>kernel::smp::local_apic::LOCAL_APIC</code></a>,
изначально содержащую страницу нулей.
Компилятор выделит под неё страницу в памяти ядра, и настроит все обращения в коде к ней.
А мы при инициализации MMIO для local APIC удалим маппинг для этой виртуальной страницы и вместо ненужных нам нулей замапим на её виртуальный адрес физический фрейм local APIC.
Побочным результатом такого подхода будет то, что до того как мы инициализируем MMIO, метод
<a href="../../doc/kernel/smp/local_apic/struct.LocalApic.html#method.id"><code>LocalApic::id()</code></a>
будет выдавать <code>0</code>, а не ошибку.
И функции, которые им пользуются, могут обойтись без обработки ошибки в этом случае.</p>
<p>Реализуйте <a href="../../doc/kernel/smp/local_apic/struct.LocalApic.html#method.map">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn LocalApic::map(address: Phys) -&gt; Result&lt;()&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Физический адрес MMIO local APIC он принимает на вход.
А для определения нужного виртуального адреса вам пригодится функция
<a href="../../doc/kernel/smp/local_apic/struct.LocalApic.html#method.get"><code>LocalApic::get()</code></a>.
Также могут пригодиться</p>
<ul>
<li><a href="../../doc/kernel/memory/struct.BASE_ADDRESS_SPACE.html"><code>kernel::memory::BASE_ADDRESS_SPACE</code></a>,</li>
<li><a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.unmap_page"><code>kernel::memory::address_space::AddressSpace::unmap_page()</code></a>,</li>
<li><a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.map_page_to_frame"><code>kernel::memory::address_space::AddressSpace::map_page_to_frame()</code></a>,</li>
<li><a href="../../doc/kernel/memory/type.Frame.html"><code>kernel::memory::Frame</code></a>,</li>
<li><a href="../../doc/kernel/memory/type.Page.html"><code>kernel::memory::Page</code></a>,</li>
<li><a href="../../doc/kernel/memory/type.Virt.html"><code>kernel::memory::Virt</code></a>.</li>
</ul>
<h3 id="Проверьте-себя-10"><a class="header" href="#Проверьте-себя-10">Проверьте себя</a></h3>
<p>Запустите тест <code>4-concurrency-2-local-apic</code> из файла
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/4-concurrency-2-local-apic.rs"><code>kernel/tests/4-concurrency-2-local-apic.rs</code></a>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 4-concurrency-2-local-apic)
...
4_concurrency_2_local_apic::mapped_properly-----------------
20:26:39 0 I Local APIC; local_apic = 0v334000; frame = Frame(1043968 @ 0pFEE00000); flags = PRESENT | WRITABLE | WRITE_THROUGH | NO_CACHE | ACCESSED | DIRTY | NO_EXECUTE
20:26:39 0 I cpu = 0
4_concurrency_2_local_apic::mapped_properly-------- [passed]
</code></pre>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-14"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-14">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/smp/local_apic.rs |   19 +++++++++++++++++--
 1 file changed, 17 insertions(+), 2 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Состояние-каждого-процессора"><a class="header" href="#Состояние-каждого-процессора">Состояние каждого процессора</a></h2>
<p>В Nikka состояние отдельного процессора описано в структуре
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html"><code>kernel::smp::cpu::Cpu</code></a>,
определённой в <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/smp/cpu.rs"><code>kernel/src/smp/cpu.rs</code></a>.
Номер процессора, на котором сейчас происходит выполнение кода, продублирован в этой структуре и его можно узнать с помощью метода
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html#method.id"><code>Cpu::id()</code></a>.
Саму структуру
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html"><code>Cpu</code></a>
текущего процессора можно получить из статического метода
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html#method.get"><code>Cpu::get()</code></a>.</p>
<p>Состояние каждого процессора включает:</p>
<ul>
<li>Стек ядра <a href="../../doc/kernel/smp/cpu/struct.Cpu.html#structfield.kernel_stack"><code>Cpu::kernel_stack</code></a>. Процессоры обрабатывают системные вызовы и прерывания независимо, так что у каждого должен быть свой стек для этого.</li>
<li>Также полезен дополнительный стек <a href="../../doc/kernel/smp/cpu/struct.Cpu.html#structfield.page_fault_stack"><code>Cpu::page_fault_stack</code></a>, который используется во время обработки Page Fault. Он позволяет напечатать диагностику возникшего исключения даже в случае, когда оно вызвано исчерпанием основного стека ядра.</li>
<li><a href="https://en.wikipedia.org/wiki/Task_state_segment">Task State Segment</a> <a href="../../doc/kernel/smp/cpu/struct.Cpu.html#structfield.tss"><code>Cpu::tss</code></a>. В TSS хранится <code>RSP</code> ядра для текущего процессора. Разумеется, раз стеки разные, то и TSS тоже должны быть разные.</li>
<li>Исполняющийся на данном CPU в текущий момент пользовательский процесс <a href="../../doc/kernel/smp/cpu/struct.Cpu.html#structfield.current_process"><code>Cpu::current_process</code></a>. Пользовательские процессы выполняются независимо на разных ядрах. Следовательно, у каждого ядра текущий процесс должен быть своим.</li>
<li>Системные регистры. У каждого процессора свои системные регистры. Так что функции их инициализации должны быть вызваны для каждого CPU. Явно в структуре <a href="../../doc/kernel/smp/cpu/struct.Cpu.html"><code>Cpu</code></a> регистры не хранятся.
<ul>
<li><a href="https://wiki.osdev.org/GDT#GDTR"><code>GDTR</code></a> — Global Descriptor Table Register, содержит адрес <a href="../../doc/kernel/memory/gdt/type.Gdt.html">kernel::memory::gdt::Gdt</a>.</li>
<li><a href="https://wiki.osdev.org/IDT#IDTR"><code>IDTR</code></a> — Interrupt Descriptor Table Register, содержит адрес <a href="../../doc/x86_64/structures/idt/struct.InterruptDescriptorTable.html">x86_64::structures::idt::InterruptDescriptorTable</a>.</li>
<li><a href="https://wiki.osdev.org/CPU_Registers_x86-64#CR3"><code>CR3</code></a> — содержит адрес корневой таблицы страниц <a href="../../doc/ku/memory/mmu/type.PageTable.html">ku::memory::mmu::PageTable</a>.</li>
<li><a href="https://wiki.osdev.org/CPU_Registers_x86-64#TR"><code>TR</code></a> — Task Register, содержит адрес <a href="../../doc/x86_64/structures/tss/struct.TaskStateSegment.html">x86_64::structures::tss::TaskStateSegment</a>.</li>
<li><a href="https://wiki.osdev.org/CPU_Registers_x86-64#FS.base.2C_GS.base"><code>FS</code></a> — доступен для программных нужд.</li>
</ul>
</li>
</ul>
<h3 id="Задача-3--вектор-структур-kernelsmpcpucpu"><a class="header" href="#Задача-3--вектор-структур-kernelsmpcpucpu">Задача 3 — вектор структур <a href="../../doc/kernel/smp/cpu/struct.Cpu.html"><code>kernel::smp::cpu::Cpu</code></a></a></h3>
<h4 id="Инициализация-tss-и-регистра-tr"><a class="header" href="#Инициализация-tss-и-регистра-tr">Инициализация TSS и регистра <code>TR</code></a></h4>
<p>Реализуйте <a href="../../doc/kernel/smp/cpu/struct.Cpu.html#method.set_tss">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Cpu::set_tss()
<span class="boring">}
</span></code></pre></pre>
<p>Он должен завести в GDT запись для Task State Segment текущего процессора.
И загрузить её в <a href="https://wiki.osdev.org/CPU_Registers_x86-64#TR"><code>TR</code></a> своего CPU.
Сам Task State Segment в поле <a href="../../doc/kernel/smp/cpu/struct.Cpu.html#structfield.tss"><code>Cpu::tss</code></a>
уже инициализирован методом
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html#method.new"><code>Cpu::new()</code></a>.</p>
<p>Для определения идентификатора текущего процессора можно использовать
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html#method.id"><code>Cpu::id()</code></a>.
Полезно проверить, что он выдаёт ровно такое же значение, что и метод
<a href="../../doc/kernel/smp/local_apic/struct.LocalApic.html#method.id"><code>LocalApic::id()</code></a>.
Если это не так, значит инициализация local APIC ранее или запуск AP в одной из дальнейших задач выполняется неверно.</p>
<p>Также вам пригодятся:</p>
<ul>
<li><a href="../../doc/kernel/memory/gdt/struct.GDT.html"><code>kernel::memory::gdt::GDT</code></a>,</li>
<li><a href="../../doc/kernel/memory/gdt/struct.SmpGdt.html#method.set_tss"><code>kernel::memory::gdt::Gdt::set_tss()</code></a>,</li>
<li><a href="../../doc/kernel/memory/gdt/struct.SmpGdt.html#method.tss"><code>kernel::memory::gdt::Gdt::tss()</code></a>,</li>
<li><a href="../../doc/x86_64/instructions/tables/fn.load_tss.html"><code>x86_64::instructions::tables::load_tss</code></a>.</li>
</ul>
<h4 id="Инициализация-регистра-fs"><a class="header" href="#Инициализация-регистра-fs">Инициализация регистра <code>FS</code></a></h4>
<p>Регистр <code>FS</code> будем использовать для аналога
<a href="https://en.wikipedia.org/wiki/Thread-local_storage">thread–local storage</a>, —
CPU–local storage.
Например, в момент получения системного вызова процессор работает на стеке пользователя.
Доверять стеку пользователя нельзя, поэтому до использования стека процессор должен переключиться на стек ядра.
Адрес стека ядра, предназначенного данному CPU, он возьмёт из нашего CPU–local storage, обратившись к нему через свой регистр <code>FS</code>.
Как вы уже догадались, сам CPU–local storage в Nikka — это структура
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html"><code>Cpu</code></a>.</p>
<p>Реализуйте <a href="../../doc/kernel/smp/cpu/struct.Cpu.html#method.set_fs">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Cpu::set_fs()
<span class="boring">}
</span></code></pre></pre>
<p>Он должен сохранить адрес структуры
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html"><code>Cpu</code></a>
для текущего CPU в его собственном регистре <code>FS</code>.
Этот же адрес нужно будет записать в поле
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html#structfield.this"><code>Cpu::this</code></a>.
Дело в том, что адресовать память относительно регистра <code>FS</code> можно,
но узнать его линейный адрес можно только прочитав его напрямую
инструкцией <a href="https://www.felixcloutier.com/x86/rdmsr">rdmsr</a>.
Получить линейный адрес через инструкцию
<a href="https://www.felixcloutier.com/x86/lea"><code>lea</code></a>
не получится.
А адресовать что-либо через <code>FS</code> неудобно — это можно сделать только в ассемблере.
Самым удобным представляется такой вариант.
Прочитать адрес структуры
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html"><code>Cpu</code></a>
из поля
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html#structfield.this"><code>Cpu::this</code></a>,
обращаясь к самому этому полю относительно регистра <code>FS</code>,
то есть используя логический адрес <code>&lt;сегментный_регистр&gt;:&lt;смещение&gt;</code>.
А дальше, имея линейный адрес структуры
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html"><code>Cpu</code></a>
получить её саму и дальше обращаться к её полям и методам без использования <code>FS</code>.
Что уже можно делать в Rust безо всякого ассемблера.</p>
<p>По умолчанию код пользователя не может менять регистры <code>FS</code> и <code>GS</code>, так это и оставим.
Если бы мы разрешили ему их менять, например для реализации
<a href="https://en.wikipedia.org/wiki/Thread-local_storage">thread-local storage</a> (TLS),
нам также понадобилась бы инструкция
<a href="https://www.felixcloutier.com/x86/swapgs">swapgs</a>
при переключении между режимами ядра и пользователя.</p>
<p>Для сохранения значения в регистр <code>FS</code> вам пригодится метод
<a href="../../doc/x86_64/registers/model_specific/struct.FsBase.html#method.write"><code>x86_64::registers::model_specific::FsBase::write()</code></a>.
Он принимает
<a href="../../doc/x86_64/addr/struct.VirtAddr.html"><code>x86_64::addr::VirtAddr</code></a>,
а не
<a href="../../doc/kernel/memory/type.Virt.html"><code>kernel::memory::Virt</code></a>.
Для преобразования
<a href="../../doc/kernel/memory/type.Virt.html"><code>Virt</code></a> в
<a href="../../doc/x86_64/addr/struct.VirtAddr.html"><code>VirtAddr</code></a>
можно использовать метод
<a href="../../doc/kernel/memory/addr/struct.Addr.html#method.into"><code>Virt::into()</code></a>,
см. <a href="../../doc/kernel/memory/type.Virt.html#%D0%9F%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-virt-%D0%B8-virtaddr">примеры</a>.</p>
<p>Также вам может пригодиться метод
<a href="../../doc/kernel/memory/addr/struct.Addr.html#method.from_ref"><code>Virt::from_ref()</code></a>.</p>
<h4 id="Использование-регистра-fs-для-получения-текущего-kernelsmpcpucpu"><a class="header" href="#Использование-регистра-fs-для-получения-текущего-kernelsmpcpucpu">Использование регистра <code>FS</code> для получения текущего <a href="../../doc/kernel/smp/cpu/struct.Cpu.html"><code>kernel::smp::cpu::Cpu</code></a></a></h4>
<p>Реализуйте <a href="../../doc/kernel/smp/cpu/struct.Cpu.html#method.get">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn Cpu::get() -&gt; &amp;'static mut Cpu
<span class="boring">}
</span></code></pre></pre>
<p><code>unsafe</code> означает, что вызывающая сторона должна гарантировать, что вызывает
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html#method.get"><code>Cpu::get()</code></a>
только после инициализации <code>FS</code> методом
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html#method.set_fs"><code>Cpu::set_fs()</code></a>.
Иначе в лучшем случае будет паника, а в худшем — обращение к невалидной или занятой другими данными памяти.</p>
<p>Загрузите из инициализированного в предыдущей задаче поля
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html#structfield.this"><code>Cpu::this</code></a>
адрес структуры
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html"><code>Cpu</code></a>.
Однако
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html#structfield.this"><code>Cpu::this</code></a> —
это поле структуры, адрес которой мы как раз хотим узнать.
Поэтому нам придётся использовать обращение через инициализированный в предыдущей задаче регистр <code>FS</code>.</p>
<p>Тут придётся использовать ассемблер, например прибегнуть к макросу
<a href="https://doc.rust-lang.org/core/arch/macro.asm.html"><code>asm!()</code></a>,
документацию на который можно посмотреть в
<a href="https://doc.rust-lang.org/nightly/rust-by-example/unsafe/asm.html">Rust By Example</a> и
<a href="https://doc.rust-lang.org/nightly/reference/inline-assembly.html">The Rust Reference</a>.</p>
<p>Также понадобится передать в ассемблерную инструкцию константу, определяющую смещение поля
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html#structfield.this"><code>Cpu::this</code></a>
внутри структуры
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html"><code>Cpu</code></a>.
Для этого пригодится макрос
<a href="../../doc/memoffset/macro.offset_of.html"><code>memoffset::offset_of!()</code></a>.</p>
<p>Полученный адрес нужно будет сохранить в переменной подходящего типа,
поддерживаемого макросом <code>asm!()</code>, например <code>usize</code>.
Преобразовать его в ссылку на структуру
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html"><code>Cpu</code></a>
можно с помощью
<a href="../../doc/kernel/memory/type.Virt.html"><code>Virt</code></a>.
Который выполнит необходимые проверки на валидность этого адреса.
В случае, если проверки не пройдут и вернётся ошибка, можно паниковать.</p>
<p>Так как поменялось назначение сегментного регистра <code>FS</code>,
поправьте код метода
<a href="../../doc/kernel/process/registers/struct.Registers.html#method.switch_to"><code>Registers::switch_to()</code></a>
который вы реализовали в
<a href="../../lab/book/3-process-3-user-mode.html#%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-3--%D0%BF%D0%B5%D1%80%D0%B5%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0-%D0%B2-%D1%80%D0%B5%D0%B6%D0%B8%D0%BC-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F-%D0%B8-%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%82-%D0%B8%D0%B7-%D0%BD%D0%B5%D0%B3%D0%BE">задаче про переключение процессора в режим пользователя</a>.
А также код метода
<a href="../../doc/kernel/process/syscall/fn.syscall_trampoline.html"><code>kernel::process::syscall::syscall_trampoline()</code></a>,
который участвует в
<a href="../../lab/book/3-process-4-syscall.html#%D0%94%D0%B8%D1%81%D0%BF%D0%B5%D1%82%D1%87%D0%B5%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%BD%D1%8B%D1%85-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%BE%D0%B2">диспетчеризации системных вызовов</a>
и был добавлен в соответствующей
<a href="../../lab/book/3-process-4-syscall.html#%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-4--%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%B0-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%BD%D1%8B%D1%85-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%BE%D0%B2">задаче</a>.
Теперь <code>RSP</code> нужно писать не в стек, а по адресу <code>FS:offset</code>, где <code>offset</code> — смещение <code>RSP</code> ядра в структуре
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html"><code>Cpu</code></a>.
Для этого смещения есть константа
<a href="../../doc/kernel/smp/cpu/constant.KERNEL_RSP_OFFSET_IN_CPU.html"><code>kernel::smp::cpu::KERNEL_RSP_OFFSET_IN_CPU</code></a>.
А запись <code>RSP</code> в стек и его сохранение в
<a href="../../doc/kernel/process/syscall/fn.syscall_trampoline.html"><code>syscall_trampoline()</code></a>
нужно будет удалить.
Обратите внимание, что в ассемблере всё также нужно использовать запись <code>FS:offset</code>.
Высокоуровневые методы вроде
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html#method.get"><code>Cpu::get()</code></a>
доступны только для Rust–кода — до переключения стека невозможно корректно позвать Rust–функцию.</p>
<h4 id="Инициализация-вектора-структур-kernelsmpcpucpu"><a class="header" href="#Инициализация-вектора-структур-kernelsmpcpucpu">Инициализация вектора структур <a href="../../doc/kernel/smp/cpu/struct.Cpu.html"><code>kernel::smp::cpu::Cpu</code></a></a></h4>
<p>Чтобы пользоваться структурами
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html"><code>Cpu</code></a>,
для них и для содержащихся в них стеках нужно выделить память.</p>
<p>Реализуйте <a href="../../doc/kernel/smp/cpu/fn.init_cpu_vec.html">функцию</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init_cpu_vec(cpu_count: usize) -&gt; Result&lt;Vec&lt;Cpu&gt;&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Все нужные стеки в количестве
<code>cpu_count *</code><a href="../../doc/kernel/smp/cpu/struct.Cpu.html#associatedconstant.STACKS_PER_CPU"><code>Cpu::STACKS_PER_CPU</code></a>
можно выделить одним вызовом метода
<a href="../../doc/kernel/memory/stack/struct.Stack.html#method.new_slice"><code>kernel::memory::stack::Stack::new_slice()</code></a>.
А для избежания переаллокаций при выделении памяти под
<a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html"><code>Vec</code></a><code>&lt;</code><a href="../../doc/kernel/smp/cpu/struct.Cpu.html"><code>Cpu</code></a><code>&gt;</code>
стоит использовать метод
<a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.with_capacity"><code>alloc::vec::Vec::with_capacity()</code></a>.</p>
<p>Далее нужно будет заполнить этот вектор передавая в метод
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html#method.new"><code>Cpu::new()</code></a>
индекс соответствующей структуры в векторе в качестве идентификатора CPU
<a href="../../doc/kernel/smp/local_apic/type.CpuId.html"><code>kernel::smp::local_apic::CpuId</code></a>
и срез из части ранее выделенных стеков в количестве
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html#associatedconstant.STACKS_PER_CPU"><code>Cpu::STACKS_PER_CPU</code></a>
штук.</p>
<h3 id="Проверьте-себя-11"><a class="header" href="#Проверьте-себя-11">Проверьте себя</a></h3>
<p>Запустите тест <code>4-concurrency-3-cpus</code> из файла
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/4-concurrency-3-cpus.rs"><code>kernel/tests/4-concurrency-3-cpus.rs</code></a>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 4-concurrency-3-cpus)
...
4_concurrency_3_cpus::initialized---------------------------
20:26:42 0 I cpu = 0; local_apic_id = 0
20:26:42 0 I cpu = 0; kernel_stack = 0v7FFFFFEB8000; frame = Frame(32427 @ 0p7EAB000); flags = PRESENT | WRITABLE | ACCESSED | DIRTY | NO_EXECUTE
4_concurrency_3_cpus::initialized------------------ [passed]
20:26:43 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-15"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-15">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/smp/cpu.rs |   54 ++++++++++++++++++++++++++++++++++++++++++--------
 1 file changed, 46 insertions(+), 8 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Загрузка-application-processor"><a class="header" href="#Загрузка-application-processor">Загрузка Application Processor</a></h2>
<p>Перед тем как приступить к запуску AP, процессор BSP должен собрать всю информацию о системе: общее число CPU, их APIC ID и адреса, по которым располагаются MMIO для LAPIC.
Эту информацию собирает BIOS, а ядро получает её от него в таблицах
<a href="https://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface">Advanced Configuration and Power Interface</a> (ACPI).
Чтение таблицы конфигурации процессоров реализовано с помощью внешней библиотеки
<a href="../../doc/acpi/index.html"><code>acpi</code></a> и находится в методе
<a href="../../doc/kernel/smp/acpi_info/struct.AcpiInfo.html#method.new"><code>kernel::smp::acpi_info::AcpiInfo::new()</code></a>
в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/smp/acpi_info.rs"><code>kernel/src/smp/acpi_info.rs</code></a>.</p>
<p>Непосредственно запуск AP из BSP происходит в функции
<a href="../../doc/kernel/smp/ap_init/fn.boot_ap.html"><code>kernel::smp::ap_init::boot_ap()</code></a>
в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/smp/ap_init.rs"><code>kernel/src/smp/ap_init.rs</code></a>.
BSP указывает адрес, c которого начинать выполнение кода загрузки AP, передавая его в
<a href="https://en.wikipedia.org/wiki/Inter-processor_interrupt">inter-processor interrupt</a> (IPI)
с помощью метода
<a href="../../doc/kernel/smp/local_apic/struct.LocalApic.html#method.send_init"><code>kernel::smp::local_apic::LocalApic::send_init()</code></a>.
BSP должен передать AP код загрузчика, слепок которого находится в функции
<a href="../../doc/kernel/smp/ap_init/fn.switch_from_real_mode_to_long_mode.html"><code>kernel::smp::ap_init::switch_from_real_mode_to_long_mode()</code></a>
в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/smp/ap_init.rs"><code>kernel/src/smp/ap_init.rs</code></a>.
Проблема в том, что AP ещё находится в <a href="https://en.wikipedia.org/wiki/Real_mode">16-битном реальном режиме</a>, в котором может адресовать только 1 мегабайт памяти.
Поэтому код загрузчика нужно перенести туда, откуда AP сможет его прочитать.
В Nikka выбран фиксированный физический адрес
<a href="../../doc/kernel/smp/ap_init/constant.BOOT_CODE.html"><code>kernel::smp::ap_init::BOOT_CODE</code></a>.</p>
<p>В конец того же фрейма памяти записывается стек с дополнительной информацией для загрузки AP.
Через этот стек в
<a href="../../doc/kernel/smp/ap_init/fn.switch_from_real_mode_to_long_mode.html"><code>switch_from_real_mode_to_long_mode()</code></a>
передаётся дополнительная информация, необходимая для загрузки AP.
Например, дескриптор описывающий GDT, который можно передать инструкции <code>lgdt</code> как есть.
Или адрес корневой таблицы страниц, который можно записать в <code>CR3</code> как есть.
Это сделано, чтобы:</p>
<ul>
<li>Не нужно было в функции <a href="../../doc/kernel/smp/ap_init/fn.switch_from_real_mode_to_long_mode.html"><code>switch_from_real_mode_to_long_mode()</code></a> на 16-битном ассемблере строить GDT, таблицы страниц и т.д. То есть для максимального упрощения ассемблерной части кода.</li>
<li>Содержимое системных регистров процессора на всех AP гарантированно совпадало с аналогичными регистрами BSP. То есть, чтобы можно было один раз правильно настроить системные регистры BSP, и автоматически получить правильные и консистентные по системе в целом настройки всех процессоров. Естественно, исключая те системные регистры, которые должны быть разными и настраиваются в предыдущих задачах в <a href="../../doc/kernel/smp/cpu/struct.Cpu.html"><code>kernel::smp::cpu::Cpu</code></a>.</li>
</ul>
<p>Вся эта информация передаётся в виде структуры
<a href="../../doc/kernel/smp/ap_init/struct.BootStack.html"><code>kernel::smp::ap_init::BootStack</code></a>,
которая определена в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/smp/ap_init.rs"><code>kernel/src/smp/ap_init.rs</code></a>.</p>
<blockquote>
<p>В этой структуре есть поле
<a href="../../doc/kernel/smp/ap_init/struct.BootStack.html#structfield.small_gdt"><code>BootStack::small_gdt</code></a>.
Оно нужно по техническим причинам — в реальном режиме нужно чтобы адрес GDT был 24-битным.
Чтобы не накладывать такое ограничение на основную GDT ядра, в
<a href="../../doc/kernel/smp/ap_init/struct.BootStack.html"><code>kernel::smp::ap_init::BootStack</code></a>
и кладётся минимальная <code>small_gdt</code>, которая нужна только в функции
<a href="../../doc/kernel/smp/ap_init/fn.switch_from_real_mode_to_long_mode.html"><code>switch_from_real_mode_to_long_mode()</code></a>.
Далее в
<a href="../../doc/kernel/smp/ap_init/fn.init_ap.html"><code>kernel::smp::ap_init::init_ap()</code></a>
Application Processor переключится на основную GDT ядра.</p>
</blockquote>
<p>Подготовку кода и стека выполняет функция
<a href="../../doc/kernel/smp/ap_init/fn.prepare_boot_code.html"><code>kernel::smp::ap_init::prepare_boot_code()</code></a>.
Копирование кода она делегирует функции
<a href="../../doc/kernel/smp/ap_init/fn.copy_switch_mode_code.html"><code>kernel::smp::ap_init::copy_switch_mode_code()</code></a>,
а подготовку стека — методу
<a href="../../doc/kernel/smp/ap_init/struct.BootStack.html#method.new"><code>kernel::smp::ap_init::BootStack::new()</code></a>.</p>
<p>После подготовки кода и данных загрузчика,
<a href="../../doc/kernel/smp/ap_init/fn.boot_ap.html"><code>boot_ap()</code></a>
с помощью
<a href="../../doc/kernel/smp/local_apic/struct.LocalApic.html#method.send_init"><code>LocalApic::send_init()</code></a>
посылает AP специальное прерывание
<a href="../../doc/kernel/smp/local_apic/struct.InterruptCommand.html#associatedconstant.START_UP"><code>kernel::smp::local_apic::InterruptCommand::START_UP</code></a>
вместе с указанием, с какого адреса начинать исполнение — в нашем случае
<a href="../../doc/kernel/smp/ap_init/constant.BOOT_CODE.html"><code>BOOT_CODE</code></a>.
Код загрузчика
<a href="../../doc/kernel/smp/ap_init/fn.switch_from_real_mode_to_long_mode.html"><code>switch_from_real_mode_to_long_mode()</code></a>
переводит процессор в защищённый режим, настраивает сегменты кода и данных ядра и виртуальную память, необходимую для перехода к выполнению кода на языке Rust.
После этого она переключается с временного стека в стек ядра, который мы подготовили в
<a href="../../lab/book/4-concurrency-1-smp-2-cpus.html#%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-3--%D0%B2%D0%B5%D0%BA%D1%82%D0%BE%D1%80-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80-kernelsmpcpucpu">предыдущей задаче</a>.
И переходит в функцию
<a href="../../doc/kernel/smp/ap_init/fn.init_ap.html"><code>kernel::smp::ap_init::init_ap()</code></a>
из <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/smp/acpi_info.rs"><code>kernel/src/smp/acpi_info.rs</code></a>,
которая станет первой функцией на Rust, запущенной на AP.</p>
<p>Функция
<a href="../../doc/kernel/smp/ap_init/fn.init_ap.html"><code>init_ap()</code></a>
завершает инициализацию AP:</p>
<ul>
<li>Загружает основную <code>GDT</code> ядра. И переключает сегментные регистры на неё.</li>
<li>Инициализирует его local APIC методом <a href="../../doc/kernel/smp/local_apic/struct.LocalApic.html#method.init"><code>LocalApic::init()</code></a>.</li>
<li>Инициализирует регистры <code>FS</code> и <code>TSS</code> методами <a href="../../doc/kernel/smp/cpu/struct.Cpu.html#method.set_fs"><code>Cpu::set_fs()</code></a> и <a href="../../doc/kernel/smp/cpu/struct.Cpu.html#method.set_tss"><code>Cpu::set_tss()</code></a>.</li>
<li>Инициализирует регистр <code>IDTR</code> и включает прерывания.</li>
</ul>
<p>Все AP запускаются по очереди.
Функция
<a href="../../doc/kernel/smp/fn.init_smp.html"><code>kernel::smp::init_smp()</code></a>
из файла <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/smp/mod.rs"><code>kernel/src/smp/mod.rs</code></a> в цикле запускает
<a href="../../doc/kernel/smp/ap_init/fn.init_ap.html"><code>init_ap()</code></a>
для каждого из найденных в системе AP —
<a href="../../doc/kernel/smp/acpi_info/fn.usable_aps.html"><code>kernel::smp::acpi_info::usable_aps()</code></a>.
А функция
<a href="../../doc/kernel/smp/ap_init/fn.init_ap.html"><code>init_ap()</code></a>
перед выходом ждёт когда запущенный ею AP завершит свою инициализацию и сигнализирует об этом через
<a href="https://doc.rust-lang.org/nightly/core/sync/atomic/struct.AtomicBool.html"><code>core::sync::atomic::AtomicBool</code></a>.
Этот
<a href="https://doc.rust-lang.org/nightly/core/sync/atomic/struct.AtomicBool.html"><code>AtomicBool</code></a>
хранится на стеке функции
<a href="../../doc/kernel/smp/ap_init/fn.init_ap.html"><code>init_ap()</code></a>.
За ожидание на нём отвечает функция
<a href="../../doc/kernel/smp/ap_init/fn.wait_initialized.html"><code>kernel::smp::ap_init::wait_initialized()</code></a>,
а AP сигнализирует об окончании своей загрузки с помощью функции
<a href="../../doc/kernel/smp/ap_init/fn.signal_initialized.html"><code>kernel::smp::ap_init::signal_initialized()</code></a>.</p>
<h3 id="Задача-4--переключение-ap-в-64-битный-режим"><a class="header" href="#Задача-4--переключение-ap-в-64-битный-режим">Задача 4 — переключение AP в 64-битный режим</a></h3>
<p>Реализуйте <a href="../../doc/kernel/smp/ap_init/fn.switch_from_real_mode_to_long_mode.html">функцию</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn switch_from_real_mode_to_long_mode() -&gt; !
<span class="boring">}
</span></code></pre></pre>
<p>Она:</p>
<ul>
<li>Запускается в <a href="https://en.wikipedia.org/wiki/Real_mode">16-битном реальном режиме</a> и в процессе работы переключается в <a href="https://en.wikipedia.org/wiki/Long_mode">64-битный режим</a> напрямую, минуя <a href="https://en.wikipedia.org/wiki/Protected_mode">32-х битный защищённый режим</a>. Это делается аналогично статье <a href="https://wiki.osdev.org/Entering_Long_Mode_Directly">Entering Long Mode Directly</a>. Но гораздо проще, так как все нужные структуры и значения регистров код на Rust копирует с BSP в <a href="../../doc/kernel/smp/ap_init/struct.BootStack.html"><code>kernel::smp::ap_init::BootStack</code></a>.</li>
<li>Должна настроить сегментные регистры и переключиться на временный стек по адресу записанному в константе <a href="../../doc/kernel/smp/ap_init/constant.BOOT_STACK.html"><code>kernel::smp::ap_init::BOOT_STACK</code></a>.</li>
<li>Инициализирует системные регистры, переданные через временный стек. В частности, страничное отображение и GDT.</li>
<li>После инициализации GDT, переинициализирует сегментные регистры селекторами новой GDT. Для переинициализации <code>CS</code> можно использовать <a href="https://www.felixcloutier.com/x86/ret"><code>far ret</code></a>. Использовать <a href="https://www.felixcloutier.com/x86/jmp"><code>far jmp</code></a> не получится, так как для него селектор сегмента кода должен быть константой, а нам хочется передать селектор кода переменной. Она записана в поле <a href="../../doc/kernel/smp/ap_init/struct.BootStack.html#structfield.kernel_code"><code>BootStack::kernel_code</code></a>. Обратите внимание на следующий момент в документации <a href="https://www.felixcloutier.com/x86/ret"><code>far ret</code></a>: <code>In 64-bit mode ... the default operation size of far returns is 32 bits</code>.</li>
<li>Далее, после метки <code>set_cs_rip_to_64bit</code>, забирает с временного стека аргументы для функции <a href="../../doc/kernel/smp/ap_init/fn.init_ap.html"><code>init_ap()</code></a>. И помещает их в регистры, в соответствии с <a href="https://wiki.osdev.org/System_V_ABI#x86-64">x86-64 C ABI</a>.</li>
<li>Финальным аккордом переключается в выделенный данному CPU в <a href="../../lab/book/4-concurrency-1-smp-2-cpus.html#%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-3--%D0%B2%D0%B5%D0%BA%D1%82%D0%BE%D1%80-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80-kernelsmpcpucpu">предыдущей задаче</a> стек ядра и передаёт управление в функцию <a href="../../doc/kernel/smp/ap_init/fn.init_ap.html"><code>init_ap()</code></a>.</li>
</ul>
<p>Поля в
<a href="../../doc/kernel/smp/ap_init/struct.BootStack.html"><code>BootStack</code></a>
организованы в удобном для референсного кода порядке.
В частности, поля с селектором кода
<a href="../../doc/kernel/smp/ap_init/struct.BootStack.html#structfield.kernel_code"><code>BootStack::kernel_code</code></a>
и релоцированным адресом
<a href="../../doc/kernel/smp/ap_init/struct.BootStack.html#structfield.set_cs_rip_to_64bit"><code>BootStack::set_cs_rip_to_64bit</code></a>
метки <code>set_cs_rip_to_64bit:</code> лежат так, что образуют
<a href="https://en.wikipedia.org/wiki/Far_pointer">far pointer</a>
<code>kernel_code:set_cs_rip_to_64bit</code>, который может быть использован инструкцией <code>far ret</code> как есть.
Вы можете менять порядок полей и их состав, так как удобнее вам.</p>
<p>Метки <code>switch_mode_start</code> и <code>switch_mode_end</code> отмечают границы загрузочного кода,
который должен быть скопирован.
Поэтому пишите код загрузки AP строго внутри них.</p>
<p>Для передачи управления в функцию
<a href="../../doc/kernel/smp/ap_init/fn.init_ap.html"><code>init_ap()</code></a>
стоит использовать косвенный
<a href="https://www.felixcloutier.com/x86/jmp"><code>jmp</code></a>
по её абсолютному адресу.
Так как код вызывающей функции
<a href="../../doc/kernel/smp/ap_init/fn.switch_from_real_mode_to_long_mode.html"><code>switch_from_real_mode_to_long_mode()</code></a>
будет релоцирован по адресу
<a href="../../doc/kernel/smp/ap_init/constant.BOOT_CODE.html"><code>BOOT_CODE</code></a>,
относительные адреса в нём работать не будут.
Непосредственный
<a href="https://www.felixcloutier.com/x86/jmp"><code>jmp</code></a>
перешёл бы по относительному адресу, то есть гарантированно сломался бы из-за релокации кода загрузки AP.
Это было бы видно в его машинном коде в дизассемблере — у непосредственного
<a href="https://www.felixcloutier.com/x86/jmp"><code>jmp</code></a>
в машинном коде было бы смещение, которое не совпадало бы с абсолютным адресом
<a href="../../doc/kernel/smp/ap_init/fn.init_ap.html"><code>init_ap()</code></a>.
При этом для удобства пользователя в мнемонике дизассемблер показал бы абсолютный адрес.
А <a href="https://www.felixcloutier.com/x86/jmp"><code>jmp</code></a>
предпочтительнее чем
<a href="https://www.felixcloutier.com/x86/call"><code>call</code></a>,
так как возвращаться функция
<a href="../../doc/kernel/smp/ap_init/fn.init_ap.html"><code>init_ap()</code></a>
не будет.
Это видно по возвращаемому
<a href="https://doc.rust-lang.ru/book/ch19-04-advanced-types.html#%D0%A2%D0%B8%D0%BF-never-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B9-%D0%BD%D0%B8%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0-%D0%BD%D0%B5-%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D1%82%D1%81%D1%8F">типу <em>никогда</em></a> —
<code>!</code> — в её сигнатуре.
А значит, адрес возврата просто съел бы место в стеке ядра.
Для получения абсолютного адреса определённой в том же исходном файле метки, и в том числе функции,
в ассемблере можно использовать выражение <code>OFFSET init_ap</code>.</p>
<p>При желании вы можете отступить от предложенной схемы загрузки AP и реализовать любой другой работающий вариант.
Также, можно передать через
<a href="../../doc/kernel/smp/ap_init/struct.BootStack.html"><code>BootStack</code></a>
какую-либо дополнительную информацию.</p>
<p>Учтите, что дело осложняется тем, что до завершения инициализации AP, ни логирования, ни обработки исключений, ни других удобных для отладки вещей доступно не будет.
И, например, в случае возникновения любого исключения до вызова <code>IDT.load()</code>, вся система просто перезагрузится.
К счастью, мы запускаем Nikka в эмуляторе, и перезагрузится эмулируемая машина.
Кроме того, эмулятор <a href="../../lab/book/0-intro-5-gdb.html">позволяет подключиться к ядру отладчиком</a> и выполнять код функции
<a href="../../doc/kernel/smp/ap_init/fn.switch_from_real_mode_to_long_mode.html"><code>switch_from_real_mode_to_long_mode()</code></a>
пошагово.</p>
<h4 id="Дизассемблирование-с-помощью-objdump"><a class="header" href="#Дизассемблирование-с-помощью-objdump">Дизассемблирование с помощью <code>objdump</code></a></h4>
<p>При использовании отладчика и дизассемблера, учтите что <code>.code16</code> и <code>.code64</code> — макрокоманды,
которые не записываются в машинный код сами по себе.
Но они влияют на порождаемый машинный код — декодирование инструкций в
<a href="https://en.wikipedia.org/wiki/X86-64">x86-64</a>
зависит от режима работы процессора.
Дизассемблер ничего не знает про макрокоманды, так как их нет в машинном коде.
И, чтобы знать в каком режиме дизассемблировать код, ему либо нужна подсказка,
либо он должен хранить состояние процессора.
Иначе он будет показывать ерунду, которая сбивает с толку.
Теоретически понимать в каком режиме находится процессор мог бы отладчик,
но не произвольный дизассемблер вроде <code>objdump</code>.
Поэтому кроме мнемоник в дизассемблере в этой задаче полезно обращать внимание и на машинные коды.</p>
<p>Дизассемблировать ваш код до метки <code>set_cs_rip_to_64bit</code> можно указав архитектуру <code>i8086</code>:</p>
<pre><code class="language-console">$ objdump --disassemble --architecture=i8086 --section=.switch_from_real_mode_to_long_mode --demangle --stop-address=$(objdump --syms target/kernel/debug/kernel | grep set_cs_rip_to_64bit | sed 's/^0*\([^ ]*\).*$/0x\1/') target/kernel/debug/kernel

target/kernel/debug/kernel:     file format elf64-x86-64


Disassembly of section .switch_from_real_mode_to_long_mode:

0000000000312c30 &lt;kernel::smp::ap_init::switch_from_real_mode_to_long_mode&gt;:
  312c30:	.. /* машинный код */	...    /* мнемоники вашего кода *
  ...
  ......:	cb                   	lret   /* то как дизассемблируется retf в неправильном режиме (он в коде уже в .code64) */

</code></pre>
<p>А после метки <code>set_cs_rip_to_64bit</code> код уже сформирован для 64–битного режима, как и весь файл.
Поэтому после неё архитектуру указывать не нужно:</p>
<pre><code class="language-code">$ objdump -d --section=.switch_from_real_mode_to_long_mode --demangle --start-address=$(objdump --syms target/kernel/debug/kernel | grep set_cs_rip_to_64bit | sed 's/^0*\([^ ]*\).*$/0x\1/') target/kernel/debug/kernel

target/kernel/debug/kernel:     file format elf64-x86-64


Disassembly of section .switch_from_real_mode_to_long_mode:

0000000000...... &lt;set_cs_rip_to_64bit&gt;:
  ......:	.. /* машинный код */	...    /* мнемоники вашего кода *
  ...

0000000000...... &lt;switch_mode_end&gt;:
  ......:	0f 0b                	ud2
</code></pre>
<p>В этом дампе вы можете разглядеть ошибки.
Например, если вы воспользуетесь относительным
<a href="https://www.felixcloutier.com/x86/jmp"><code>jmp</code></a>
вместо абсолютного, то увидите что-то вроде:</p>
<pre><code class="language-console">  312c75:	e9 a6 63 f6 ff       	jmp    279020 &lt;init_ap&gt;

0000000000312c7a &lt;switch_mode_end&gt;:
</code></pre>
<p>В машинном коде нет ни намёка на правильный адрес, хотя дизассемблер и подставил его в
мнемонику <code>jmp    279020 &lt;init_ap&gt;</code>.
Так как в машинном коде в обратном порядке байтов указано смещение <code>a6 63 f6 ff</code>
абсолютного адреса <code>0x279020 &lt;init_ap&gt;</code> относительно адреса следующей инструкции:</p>
<pre><code class="language-console">(gdb) print /x 0x279020 - 0x312c7a
$1 = 0xfff663a6
</code></pre>
<p>А значит, после релокации такой код сломается, так как адрес следующей инструкции будет уже другой.</p>
<h4 id="Дизассемблирование-в-gdb"><a class="header" href="#Дизассемблирование-в-gdb">Дизассемблирование в <code>gdb</code></a></h4>
<p>Для указания архитектуры в <code>gdb</code> есть команда <code>set architecture</code>:</p>
<pre><code class="language-console">(gdb) file target/kernel/debug/kernel
(gdb) set architecture
Requires an argument. Valid arguments are i386, i386:x86-64, i386:x64-32, i8086, i386:intel, i386:x86-64:intel, i386:x64-32:intel, auto.
(gdb) set architecture i8086
The target architecture is set to &quot;i8086&quot;.
(gdb) disassemble switch_from_real_mode_to_long_mode, set_cs_rip_to_64bit
Dump of assembler code from 0x312c30 to 0x......:
   0x00312c30 &lt;...+0&gt;:	...	/* мнемоники вашего кода *
   ...
   0x00...... &lt;...+..&gt;:	lret	/* то как дизассемблируется retf в неправильном режиме (он в коде уже в .code64) */
End of assembler dump.
(gdb) set architecture i386:x86-64
The target architecture is set to &quot;i386:x86-64&quot;.
(gdb) disassemble set_cs_rip_to_64bit, switch_mode_end
Dump of assembler code from 0x...... to 0x......:
   0x0000000000...... &lt;...+..&gt;:	...	/* мнемоники вашего кода *
   ...
End of assembler dump.
</code></pre>
<h4 id="Пошаговое-выполнение-в-gdb"><a class="header" href="#Пошаговое-выполнение-в-gdb">Пошаговое выполнение в <code>gdb</code></a></h4>
<p>Аналогично можно указать архитектуру при подключении <code>gdb</code> к <code>qemu</code>.
Сначала запустите тест, чтобы подглядеть нужные аргументы <code>qemu</code>:</p>
<pre><code class="language-console">$ cd kernel; cargo test --test 4-concurrency-4-ap-init 2&gt;/dev/null | grep qemu
Running: `qemu-system-x86_64 -drive format=raw,file=/.../target/kernel/debug/deps/bootimage-4_concurrency_4_ap_init-91a7e203d980f479.bin -no-reboot -m size=128M -smp cpus=4 -device isa-debug-exit,iobase=0xF4,iosize=0x04 -serial stdio -display none`
...
</code></pre>
<p>Дальше в одной консоли запустите <code>qemu</code>, взяв команду из теста и добавив к ней опции <code>-gdb tcp::1234 -S</code>:</p>
<pre><code class="language-console">$ qemu-system-x86_64 -drive format=raw,file=/.../target/kernel/debug/deps/bootimage-4_concurrency_4_ap_init-91a7e203d980f479.bin -no-reboot -m size=128M -smp cpus=4 -device isa-debug-exit,iobase=0xF4,iosize=0x04 -serial stdio -display none -gdb tcp::1234 -S
</code></pre>
<p>Он будет ждать подключения <code>gdb</code>.</p>
<p>То же самое сделает запуск скрипта</p>
<pre><code class="language-console">$ ./run-gdb.sh 4-concurrency-4-ap-init
</code></pre>
<p>Теперь в другой консоли запустите <code>gdb</code>:</p>
<pre><code class="language-console">$ gdb
...
</code></pre>
<p>Команду <code>file</code> можно указать, но это не обязательно:</p>
<pre><code class="language-console">(gdb) file target/kernel/debug/kernel
</code></pre>
<p>Подключитесь к <code>localhost:1234</code>:</p>
<pre><code class="language-console">(gdb) target remote localhost:1234
Remote debugging using localhost:1234
0x000000000000fff0 in ?? ()
(gdb) break *0x7000
Breakpoint 1 at 0x7000
(gdb) continue
Continuing.

Thread 2 received signal SIGTRAP, Trace/breakpoint trap.
[Switching to Thread 1.2]
0x0000000000000000 in ?? ()
</code></pre>
<p>Установите архитектуру, хотя <code>gdb</code> и выдаст предупреждения:</p>
<pre><code class="language-console">(gdb) set architecture i8086
warning: Selected architecture i8086 is not compatible with reported target architecture i386:x86-64
warning: A handler for the OS ABI &quot;GNU/Linux&quot; is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

Architecture `i8086' not recognized.
The target architecture is set to &quot;i8086&quot;.
</code></pre>
<p>Ноль в качестве текущего адреса — <code>0x0000000000000000 in ?? ()</code> показывается потому что <code>CS:IP</code> равно <code>0x700:0x0</code>, а не эквивалентное <code>0x0:0x7000</code>:</p>
<pre><code class="language-console">(gdb) info registers
...
rip            0x0                 0x0
eflags         0x2                 [ IOPL=0 ]
cs             0x700               1792
...
(gdb) print /x $cs * 16 + $rip
$1 = 0x7000
</code></pre>
<p>Теперь можно дизассемблировать и пройти по коду пошагово:</p>
<pre><code class="language-console">(gdb) disassemble 0x7000, 0x7100
Dump of assembler code from 0x7000 to 0x7100:
   0x0000000000007000:	...	/* мнемоники вашего кода *
   ...
(gdb) stepi
0x00000000000000.. in ?? ()
</code></pre>
<p>Будьте готовы к тому что на написание и отладку этой задачи может потребоваться много времени.</p>
<h3 id="Проверьте-себя-12"><a class="header" href="#Проверьте-себя-12">Проверьте себя</a></h3>
<p>Запустите тест <code>4-concurrency-4-ap-init</code> из файла
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/4-concurrency-4-ap-init.rs"><code>kernel/tests/4-concurrency-4-ap-init.rs</code></a>.
Сразу после времени логирование печатает номер текущего процессора.
Теперь их у нас четыре:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 4-concurrency-4-ap-init)
...
4_concurrency_4_ap_init::ap_init----------------------------
20:26:45 0 I acpi_info = AcpiInfo { local_apic_address: Phys(0pFEE00000), bsp_id: 0, ap_ids: [1, 2, 3] }
20:26:45 0 I Local APIC init; cpu = 0; cpu_count = 4; local_apic_address = 0pFEE00000
20:26:46 0 D set FS register to Cpu structure address; cpu = 0; fs = 0v7FFFFFEB8000
20:26:46 0 I Bootstrap Processor; cpu = 0
20:26:46 0 D boot_stack = { efer: 0xD01, cr4: 0x20, cr3: 0x1000, cr0: 0x80010011, gdt: { base: 0p007FD8, limit: 0x0027 }, kernel_code: SegmentSelector { index: 1, rpl: Ring0 }, kernel_data: SegmentSelector { index: 2, rpl: Ring0 }, set_cs_rip_to_64bit: 0p7035, kernel_stack: 0v7FFFFFEE9000, cpu: 0v7FFFFFEB8100, initialized: 0v10000200418 }
20:26:46 1 D set FS register to Cpu structure address; cpu = 1; fs = 0v7FFFFFEB8100
20:26:46 1 I report for duty; cpu = 1
20:26:46 0 I cpu = 1; duration = 30.504 ms; &quot;boot Application Processor&quot;
20:26:46 1 I arrived at the barrier; cpu = 1; cpu_count = 4; cpus_waiting = 0; last = false
20:26:46 0 D boot_stack = { efer: 0xD01, cr4: 0x20, cr3: 0x1000, cr0: 0x80010011, gdt: { base: 0p007FD8, limit: 0x0027 }, kernel_code: SegmentSelector { index: 1, rpl: Ring0 }, kernel_data: SegmentSelector { index: 2, rpl: Ring0 }, set_cs_rip_to_64bit: 0p7035, kernel_stack: 0v7FFFFFF09000, cpu: 0v7FFFFFEB8200, initialized: 0v10000200418 }
20:26:46 2 D set FS register to Cpu structure address; cpu = 2; fs = 0v7FFFFFEB8200
20:26:46 2 I report for duty; cpu = 2
20:26:46 0 I cpu = 2; duration = 30.957 ms; &quot;boot Application Processor&quot;
20:26:46 2 I arrived at the barrier; cpu = 2; cpu_count = 4; cpus_waiting = 1; last = false
20:26:46 0 D boot_stack = { efer: 0xD01, cr4: 0x20, cr3: 0x1000, cr0: 0x80010011, gdt: { base: 0p007FD8, limit: 0x0027 }, kernel_code: SegmentSelector { index: 1, rpl: Ring0 }, kernel_data: SegmentSelector { index: 2, rpl: Ring0 }, set_cs_rip_to_64bit: 0p7035, kernel_stack: 0v7FFFFFF29000, cpu: 0v7FFFFFEB8300, initialized: 0v10000200418 }
20:26:46 3 D set FS register to Cpu structure address; cpu = 3; fs = 0v7FFFFFEB8300
20:26:46 3 I report for duty; cpu = 3
20:26:46 0 I cpu = 3; duration = 30.971 ms; &quot;boot Application Processor&quot;
20:26:46 3 I arrived at the barrier; cpu = 3; cpu_count = 4; cpus_waiting = 2; last = false
20:26:46 0 I arrived at the barrier; cpu = 0; cpu_count = 4; cpus_waiting = 3; last = true
20:26:46 1 I all CPUs have arrived at the barrier; cpu = 1; cpu_count = 4
20:26:46 3 I all CPUs have arrived at the barrier; cpu = 3; cpu_count = 4
20:26:46 0 I all CPUs have arrived at the barrier; cpu = 0; cpu_count = 4
20:26:46 2 I all CPUs have arrived at the barrier; cpu = 2; cpu_count = 4
20:26:47.485 1 I AP halted; cpu = 1
20:26:47.491 3 I AP halted; cpu = 3
20:26:47.495 0 I racy_counter = 14031486; racefree_counter = 20000000
4_concurrency_4_ap_init::ap_init------------------- [passed]
20:26:47.503 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<blockquote>
<p>Попробуйте реализовать <code>RACY_COUNTER</code> из теста без <code>unsafe</code>.</p>
</blockquote>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-16"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-16">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/smp/ap_init.rs |   55 +++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 52 insertions(+), 3 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Таблица-процессов"><a class="header" href="#Таблица-процессов">Таблица процессов</a></h2>
<p>Код таблицы процессов находится в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/table.rs"><code>kernel/src/process/table.rs</code></a>.</p>
<h3 id="Идентификаторы-процессов-kuprocesspidpid"><a class="header" href="#Идентификаторы-процессов-kuprocesspidpid">Идентификаторы процессов <a href="../../doc/ku/process/pid/enum.Pid.html"><code>ku::process::pid::Pid</code></a></a></h3>
<p>В файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/process/pid.rs"><code>ku/src/process/pid.rs</code></a> описана структура</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, Eq, PartialEq)]
pub enum Pid {
    Current,
    Id {
        slot: u16,
        epoch: u32,
    },
}
<span class="boring">}
</span></code></pre></pre>
<p>Она позволяет отдельно указывать либо
<a href="../../doc/ku/process/pid/enum.Pid.html#variant.Current"><code>Pid::Current</code></a> —
текущий процесс, это удобно для использования тех системных вызовов, что принимают на вход
<a href="../../doc/ku/process/pid/enum.Pid.html"><code>Pid</code></a>.
Либо конкретный процесс
<a href="../../doc/ku/process/pid/enum.Pid.html#variant.Id"><code>Pid::Id</code></a>,
идентификатор которого состоит из номера слота в таблице процессов
<a href="../../doc/ku/process/pid/enum.Pid.html#variant.Id.field.slot"><code>slot</code></a>
и эпохи этого слота
<a href="../../doc/ku/process/pid/enum.Pid.html#variant.Id.field.epoch"><code>epoch</code></a>.
Поле <a href="../../doc/ku/process/pid/enum.Pid.html#variant.Id.field.slot"><code>slot</code></a> позволяет быстро находить процесс по его идентификатору в таблице процессов, —
она может быть устроена как вектор, а не как хеш-таблица.
А <a href="../../doc/ku/process/pid/enum.Pid.html#variant.Id.field.epoch"><code>epoch</code></a> позволяет сделать идентификаторы процессов уникальными на протяжении всего времени работы системы.</p>
<p>Например, в Unix есть гонка, из-за того что одно и то же значение <code>pid_t</code> может в разное время ссылаться на разные процессы.
Если вы хотите что-то сделать с определённым процессом, и записали его <code>pid_t</code> себе,
то конкурентно он может прекратить своё исполнение, а ядро выдаст то же самое значение <code>pid_t</code> новому процессу.
Теперь вы что-то делаете с процессом по сохранённому у себя <code>pid_t</code>, например, посылаете ему сигнал <code>SIGKILL</code>, но это уже другой процесс.
Реализации пытаются уменьшить вероятность таких гонок за счёт выдачи <code>pid_t</code> по кругу.
В Nikka для избежания гонки, каждый раз, когда новый процесс получает тот же
<a href="../../doc/ku/process/pid/enum.Pid.html#variant.Id.field.slot"><code>slot</code></a>,
он получает на единицу большее значение
<a href="../../doc/ku/process/pid/enum.Pid.html#variant.Id.field.epoch"><code>epoch</code></a>.
За это отвечает метод
<a href="../../doc/ku/process/pid/enum.Pid.html#method.next_epoch"><code>Pid::next_epoch()</code></a>.</p>
<p>Другие методы <a href="../../doc/ku/process/pid/enum.Pid.html"><code>Pid</code></a>:</p>
<ul>
<li><a href="../../doc/ku/process/pid/enum.Pid.html#method.new"><code>Pid::new(slot)</code></a> создаёт <a href="../../doc/ku/process/pid/enum.Pid.html"><code>Pid</code></a> с начальным значением <a href="../../doc/ku/process/pid/enum.Pid.html#variant.Id.field.epoch"><code>epoch</code></a> для заданного <code>slot</code>.</li>
<li><a href="../../doc/ku/process/pid/enum.Pid.html#method.slot"><code>Pid::slot()</code></a> возвращает значение <a href="../../doc/ku/process/pid/enum.Pid.html#variant.Id.field.slot"><code>slot</code></a>.</li>
<li><a href="../../doc/ku/process/pid/enum.Pid.html#method.into_usize"><code>Pid::into_usize()</code></a> и <a href="../../doc/ku/process/pid/enum.Pid.html#method.from_usize"><code>Pid::from_usize()</code></a> позволяют сериализовать <a href="../../doc/ku/process/pid/enum.Pid.html"><code>Pid</code></a> в регистр для передачи в системные вызовы.</li>
</ul>
<h3 id="Слот-таблицы-процессов-kernelprocesstableslot"><a class="header" href="#Слот-таблицы-процессов-kernelprocesstableslot">Слот таблицы процессов <a href="../../doc/kernel/process/table/enum.Slot.html"><code>kernel::process::table::Slot</code></a></a></h3>
<p>Таблица процессов состоит из фиксированного количества слотов</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Slot {
    Free {
        pid: Pid,
        next: Option&lt;Pid&gt;,
    },
    Occupied {
        process: Mutex&lt;Process&gt;,
    },
}
<span class="boring">}
</span></code></pre></pre>
<p>Каждый из которых либо свободен —
<a href="../../doc/kernel/process/table/enum.Slot.html#variant.Free"><code>Slot::Free</code></a>,
либо занят —
<a href="../../doc/kernel/process/table/enum.Slot.html#variant.Occupied"><code>Slot::Occupied</code></a>.</p>
<p>Свободные слоты содержат поле
<a href="../../doc/kernel/process/table/enum.Slot.html#variant.Free.field.pid"><code>pid</code></a>
для того, что помнить эпоху последнего процесса, занимавшего этот слот.
И выдать следующему процессу, который попадёт в тот же слот, номер эпохи на единицу больше.
Также свободные слоты провязаны в список, чтобы удобнее было за \(O(1)\)
находить какой-нибудь свободный слот под новый процесс.</p>
<p>Занятые слоты содержат спинлок
<a href="../../doc/kernel/process/table/enum.Slot.html#variant.Occupied.field.process"><code>process</code></a>.
Когда нам понадобится обратиться к процессу, нужно будет захватить его спинлок,
чтобы избежать неконсистентного конкурентного изменения структуры
<a href="../../doc/kernel/process/process/struct.Process.html"><code>kernel::process::process::Process</code></a>.
Чтобы обратиться с самой таблице процессов
<a href="../../doc/kernel/process/table/struct.TABLE.html"><code>static ref kernel::process::table::TABLE: Mutex&lt;Table&gt;</code></a>,
конечно тоже нужно захватить её общий спинлок.
Но не хочется держать заблокированным спинлок всей таблицы, пока мы работаем со структурой
<a href="../../doc/kernel/process/process/struct.Process.html"><code>kernel::process::process::Process</code></a>
одного её процесса.
Поэтому, таблица будет по идентификатору процесса
<a href="../../doc/ku/process/pid/enum.Pid.html"><code>Pid</code></a>
фактически обменивать заблокированный спинлок <code>Mutex&lt;Table&gt;</code> на заблокированный спинлок процесса <code>Mutex&lt;Process&gt;</code>.
После чего вызывающий код сможет работать с процессом конкурентно другому коду,
который сможет захватить уже освободившийся <code>Mutex&lt;Table&gt;</code>.</p>
<h3 id="Задача-5--таблица-процессов"><a class="header" href="#Задача-5--таблица-процессов">Задача 5 — таблица процессов</a></h3>
<h4 id="Инициализация-таблицы"><a class="header" href="#Инициализация-таблицы">Инициализация таблицы</a></h4>
<p>Реализуйте <a href="../../doc/kernel/process/struct.Table.html#method.new">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Table::new(len: usize) -&gt; Self
<span class="boring">}
</span></code></pre></pre>
<p>Он создаёт таблицу процессов
<a href="../../doc/kernel/process/struct.Table.html#structfield.table"><code>Table::table</code></a>
размера <code>len</code> элементов, заполняя её пустыми слотами
<a href="../../doc/kernel/process/table/enum.Slot.html#variant.Free"><code>Slot::Free</code></a>
с соответствующими индексам слотов полями
<a href="../../doc/ku/process/pid/enum.Pid.html#variant.Id.field.slot"><code>Pid::Id::slot</code></a>.
Эти пустые слоты он провязывает в односвязный список с головой в поле
<a href="../../doc/kernel/process/struct.Table.html#structfield.free"><code>Table::free</code></a>.
Чтобы избежать переаллокаций, рекомендуется использовать метод
<a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.with_capacity"><code>alloc::vec::Vec::with_capacity()</code></a>.</p>
<h4 id="Аллокация-слота-под-процесс"><a class="header" href="#Аллокация-слота-под-процесс">Аллокация слота под процесс</a></h4>
<p>Реализуйте <a href="../../doc/kernel/process/struct.Table.html#method.allocate">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Table::allocate(mut process: Process) -&gt; Result&lt;Pid&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Он должен выделить новому процессу <code>process</code> свободный слот таблицы.
Слот возьмите из головы списка свободных
<a href="../../doc/kernel/process/struct.Table.html#structfield.free"><code>Table::free</code></a>.
Запишите в него <code>process</code>, а
<a href="../../doc/kernel/process/table/enum.Slot.html#variant.Free.field.pid"><code>pid</code></a>
слота запишите в структуру процесса <code>process</code> методом
<a href="../../doc/kernel/process/process/struct.Process.html#method.set_pid"><code>Process::set_pid()</code></a>.
Если же свободного слота нет, верните ошибку
<a href="../../doc/kernel/error/enum.Error.html#variant.NoProcessSlot"><code>Error::NoProcessSlot</code></a>.
В этом случае при выходе из метода, <code>process</code> будет автоматически уничтожен, а все его ресурсы освобождены.
Так как по сигнатуре
<a href="../../doc/kernel/process/struct.Table.html#method.allocate"><code>Table::allocate(process: Process)</code></a>
поглощает свой аргумент.
Этот и все последующие методы — статические, они оперируют с глобальным
<a href="https://en.wikipedia.org/wiki/Singleton_pattern">синглтоном</a>
<a href="../../doc/kernel/process/table/struct.TABLE.html"><code>static ref TABLE: Mutex&lt;Table&gt;</code></a>,
захватывая его блокировку — <code>TABLE.lock()</code>.
При реализации вам может пригодиться метод
<a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#method.take"><code>Option::take()</code></a>.</p>
<h4 id="Получение-процесса-по-его-идентификатору"><a class="header" href="#Получение-процесса-по-его-идентификатору">Получение процесса по его идентификатору</a></h4>
<p>Реализуйте <a href="../../doc/kernel/process/struct.Table.html#method.get">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Table::get(pid: Pid) -&gt; Result&lt;MutexGuard&lt;'static, Process&gt;&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Он возвращает заблокированный спинлок
<a href="../../doc/spin/mutex/struct.MutexGuard.html"><code>spin::mutex::MutexGuard</code></a>
со структурой
<a href="../../doc/kernel/process/process/struct.Process.html"><code>kernel::process::process::Process</code></a>,
соответствующей идентификатору <code>pid</code>.
Верните ошибку
<a href="../../doc/kernel/error/enum.Error.html#variant.NoProcess"><code>Error::NoProcess</code></a>,
если процесса по указанному <code>pid</code> нет.
То есть, если либо не занят <code>pid.slot()</code>, либо в этом слоте у процесса другое значение
<a href="../../doc/kernel/process/process/struct.Process.html#method.pid"><code>kernel::process::process::Process::pid()</code></a>
(значит у него другая эпоха
<a href="../../doc/ku/process/pid/enum.Pid.html#variant.Id.field.epoch"><code>Pid::epoch</code></a>,
так как слот
<a href="../../doc/ku/process/pid/enum.Pid.html#variant.Id.field.slot"><code>Pid::slot</code></a>
должен совпадать).
Вытащить значение
<a href="../../doc/ku/process/pid/enum.Pid.html#variant.Id.field.epoch"><code>epoch</code></a> тип
<a href="../../doc/ku/process/pid/enum.Pid.html"><code>Pid</code></a>
не позволяет, но зато он позволяет сравнивать два своих значения на равенство за счёт реализации
<code>#[derive(..., Eq, PartialEq)]</code>.</p>
<p>Так как размер таблицы процессов
<a href="../../doc/kernel/process/table/struct.TABLE.html"><code>static ref TABLE: Mutex&lt;Table&gt;</code></a>
после инициализации мы никогда не меняем, и в частности не уменьшаем,
время жизни каждого её слота — практически <code>'static</code>.
Который и указан в результирующем типе метода
<a href="../../doc/kernel/process/struct.Table.html#method.get"><code>Table::get()</code></a>.
Но Rust не может проверить это самостоятельно.
Нам придётся пообещать ему это с помощью
<a href="../../doc/kernel/process/table/fn.forge_static_lifetime.html">unsafe–функции</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn forge_static_lifetime&lt;T&gt;(x: &amp;T) -&gt; &amp;'static T
<span class="boring">}
</span></code></pre></pre>
<p>Естественно, чтобы вернуть
<a href="../../doc/spin/mutex/struct.MutexGuard.html"><code>MutexGuard</code></a>
нужно заблокировать процесс в слоте методом
<a href="../../doc/spin/mutex/struct.Mutex.html#method.lock"><code>Mutex::lock()</code></a>.
Спинлок же самой
<a href="../../doc/kernel/process/table/struct.TABLE.html"><code>TABLE</code></a>
будет автоматически разблокирован аналогичным гардом при выходе из функции.
Получается, что она в начале захватывает низкогранулярную блокировку на всю таблицу
<a href="../../doc/kernel/process/table/struct.TABLE.html"><code>TABLE</code></a>,
а потом повышает гранулярность этой блокировки до блокировки одного слота таблицы.
И вызывающая функции в дальнейшем работает уже с высокогранулярной блокировкой.</p>
<h4 id="Освобождение-слота-с-уничтожением-процесса"><a class="header" href="#Освобождение-слота-с-уничтожением-процесса">Освобождение слота с уничтожением процесса</a></h4>
<p>Реализуйте <a href="../../doc/kernel/process/struct.Table.html#method.free">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Table::free(process: MutexGuard&lt;Process&gt;)
<span class="boring">}
</span></code></pre></pre>
<p>Он:</p>
<ul>
<li>Удаляет процесс <code>process</code>.</li>
<li>Инкрементирует эпоху в освободившемся слоте.</li>
<li>Вставляет слот в голову списка свободных слотов <a href="../../doc/kernel/process/struct.Table.html#structfield.free"><code>Table::free</code></a>.</li>
</ul>
<p>Вам могут пригодиться функции
<a href="https://doc.rust-lang.org/nightly/core/mem/fn.drop.html"><code>drop()</code></a> и
<a href="https://doc.rust-lang.org/nightly/core/mem/fn.replace.html"><code>core::mem::replace()</code></a>.</p>
<h3 id="Проверьте-себя-13"><a class="header" href="#Проверьте-себя-13">Проверьте себя</a></h3>
<p>Теперь должны заработать тесты <code>basic()</code> и <code>full_capacity()</code> в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/4-concurrency-5-table.rs"><code>kernel/tests/4-concurrency-5-table.rs</code></a>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 4-concurrency-5-table)
...
4_concurrency_5_table::basic--------------------------------
20:26:51 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:26:51 0 I duplicate; address_space = &quot;process&quot; @ 0p7E8A000
20:26:51 0 I switch to; address_space = &quot;process&quot; @ 0p7E8A000
20:26:51 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:26:51 0 I allocate; slot = Process { pid: 0:0, address_space: &quot;0:0&quot; @ 0p7E8A000, { rip: 0v0, rsp: 0v0 } }; process_count = 1
20:26:51 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:26:51 0 I duplicate; address_space = &quot;process&quot; @ 0p7E74000
20:26:51 0 I switch to; address_space = &quot;process&quot; @ 0p7E74000
20:26:51 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:26:51 0 I allocate; slot = Process { pid: 1:0, address_space: &quot;1:0&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 2
20:26:51 0 D pid_1 = 0:0; pid_2 = 1:0
20:26:51 0 I free; slot = Process { pid: 0:0, address_space: &quot;0:0&quot; @ 0p7E8A000, { rip: 0v0, rsp: 0v0 } }; process_count = 1
20:26:51 0 I drop; address_space = &quot;0:0&quot; @ 0p7E8A000
20:26:51 0 I free; slot = Process { pid: 1:0, address_space: &quot;1:0&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 0
20:26:51 0 I drop; address_space = &quot;1:0&quot; @ 0p7E74000
4_concurrency_5_table::basic----------------------- [passed]

4_concurrency_5_table::full_capacity------------------------
20:26:51 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:26:51 0 I duplicate; address_space = &quot;process&quot; @ 0p7E74000
20:26:51 0 I switch to; address_space = &quot;process&quot; @ 0p7E74000
20:26:51 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:26:51 0 I allocate; slot = Process { pid: 1:1, address_space: &quot;1:1&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 1
20:26:51 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:26:51 0 I duplicate; address_space = &quot;process&quot; @ 0p7E79000
20:26:51 0 I switch to; address_space = &quot;process&quot; @ 0p7E79000
20:26:51 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:26:51 0 I allocate; slot = Process { pid: 0:1, address_space: &quot;0:1&quot; @ 0p7E79000, { rip: 0v0, rsp: 0v0 } }; process_count = 2
20:26:51 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:26:51 0 I duplicate; address_space = &quot;process&quot; @ 0p7E5C000
20:26:51 0 I switch to; address_space = &quot;process&quot; @ 0p7E5C000
20:26:51 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:26:51 0 I allocate; slot = Process { pid: 2:0, address_space: &quot;2:0&quot; @ 0p7E5C000, { rip: 0v0, rsp: 0v0 } }; process_count = 3
...
20:27:10.241 0 I drop; address_space = &quot;process&quot; @ 0p6888000
20:27:10.289 0 I free; slot = Process { pid: 1:1, address_space: &quot;1:1&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 255
20:27:10.295 0 I drop; address_space = &quot;1:1&quot; @ 0p7E74000
20:27:10.375 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:10.381 0 I duplicate; address_space = &quot;process&quot; @ 0p7E74000
20:27:10.385 0 I switch to; address_space = &quot;process&quot; @ 0p7E74000
20:27:10.391 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:10.395 0 I allocate; slot = Process { pid: 1:2, address_space: &quot;1:2&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 256
20:27:10.447 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:10.455 0 I duplicate; address_space = &quot;process&quot; @ 0p6888000
20:27:10.459 0 I switch to; address_space = &quot;process&quot; @ 0p6888000
20:27:10.463 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:10.467 0 I drop; address_space = &quot;process&quot; @ 0p6888000
20:27:10.503 0 D prev_pid = 1:1; pid = 1:2
20:27:10.505 0 I free; slot = Process { pid: 1:2, address_space: &quot;1:2&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 255
20:27:10.513 0 I drop; address_space = &quot;1:2&quot; @ 0p7E74000
20:27:10.593 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:10.599 0 I duplicate; address_space = &quot;process&quot; @ 0p7E74000
20:27:10.603 0 I switch to; address_space = &quot;process&quot; @ 0p7E74000
20:27:10.609 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:10.613 0 I allocate; slot = Process { pid: 1:3, address_space: &quot;1:3&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 256
20:27:10.665 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:10.673 0 I duplicate; address_space = &quot;process&quot; @ 0p6888000
20:27:10.677 0 I switch to; address_space = &quot;process&quot; @ 0p6888000
20:27:10.681 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:10.685 0 I drop; address_space = &quot;process&quot; @ 0p6888000
20:27:10.719 0 D prev_pid = 1:2; pid = 1:3
20:27:10.723 0 I free; slot = Process { pid: 1:3, address_space: &quot;1:3&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 255
20:27:10.731 0 I drop; address_space = &quot;1:3&quot; @ 0p7E74000
20:27:10.809 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:10.817 0 I duplicate; address_space = &quot;process&quot; @ 0p7E74000
20:27:10.821 0 I switch to; address_space = &quot;process&quot; @ 0p7E74000
20:27:10.827 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:10.831 0 I allocate; slot = Process { pid: 1:4, address_space: &quot;1:4&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 256
20:27:10.883 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:10.889 0 I duplicate; address_space = &quot;process&quot; @ 0p6888000
20:27:10.893 0 I switch to; address_space = &quot;process&quot; @ 0p6888000
20:27:10.899 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:10.903 0 I drop; address_space = &quot;process&quot; @ 0p6888000
20:27:10.937 0 D prev_pid = 1:3; pid = 1:4
20:27:10.941 0 I free; slot = Process { pid: 1:4, address_space: &quot;1:4&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 255
20:27:10.949 0 I drop; address_space = &quot;1:4&quot; @ 0p7E74000
20:27:11.027 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:11.035 0 I duplicate; address_space = &quot;process&quot; @ 0p7E74000
20:27:11.039 0 I switch to; address_space = &quot;process&quot; @ 0p7E74000
20:27:11.043 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:11.047 0 I allocate; slot = Process { pid: 1:5, address_space: &quot;1:5&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 256
20:27:11.101 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:11.107 0 I duplicate; address_space = &quot;process&quot; @ 0p6888000
20:27:11.111 0 I switch to; address_space = &quot;process&quot; @ 0p6888000
20:27:11.117 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:11.121 0 I drop; address_space = &quot;process&quot; @ 0p6888000
20:27:11.155 0 D prev_pid = 1:4; pid = 1:5
20:27:11.159 0 I free; slot = Process { pid: 1:5, address_space: &quot;1:5&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 255
20:27:11.165 0 I drop; address_space = &quot;1:5&quot; @ 0p7E74000
20:27:11.245 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:11.253 0 I duplicate; address_space = &quot;process&quot; @ 0p7E74000
20:27:11.257 0 I switch to; address_space = &quot;process&quot; @ 0p7E74000
20:27:11.261 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:11.265 0 I allocate; slot = Process { pid: 1:6, address_space: &quot;1:6&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 256
20:27:11.319 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:11.325 0 I duplicate; address_space = &quot;process&quot; @ 0p6888000
20:27:11.329 0 I switch to; address_space = &quot;process&quot; @ 0p6888000
20:27:11.335 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:11.339 0 I drop; address_space = &quot;process&quot; @ 0p6888000
20:27:11.373 0 D prev_pid = 1:5; pid = 1:6
20:27:11.377 0 I free; slot = Process { pid: 1:6, address_space: &quot;1:6&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 255
20:27:11.385 0 I drop; address_space = &quot;1:6&quot; @ 0p7E74000
20:27:11.463 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:11.471 0 I duplicate; address_space = &quot;process&quot; @ 0p7E74000
20:27:11.475 0 I switch to; address_space = &quot;process&quot; @ 0p7E74000
20:27:11.479 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:11.483 0 I allocate; slot = Process { pid: 1:7, address_space: &quot;1:7&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 256
20:27:11.535 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:11.543 0 I duplicate; address_space = &quot;process&quot; @ 0p6888000
20:27:11.547 0 I switch to; address_space = &quot;process&quot; @ 0p6888000
20:27:11.553 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:11.557 0 I drop; address_space = &quot;process&quot; @ 0p6888000
20:27:11.591 0 D prev_pid = 1:6; pid = 1:7
20:27:11.595 0 I free; slot = Process { pid: 1:7, address_space: &quot;1:7&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 255
20:27:11.601 0 I drop; address_space = &quot;1:7&quot; @ 0p7E74000
20:27:11.681 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:11.689 0 I duplicate; address_space = &quot;process&quot; @ 0p7E74000
20:27:11.691 0 I switch to; address_space = &quot;process&quot; @ 0p7E74000
20:27:11.697 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:11.701 0 I allocate; slot = Process { pid: 1:8, address_space: &quot;1:8&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 256
20:27:11.753 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:11.761 0 I duplicate; address_space = &quot;process&quot; @ 0p6888000
20:27:11.765 0 I switch to; address_space = &quot;process&quot; @ 0p6888000
20:27:11.769 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:11.773 0 I drop; address_space = &quot;process&quot; @ 0p6888000
20:27:11.809 0 D prev_pid = 1:7; pid = 1:8
20:27:11.811 0 I free; slot = Process { pid: 1:8, address_space: &quot;1:8&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 255
20:27:11.819 0 I drop; address_space = &quot;1:8&quot; @ 0p7E74000
20:27:11.899 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:11.905 0 I duplicate; address_space = &quot;process&quot; @ 0p7E74000
20:27:11.909 0 I switch to; address_space = &quot;process&quot; @ 0p7E74000
20:27:11.915 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:11.919 0 I allocate; slot = Process { pid: 1:9, address_space: &quot;1:9&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 256
20:27:11.971 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:11.979 0 I duplicate; address_space = &quot;process&quot; @ 0p6888000
20:27:11.983 0 I switch to; address_space = &quot;process&quot; @ 0p6888000
20:27:11.987 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:11.991 0 I drop; address_space = &quot;process&quot; @ 0p6888000
20:27:12.025 0 D prev_pid = 1:8; pid = 1:9
20:27:12.029 0 I free; slot = Process { pid: 1:9, address_space: &quot;1:9&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 255
20:27:12.037 0 I drop; address_space = &quot;1:9&quot; @ 0p7E74000
20:27:12.117 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:12.125 0 I duplicate; address_space = &quot;process&quot; @ 0p7E74000
20:27:12.127 0 I switch to; address_space = &quot;process&quot; @ 0p7E74000
20:27:12.133 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:12.137 0 I allocate; slot = Process { pid: 1:10, address_space: &quot;1:10&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 256
20:27:12.189 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:12.197 0 I duplicate; address_space = &quot;process&quot; @ 0p6888000
20:27:12.201 0 I switch to; address_space = &quot;process&quot; @ 0p6888000
20:27:12.207 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:12.211 0 I drop; address_space = &quot;process&quot; @ 0p6888000
20:27:12.245 0 D prev_pid = 1:9; pid = 1:10
20:27:12.249 0 I free; slot = Process { pid: 1:10, address_space: &quot;1:10&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 255
20:27:12.255 0 I drop; address_space = &quot;1:10&quot; @ 0p7E74000
20:27:12.335 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:12.343 0 I duplicate; address_space = &quot;process&quot; @ 0p7E74000
20:27:12.345 0 I switch to; address_space = &quot;process&quot; @ 0p7E74000
20:27:12.351 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:12.355 0 I allocate; slot = Process { pid: 1:11, address_space: &quot;1:11&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 256
20:27:12.407 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:12.415 0 I duplicate; address_space = &quot;process&quot; @ 0p6888000
20:27:12.419 0 I switch to; address_space = &quot;process&quot; @ 0p6888000
20:27:12.423 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:12.427 0 I drop; address_space = &quot;process&quot; @ 0p6888000
20:27:12.463 0 D prev_pid = 1:10; pid = 1:11
...
20:27:22.979 0 I free; slot = Process { pid: 2:0, address_space: &quot;2:0&quot; @ 0p7E5C000, { rip: 0v0, rsp: 0v0 } }; process_count = 2
20:27:22.987 0 I drop; address_space = &quot;2:0&quot; @ 0p7E5C000
20:27:23.021 0 I free; slot = Process { pid: 0:1, address_space: &quot;0:1&quot; @ 0p7E79000, { rip: 0v0, rsp: 0v0 } }; process_count = 1
20:27:23.029 0 I drop; address_space = &quot;0:1&quot; @ 0p7E79000
20:27:23.063 0 I free; slot = Process { pid: 1:11, address_space: &quot;1:11&quot; @ 0p7E74000, { rip: 0v0, rsp: 0v0 } }; process_count = 0
20:27:23.069 0 I drop; address_space = &quot;1:11&quot; @ 0p7E74000
4_concurrency_5_table::full_capacity--------------- [passed]
20:27:23.107 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-17"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-17">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/process/table.rs |  119 +++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 111 insertions(+), 8 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Вытесняющая-многозадачность"><a class="header" href="#Вытесняющая-многозадачность">Вытесняющая многозадачность</a></h2>
<h3 id="Задача-6--реализуйте-вытеснение-пользовательского-процесса-по-прерыванию"><a class="header" href="#Задача-6--реализуйте-вытеснение-пользовательского-процесса-по-прерыванию">Задача 6 — реализуйте вытеснение пользовательского процесса по прерыванию</a></h3>
<p>Убедитесь, что в запускаемых процессах прерывания разрешены,
то есть установлен флаг
<a href="../../doc/ku/process/registers/struct.RFlags.html#associatedconstant.INTERRUPT_FLAG"><code>RFlags::INTERRUPT_FLAG</code></a>.
См.
<a href="../../lab/book/3-process-3-user-mode.html#%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-3--%D0%BF%D0%B5%D1%80%D0%B5%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0-%D0%B2-%D1%80%D0%B5%D0%B6%D0%B8%D0%BC-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F-%D0%B8-%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%82-%D0%B8%D0%B7-%D0%BD%D0%B5%D0%B3%D0%BE">задачу</a>
про переключение процессора в режим пользователя и
<a href="../../lab/book/3-process-3-user-mode.html#%D0%A1%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5-%D1%80%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D0%BE%D0%B2-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D0%BA%D0%BE%D0%B3%D0%BE-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%B0">состояние регистров пользовательского процесса</a>.</p>
<p>Реализуйте <a href="../../doc/kernel/process/process/struct.Process.html#method.preempt">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Process::preempt(context: &amp;mut InterruptContext)
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/process.rs"><code>kernel/src/process/process.rs</code></a>.</p>
<p>Он должен выполнить переключение текущего контекста исполнения <code>context</code> на контекст ядра в случае,
если текущий контекст исполняется в режиме пользователя.
Текущий контекст пользователя нужно будет сохранить в структуре
<a href="../../doc/kernel/process/process/struct.Process.html"><code>Process</code></a>.
Но чтобы до неё добраться, нужно блокировать спинлок в таблице процессов.
А брать блокировки из обработчиков прерываний не стоит.
Поэтому для начала в самом прерывании сохраним контекст пользователя в промежуточном месте —
в CPU–локальной структуре
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html"><code>kernel::smp::cpu::Cpu</code></a>.
Захватывать блокировку для доступа ней не нужно, так как она не разделяется между разными CPU
и доступ к ней не будет конкурентным.</p>
<p>Метод
<a href="../../doc/kernel/process/process/struct.Process.html#method.preempt"><code>Process::preempt</code></a>
вызывается из
<a href="../../doc/kernel/interrupts/fn.apic_timer.html">функции обработки прерывания от таймера</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;x86-interrupt&quot; fn apic_timer(mut context: InterruptContext)
<span class="boring">}
</span></code></pre></pre>
<p>находящейся в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/interrupts.rs"><code>kernel/src/interrupts.rs</code></a>.</p>
<p><a href="../../doc/kernel/interrupts/struct.InterruptContext.html"><code>kernel::interrupts::InterruptContext</code></a> —
обёртка для уже знакомого
<a href="../../doc/kernel/process/registers/struct.ModeContext.html"><code>kernel::process::registers::ModeContext</code></a>.
Она помечает запись в него как
<a href="../../doc/volatile/struct.Volatile.html"><code>volatile::Volatile</code></a>,
чтобы компилятор такую операцию записи не выкинул.
Дело в том, что
<a href="../../doc/kernel/interrupts/struct.InterruptContext.html"><code>InterruptContext</code></a>
формально является изменяемым аргументом
<a href="../../doc/kernel/interrupts/fn.apic_timer.html"><code>apic_timer()</code></a>,
а не изменяемой ссылкой.
Если бы функция была обычной, запись в <code>context</code> сделанную последней, никто снаружи функции бы не заметил.
А значит, компилятор мог бы её выкинуть.
В нашем случае
<a href="../../doc/kernel/interrupts/fn.apic_timer.html"><code>apic_timer()</code></a> —
<a href="https://github.com/rust-lang/rust/issues/40180"><code>extern &quot;x86-interrupt&quot;</code></a>
и эту запись увидит инструкция процессора
<a href="https://www.felixcloutier.com/x86/iret:iretd:iretq"><code>iretq</code></a>.
Чтобы предотвратить выкидывание оптимизатором команд записи в <code>context</code> и нужен <code>Volatile</code>.</p>
<p>В <a href="../../doc/kernel/process/process/struct.Process.html#method.enter_user_mode">методе</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Process::enter_user_mode(mut process: MutexGuard&lt;Process&gt;) -&gt; bool
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/process.rs"><code>kernel/src/process/process.rs</code></a>
после возвращения из режима пользователя, то есть после возвращения из
<a href="../../doc/kernel/process/registers/struct.Registers.html#method.switch_to"><code>Registers::switch_to()</code></a>,
добавьте проверку, что в
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html"><code>Cpu</code></a>
есть сохранённый контекст пользователя.
Если его нет, то процесс вернулся из режима пользователя синхронно, например через системный вызов
<code>exit()</code> или <code>sched_yield()</code>, и дополнительно ничего делать не нужно.
Если же в
<a href="../../doc/kernel/smp/cpu/struct.Cpu.html"><code>Cpu</code></a>
сохранён контекст пользователя, то его нужно перенести в структуру
<a href="../../doc/kernel/process/process/struct.Process.html"><code>Process</code></a>.
Для этого, по идентификатору
<a href="../../doc/ku/process/pid/enum.Pid.html"><code>Pid</code></a>
текущего процесса, получите из
<a href="../../doc/kernel/process/struct.Table.html"><code>Table</code></a>
его заблокированную спинлоком структуру
<a href="../../doc/kernel/process/process/struct.Process.html"><code>Process</code></a>.
И запишите пользовательский контекст в неё.
Верните из этого метода <code>true</code>, если процесс был вытеснен.</p>
<p>Вам пригодятся</p>
<ul>
<li><a href="../../doc/kernel/interrupts/struct.InterruptContext.html#method.is_user_mode"><code>InterruptContext::is_user_mode()</code></a>,</li>
<li><a href="../../doc/kernel/interrupts/struct.InterruptContext.html#method.get"><code>InterruptContext::get()</code></a>,</li>
<li><a href="../../doc/kernel/interrupts/struct.InterruptContext.html#method.set"><code>InterruptContext::set()</code></a>,</li>
<li><a href="../../doc/kernel/smp/cpu/struct.Cpu.html#method.kernel_context"><code>Cpu::kernel_context()</code></a>,</li>
<li><a href="../../doc/kernel/smp/cpu/struct.Cpu.html#method.set_user_context"><code>Cpu::set_user_context()</code></a>,</li>
<li><a href="../../doc/kernel/smp/cpu/struct.Cpu.html#method.take_user_context"><code>Cpu::take_user_context()</code></a>,</li>
<li><a href="../../doc/kernel/process/struct.Table.html#method.get"><code>Table::get()</code></a>,</li>
<li><a href="../../doc/kernel/process/registers/struct.Registers.html#method.set_mode_context"><code>Registers::set_mode_context()</code></a>.</li>
</ul>
<h3 id="Проверьте-себя-14"><a class="header" href="#Проверьте-себя-14">Проверьте себя</a></h3>
<p>После этого заработает тест <code>preemption()</code> в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/4-concurrency-6-preemption.rs"><code>kernel/tests/4-concurrency-6-preemption.rs</code></a>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 4-concurrency-6-preemption)
...
4_concurrency_6_preemption::preemption----------------------
20:27:28 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:28 0 I duplicate; address_space = &quot;process&quot; @ 0p7E8A000
20:27:28 0 I switch to; address_space = &quot;process&quot; @ 0p7E8A000
20:27:28 0 D extend mapping; block = [0v10000000, 0v10006DA4), size 27.410 KiB; page_block = [0v10000000, 0v10007000), size 28.000 KiB; flags =   R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
20:27:28 0 D elf loadable program header; file_block = [0v201A9A, 0v20883E), size 27.410 KiB; memory_block = [0v10000000, 0v10006DA4), size 27.410 KiB; flags =   R
20:27:28 0 D extend mapping; block = [0v10007000, 0v1004EAD2), size 286.705 KiB; page_block = [0v10007000, 0v1004F000), size 288.000 KiB; flags = X R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
20:27:28 0 D elf loadable program header; file_block = [0v20884A, 0v25056C), size 287.283 KiB; memory_block = [0v10006DB0, 0v1004EAD2), size 287.283 KiB; flags = X R
20:27:28 0 D elf loadable program header; file_block = [0v250572, 0v250662), size 240 B; memory_block = [0v1004EAD8, 0v1004EBC8), size 240 B; flags =  WR
20:27:28 0 D extend mapping; block = [0v1004F000, 0v100547D0), size 21.953 KiB; page_block = [0v1004F000, 0v10055000), size 24.000 KiB; flags =  WR; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
20:27:28 0 D elf loadable program header; file_block = [0v250662, 0v256242), size 22.969 KiB; memory_block = [0v1004EBC8, 0v100547D0), size 23.008 KiB; flags =  WR
20:27:28 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:28 0 I loaded ELF file; context = { rip: 0v10006E60, rsp: 0v7F7FFFFFF000 }; file_size = 5.307 MiB; process = { pid: &lt;current&gt;, address_space: &quot;process&quot; @ 0p7E8A000, { rip: 0v10006E60, rsp: 0v7F7FFFFFF000 } }
20:27:28 0 I allocate; slot = Process { pid: 0:0, address_space: &quot;0:0&quot; @ 0p7E8A000, { rip: 0v10006E60, rsp: 0v7F7FFFFFF000 } }; process_count = 1
20:27:28 0 I user process page table entry; entry_point = 0v10006E60; frame = Frame(32366 @ 0p7E6E000); flags = PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED | DIRTY
20:27:28 0 D process_frames = 126
20:27:28 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E8A000
20:27:28 0 D entering the user mode; pid = 0:0; registers = { rax: 0x0, rdi: 0x7F7FFFFED000, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v10006E60, ss:rsp: 0x001B:0v7F7FFFFFF000, rflags: IF } }
20:27:28 0 D leaving the user mode; pid = 0:0
20:27:28 0 I the process was preempted; pid = 0:0; user_context = { mode: user, cs:rip: 0x0023:0v10006E1A, ss:rsp: 0x001B:0v7F7FFFFFEFB8, rflags: IF AF }
20:27:28 0 D returned from the user space
20:27:28 0 I free; slot = Process { pid: 0:0, address_space: &quot;0:0&quot; @ 0p7E8A000, { rip: 0v10006E1A, rsp: 0v7F7FFFFFEFB8 } }; process_count = 0
20:27:28 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:28 0 I drop the current address space; address_space = &quot;0:0&quot; @ 0p7E8A000; switch_to = &quot;base&quot; @ 0p1000
4_concurrency_6_preemption::preemption------------- [passed]
20:27:28 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-18"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-18">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/process/process.rs |   24 +++++++++++++++++++++---
 1 file changed, 21 insertions(+), 3 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="round-robin-планировщик"><a class="header" href="#round-robin-планировщик">Round-robin планировщик</a></h2>
<p>Планировщик процессов
<a href="../../doc/kernel/process/scheduler/struct.Scheduler.html"><code>kernel::process::scheduler::Scheduler</code></a>
расположен в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/scheduler.rs"><code>kernel/src/process/scheduler.rs</code></a>
и реализует простейшее
<a href="https://en.wikipedia.org/wiki/Round-robin_scheduling">циклическое исполнение процессов</a>.
Он содержит очередь процессов
<a href="../../doc/kernel/process/scheduler/struct.Scheduler.html#structfield.queue"><code>Scheduler::queue</code></a>
такой же ёмкости, как таблица процессов.
И, так же как и таблица процессов, является <a href="https://en.wikipedia.org/wiki/Singleton_pattern">синглтоном</a>
<a href="../../doc/kernel/process/scheduler/struct.SCHEDULER.html"><code>static ref SCHEDULER: Mutex&lt;Scheduler&gt;</code></a>.</p>
<h3 id="Задача-7--планировщик"><a class="header" href="#Задача-7--планировщик">Задача 7 — планировщик</a></h3>
<h4 id="Реализуйте-методы-планировщика"><a class="header" href="#Реализуйте-методы-планировщика">Реализуйте методы планировщика</a></h4>
<ul>
<li><a href="../../doc/kernel/process/scheduler/struct.Scheduler.html#method.enqueue"><code>fn Scheduler::enqueue(pid: Pid)</code></a> ставит процесс, заданный идентификатором <code>pid</code>, в очередь исполнения.</li>
<li><a href="../../doc/kernel/process/scheduler/struct.Scheduler.html#method.dequeue"><code>fn Scheduler::dequeue() -&gt; Option&lt;Pid&gt;</code></a> достаёт из очереди первый процесс.</li>
<li><a href="../../doc/kernel/process/scheduler/struct.Scheduler.html#method.run_one"><code>fn Scheduler::run_one() -&gt; bool</code></a> выполняет один цикл работы — берёт первый процесс из очереди и исполняет его пользовательский код. Если метод <a href="../../doc/kernel/process/process/struct.Process.html#method.enter_user_mode"><code>Process::enter_user_mode()</code></a> вернёт <code>true</code>, то есть процесс был снят с CPU принудительно по прерыванию таймера, <a href="../../doc/kernel/process/scheduler/struct.Scheduler.html#method.run_one"><code>Scheduler::run_one()</code></a> перепланирует исполнение процесса, ставя его в конец очереди. Метод <a href="../../doc/kernel/process/scheduler/struct.Scheduler.html#method.run_one"><code>Scheduler::run_one()</code></a> возвращает <code>true</code> если в очереди на исполнение нашёлся хотя бы один процесс. Должен корректно обрабатывать ситуацию, когда <code>pid</code> есть в очереди планирования, но соответствующего процесса уже нет в <a href="../../doc/kernel/process/struct.Table.html"><code>kernel::process::Table</code></a>.</li>
</ul>
<p>Метод
<a href="../../doc/kernel/process/scheduler/struct.Scheduler.html#method.run"><code>fn Scheduler::run() -&gt; !</code></a>
уже реализован.
Он в вечном цикле выполняет
<a href="../../doc/kernel/process/scheduler/struct.Scheduler.html#method.run_one"><code>Scheduler::run_one()</code></a>.
Если в очереди на исполнение процессов не нашлось,
то он выключает процессор до прихода следующего прерывания, самое долгое — до следующего тика таймера</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;x86-interrupt&quot; fn apic_timer(mut context: InterruptContext)
<span class="boring">}
</span></code></pre></pre>
<p>Для этого служит специальная инструкция
<a href="https://www.felixcloutier.com/x86/hlt"><code>hlt</code></a>,
которая зовётся через функцию
<a href="../../doc/x86_64/instructions/fn.hlt.html"><code>x86_64::instructions::hlt()</code></a>.</p>
<p>Добавьте вызов
<a href="../../doc/kernel/process/scheduler/struct.Scheduler.html#method.run"><code>Scheduler::run()</code></a>
в конец функции
<a href="../../doc/kernel/smp/ap_init/fn.init_ap.html"><code>init_ap()</code></a>
в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/smp/ap_init.rs"><code>kernel/src/smp/ap_init.rs</code></a>,
чтобы все CPU занялись исполнением процессов.</p>
<h4 id="Системный-вызов-kernelprocesssyscallsched_yield"><a class="header" href="#Системный-вызов-kernelprocesssyscallsched_yield">Системный вызов <a href="../../doc/kernel/process/syscall/fn.sched_yield.html"><code>kernel::process::syscall::sched_yield()</code></a></a></h4>
<p>Добавьте в файл
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/syscall.rs"><code>kernel/src/process/syscall.rs</code></a>
реализацию системного вызова
<a href="../../doc/kernel/process/syscall/fn.sched_yield.html"><code>kernel::process::syscall::sched_yield()</code></a>
с номером
<a href="../../doc/ku/process/syscall/struct.Syscall.html#associatedconstant.SCHED_YIELD"><code>ku::process::syscall::Syscall::SCHED_YIELD</code></a>.
Он должен перепланировать процесс в конец очереди и забрать у него CPU функцией
<a href="../../doc/kernel/process/process/struct.Process.html#method.sched_yield"><code>kernel::process::process::Process::sched_yield()</code></a>,
которая вернёт управление в другой контекст ядра.
А именно, в контекст из которого была вызвана функция
<a href="../../doc/kernel/process/process/struct.Process.html#method.enter_user_mode"><code>kernel::process::process::Process::enter_user_mode()</code></a>.
То есть, управление вернётся в цикл планировщика.</p>
<p>Функция
<a href="../../doc/kernel/process/syscall/fn.sched_yield.html"><code>kernel::process::syscall::sched_yield()</code></a>
не вернётся в диспетчер системных вызовов
<a href="../../doc/kernel/process/syscall/fn.syscall.html"><code>kernel::process::syscall::syscall()</code></a>
и далее в возврат из системного вызова
<a href="../../doc/kernel/process/syscall/fn.sysret.html"><code>kernel::process::syscall::sysret()</code></a>.
Но, тем не менее, когда-нибудь управление нужно будет передать вызывающему процессу.
Это сделает планировщик через цепочку
<a href="../../doc/kernel/process/process/struct.Process.html#method.enter_user_mode"><code>kernel::process::process::Process::enter_user_mode()</code></a> -&gt;
<a href="../../doc/kernel/process/registers/struct.Registers.html#method.switch_to"><code>kernel::process::registers::Registers::switch_to()</code></a> -&gt;
<a href="https://www.felixcloutier.com/x86/iret:iretd:iretq"><code>iretq</code></a>.
И для
<a href="https://www.felixcloutier.com/x86/iret:iretd:iretq"><code>iretq</code></a>
нужно предоставить правильный контекст пользователя, в который нужно будет переключиться.
Это ровно тот контекст пользователя, который есть у
<a href="../../doc/kernel/process/syscall/fn.sched_yield.html"><code>kernel::process::syscall::sched_yield()</code></a>.
И который она обычно передаёт в
<a href="../../doc/kernel/process/syscall/fn.sysret.html"><code>kernel::process::syscall::sysret()</code></a>.
А в
<a href="../../doc/kernel/process/syscall/fn.sched_yield.html"><code>kernel::process::syscall::sched_yield()</code></a>
этот контекст пользователя нужно явно сохранить методом
<a href="../../doc/kernel/process/process/struct.Process.html#method.set_context"><code>kernel::process::process::Process::set_context()</code></a>.
Флаги и сегментные регистры тут сохранять не требуется.
Флаги должен сохранить пользовательский код, если они ему нужны.
Так как это syscall, то есть пользователь готов к тому что регистры, и в том числе флаги, будут изменены.
А сегментные регистры не меняются на протяжении жизни процесса.</p>
<h3 id="Проверьте-себя-15"><a class="header" href="#Проверьте-себя-15">Проверьте себя</a></h3>
<p>Теперь должны заработать тесты <code>syscall_sched_yield()</code> и <code>scheduler()</code> в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/4-concurrency-7-scheduler.rs"><code>kernel/tests/4-concurrency-7-scheduler.rs</code></a>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 4-concurrency-7-scheduler)
...
4_concurrency_7_scheduler::syscall_sched_yield--------------
20:27:37 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:37 0 I duplicate; address_space = &quot;process&quot; @ 0p7E8A000
20:27:37 0 I switch to; address_space = &quot;process&quot; @ 0p7E8A000
20:27:37 0 D extend mapping; block = [0v10000000, 0v10006DA4), size 27.410 KiB; page_block = [0v10000000, 0v10007000), size 28.000 KiB; flags =   R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
20:27:37 0 D elf loadable program header; file_block = [0v201B61, 0v208905), size 27.410 KiB; memory_block = [0v10000000, 0v10006DA4), size 27.410 KiB; flags =   R
20:27:37 0 D extend mapping; block = [0v10007000, 0v1004EA72), size 286.611 KiB; page_block = [0v10007000, 0v1004F000), size 288.000 KiB; flags = X R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
20:27:37 0 D elf loadable program header; file_block = [0v208911, 0v2505D3), size 287.189 KiB; memory_block = [0v10006DB0, 0v1004EA72), size 287.189 KiB; flags = X R
20:27:37 0 D elf loadable program header; file_block = [0v2505D9, 0v2506C9), size 240 B; memory_block = [0v1004EA78, 0v1004EB68), size 240 B; flags =  WR
20:27:37 0 D extend mapping; block = [0v1004F000, 0v10054770), size 21.859 KiB; page_block = [0v1004F000, 0v10055000), size 24.000 KiB; flags =  WR; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
20:27:37 0 D elf loadable program header; file_block = [0v2506C9, 0v2562A9), size 22.969 KiB; memory_block = [0v1004EB68, 0v10054770), size 23.008 KiB; flags =  WR
20:27:37 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:37 0 I loaded ELF file; context = { rip: 0v10006E00, rsp: 0v7F7FFFFFF000 }; file_size = 5.307 MiB; process = { pid: &lt;current&gt;, address_space: &quot;process&quot; @ 0p7E8A000, { rip: 0v10006E00, rsp: 0v7F7FFFFFF000 } }
20:27:37 0 I allocate; slot = Process { pid: 0:0, address_space: &quot;0:0&quot; @ 0p7E8A000, { rip: 0v10006E00, rsp: 0v7F7FFFFFF000 } }; process_count = 1
20:27:37 0 I user process page table entry; entry_point = 0v10006E00; frame = Frame(32361 @ 0p7E69000); flags = PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED | DIRTY
20:27:37 0 D process_frames = 131
20:27:37 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E8A000
20:27:37 0 D entering the user mode; pid = 0:0; registers = { rax: 0x0, rdi: 0x7F7FFFFED000, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v10006E00, ss:rsp: 0x001B:0v7F7FFFFFF000, rflags:  } }
20:27:37 0 W log is not mapped properly; pid = 0:0
20:27:37 0 I syscall = &quot;sched_yield&quot;; pid = 0:0
20:27:37 0 D leaving the user mode; pid = 0:0
20:27:37 0 D returned from the user space; user_registers = [0, 0, 0, 0, 140187732463616, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
20:27:37 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E8A000
20:27:37 0 D entering the user mode; pid = 0:0; registers = { rax: 0x0, rdi: 0x7F7FFFFED000, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v1000801E, ss:rsp: 0x001B:0v7F7FFFFFEE18, rflags:  } }
20:27:37 0 W log is not mapped properly; pid = 0:0
20:27:37 0 I syscall = &quot;sched_yield&quot;; pid = 0:0
20:27:37 0 D leaving the user mode; pid = 0:0
20:27:37 0 D returned from the user space; user_registers = [0, 0, 0, 0, 140187732463616, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
20:27:37 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E8A000
20:27:37 0 D entering the user mode; pid = 0:0; registers = { rax: 0x0, rdi: 0x7F7FFFFED000, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v1000801E, ss:rsp: 0x001B:0v7F7FFFFFEE18, rflags:  } }
20:27:37 0 W log is not mapped properly; pid = 0:0
20:27:37 0 I syscall = &quot;sched_yield&quot;; pid = 0:0
20:27:37 0 D leaving the user mode; pid = 0:0
20:27:37 0 I free; slot = Process { pid: 0:0, address_space: &quot;0:0&quot; @ 0p7E8A000, { rip: 0v1000801E, rsp: 0v7F7FFFFFEE18 } }; process_count = 0
20:27:37 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:37 0 I drop the current address space; address_space = &quot;0:0&quot; @ 0p7E8A000; switch_to = &quot;base&quot; @ 0p1000
4_concurrency_7_scheduler::syscall_sched_yield----- [passed]

4_concurrency_7_scheduler::scheduler------------------------
20:27:37 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:37 0 I duplicate; address_space = &quot;process&quot; @ 0p7E8A000
20:27:37 0 I switch to; address_space = &quot;process&quot; @ 0p7E8A000
20:27:37 0 D extend mapping; block = [0v10000000, 0v10007514), size 29.270 KiB; page_block = [0v10000000, 0v10008000), size 32.000 KiB; flags =   R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
20:27:37 0 D elf loadable program header; file_block = [0v750795, 0v757CA9), size 29.270 KiB; memory_block = [0v10000000, 0v10007514), size 29.270 KiB; flags =   R
20:27:37 0 D extend mapping; block = [0v10008000, 0v100539CD), size 302.450 KiB; page_block = [0v10008000, 0v10054000), size 304.000 KiB; flags = X R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
20:27:37 0 D elf loadable program header; file_block = [0v757CB5, 0v7A4162), size 305.169 KiB; memory_block = [0v10007520, 0v100539CD), size 305.169 KiB; flags = X R
20:27:37 0 D elf loadable program header; file_block = [0v7A4165, 0v7A4255), size 240 B; memory_block = [0v100539D0, 0v10053AC0), size 240 B; flags =  WR
20:27:37 0 D extend mapping; block = [0v10054000, 0v10059B80), size 22.875 KiB; page_block = [0v10054000, 0v1005A000), size 24.000 KiB; flags =  WR; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
20:27:37 0 D elf loadable program header; file_block = [0v7A4255, 0v7AA2ED), size 24.148 KiB; memory_block = [0v10053AC0, 0v10059B80), size 24.188 KiB; flags =  WR
20:27:37 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:37 0 I loaded ELF file; context = { rip: 0v10007A90, rsp: 0v7F7FFFFFF000 }; file_size = 5.355 MiB; process = { pid: &lt;current&gt;, address_space: &quot;process&quot; @ 0p7E8A000, { rip: 0v10007A90, rsp: 0v7F7FFFFFF000 } }
20:27:37 0 I allocate; slot = Process { pid: 0:1, address_space: &quot;0:1&quot; @ 0p7E8A000, { rip: 0v10007A90, rsp: 0v7F7FFFFFF000 } }; process_count = 1
20:27:37 0 I user process page table entry; entry_point = 0v10007A90; frame = Frame(32392 @ 0p7E88000); flags = PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED | DIRTY
20:27:37 0 D process_frames = 136
20:27:37 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:27:37 0 I duplicate; address_space = &quot;process&quot; @ 0p7E02000
20:27:37 0 I switch to; address_space = &quot;process&quot; @ 0p7E02000
20:27:37 0 D extend mapping; block = [0v10000000, 0v10007514), size 29.270 KiB; page_block = [0v10000000, 0v10008000), size 32.000 KiB; flags =   R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
20:27:37 0 D elf loadable program header; file_block = [0vCAB6CD, 0vCB2BE1), size 29.270 KiB; memory_block = [0v10000000, 0v10007514), size 29.270 KiB; flags =   R
20:27:37 0 D extend mapping; block = [0v10008000, 0v100539ED), size 302.481 KiB; page_block = [0v10008000, 0v10054000), size 304.000 KiB; flags = X R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
20:27:37 0 D elf loadable program header; file_block = [0vCB2BED, 0vCFF0BA), size 305.200 KiB; memory_block = [0v10007520, 0v100539ED), size 305.200 KiB; flags = X R
20:27:37 0 D elf loadable program header; file_block = [0vCFF0BD, 0vCFF1AD), size 240 B; memory_block = [0v100539F0, 0v10053AE0), size 240 B; flags =  WR
20:27:37 0 D extend mapping; block = [0v10054000, 0v10059BA0), size 22.906 KiB; page_block = [0v10054000, 0v1005A000), size 24.000 KiB; flags =  WR; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
20:27:37 0 D elf loadable program header; file_block = [0vCFF1AD, 0vD05245), size 24.148 KiB; memory_block = [0v10053AE0, 0v10059BA0), size 24.188 KiB; flags =  WR
20:27:37 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:37 0 I loaded ELF file; context = { rip: 0v10007AB0, rsp: 0v7F7FFFFFF000 }; file_size = 5.354 MiB; process = { pid: &lt;current&gt;, address_space: &quot;process&quot; @ 0p7E02000, { rip: 0v10007AB0, rsp: 0v7F7FFFFFF000 } }
20:27:37 0 I allocate; slot = Process { pid: 1:0, address_space: &quot;1:0&quot; @ 0p7E02000, { rip: 0v10007AB0, rsp: 0v7F7FFFFFF000 } }; process_count = 2
20:27:37 0 I user process page table entry; entry_point = 0v10007AB0; frame = Frame(32224 @ 0p7DE0000); flags = PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED | DIRTY
20:27:37 0 D process_frames = 136
20:27:37 0 I dequeue; pid = Some(0:0)
20:27:37 0 I dequeue; pid = Some(0:0)
20:27:37 0 I dequeue; pid = Some(0:0)
20:27:37 0 I dequeue; pid = Some(0:1)
20:27:37 0 I switch to; address_space = &quot;0:1&quot; @ 0p7E8A000
20:27:37 0 D entering the user mode; pid = 0:1; registers = { rax: 0x0, rdi: 0x7F7FFFFED000, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v10007A90, ss:rsp: 0x001B:0v7F7FFFFFF000, rflags: IF } }
20:27:37 0 D leaving the user mode; pid = 0:1
20:27:37 0 I the process was preempted; pid = 0:1; user_context = { mode: user, cs:rip: 0x0023:0v1000BDF2, ss:rsp: 0x001B:0v7F7FFFFFEE88, rflags: IF ZF PF }
20:27:37 0 I returned
20:27:37 0 I dequeue; pid = Some(1:0)
20:27:37 0 I switch to; address_space = &quot;1:0&quot; @ 0p7E02000
20:27:37 0 D entering the user mode; pid = 1:0; registers = { rax: 0x0, rdi: 0x7F7FFFFED000, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v10007AB0, ss:rsp: 0x001B:0v7F7FFFFFF000, rflags: IF } }
20:27:37 0 D leaving the user mode; pid = 1:0
20:27:37 0 I the process was preempted; pid = 1:0; user_context = { mode: user, cs:rip: 0x0023:0v1000BDF3, ss:rsp: 0x001B:0v7F7FFFFFEEA8, rflags: IF AF PF }
20:27:37 0 I returned
20:27:37 0 I dequeue; pid = Some(0:1)
20:27:37 0 I switch to; address_space = &quot;0:1&quot; @ 0p7E8A000
20:27:37 0 D entering the user mode; pid = 0:1; registers = { rax: 0x1, rdi: 0x7F7FFFFFEF50, rsi: 0x7F7FFFFFEF20, { mode: user, cs:rip: 0x0023:0v1000BDF2, ss:rsp: 0x001B:0v7F7FFFFFEE88, rflags: IF ZF PF } }
20:27:37 0 W log is not mapped properly; pid = 0:1
20:27:37 0 I free; slot = Process { pid: 0:1, address_space: &quot;0:1&quot; @ 0p7E8A000, { rip: 0v10007A4D, rsp: 0v0 } }; process_count = 1
20:27:37 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:37 0 I drop the current address space; address_space = &quot;0:1&quot; @ 0p7E8A000; switch_to = &quot;base&quot; @ 0p1000
20:27:37 0 I syscall = &quot;exit&quot;; pid = 0:1; code = 3141592653589793238; reason = None
20:27:37 0 D leaving the user mode; pid = 0:1
20:27:37 0 I dequeue; pid = Some(1:0)
20:27:37 0 I switch to; address_space = &quot;1:0&quot; @ 0p7E02000
20:27:37 0 D entering the user mode; pid = 1:0; registers = { rax: 0xD0F79FF, rdi: 0x7F7FFFFFEF70, rsi: 0x7F7FFFFFEF40, { mode: user, cs:rip: 0x0023:0v1000BDF3, ss:rsp: 0x001B:0v7F7FFFFFEEA8, rflags: IF AF PF } }
20:27:37 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10007A61, ss:rsp: 0x001B:0v0, rflags: IF ZF PF }; info = { code: 0b100 = non-present page | read | user, address: 0v0 }
20:27:37 0 W log is not mapped properly; pid = 1:0
20:27:37 0 I user mode trap; trap = &quot;Page Fault&quot;; number = 14; info = { code: 0b100 = non-present page | read | user, address: 0v0 }; context = { mode: user, cs:rip: 0x0023:0v10007A61, ss:rsp: 0x001B:0v0, rflags: IF ZF PF }; pid = 1:0
20:27:37 0 I free; slot = Process { pid: 1:0, address_space: &quot;1:0&quot; @ 0p7E02000, { rip: 0v1000BDF3, rsp: 0v7F7FFFFFEEA8 } }; process_count = 0
20:27:37 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:27:37 0 I drop the current address space; address_space = &quot;1:0&quot; @ 0p7E02000; switch_to = &quot;base&quot; @ 0p1000
20:27:37 0 D leaving the user mode; pid = 1:0
20:27:37 0 I dequeue; pid = None
4_concurrency_7_scheduler::scheduler--------------- [passed]
20:27:37 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-19"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-19">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/process/scheduler.rs |   26 +++++++++++++++++++++-----
 1 file changed, 21 insertions(+), 5 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Продвинутая-работа-с-памятью-в-пространстве-пользователя"><a class="header" href="#Продвинутая-работа-с-памятью-в-пространстве-пользователя">Продвинутая работа с памятью в пространстве пользователя</a></h2>
<p>В этой лабораторной работе мы освоим продвинутое управление памятью в пространстве пользователя.
В частности, реализуем обработку исключений доступа к памяти и copy-on-write <code>fork()</code> в пространстве пользователя.</p>
<h3 id="Ориентировочный-объём-работ-этой-лабораторки-4"><a class="header" href="#Ориентировочный-объём-работ-этой-лабораторки-4">Ориентировочный объём работ этой лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/memory/mapping.rs  |   16 +++++
 kernel/src/process/mod.rs     |   28 +++++++++-
 kernel/src/process/process.rs |   50 +++++++++++++++++-
 kernel/src/process/syscall.rs |  214 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++---------
 ku/src/ring_buffer.rs         |   50 ++++++++++++++----
 user/cow_fork/src/main.rs     |   74 +++++++++++++++++++++++++--
 user/eager_fork/src/main.rs   |   54 ++++++++++++++++++--
 user/lib/src/memory/mod.rs    |   34 ++++++++++--
 user/lib/src/syscall.rs       |   48 +++++++++++++++++
 9 files changed, 510 insertions(+), 58 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Разделяемая-память"><a class="header" href="#Разделяемая-память">Разделяемая память</a></h2>
<p>Для общения между разными процессами и между кодом ядра и кодом режима пользователя внутри одного процесса необходим тот или иной метод
<a href="https://en.wikipedia.org/wiki/Inter-process_communication">межпроцессного взаимодействия</a>.
В Nikka используется <a href="https://en.wikipedia.org/wiki/Shared_memory">разделяемая память</a>,
организованная в виде <a href="https://en.wikipedia.org/wiki/Circular_buffer">циклического буфера</a>.
Для удобства в нём сделаны две доработки.</p>
<h3 id="Непрерывный-циклический-буфер"><a class="header" href="#Непрерывный-циклический-буфер">Непрерывный циклический буфер</a></h3>
<p>Обычный циклический буфер оборачивается вокруг своего конца, но адресовать память нужно линейно.
Поэтому если блок данных пересекает границу буфера, его нужно адресовать двумя частями —
от начала блока данных до конца буфера и от начала буфера до конца блока данных.
Это неудобно, и некоторые циклические буферы предоставляют метод для сдвига данных внутри буфера,
чтобы выровнять содержащиеся данные на границу буфера.
Например, это делает метод
<a href="https://doc.rust-lang.org/nightly/alloc/collections/vec_deque/struct.VecDeque.html#method.make_contiguous"><code>alloc::collections::vec_deque::VecDeque::make_contiguous()</code></a>.</p>
<p>Мы поступим <a href="https://fgiesen.wordpress.com/2012/07/21/the-magic-ring-buffer/">другим способом</a>.
Отобразим в виртуальную память буфер дважды подряд.
Тогда, при пересечении границы буфера, циклическое оборачивание адресов не нужно будет делать.
Точнее, за нас его сделает механизм виртуальной памяти.
В результате, любой отрезок буфера, размера не превышающего ёмкость буфера,
и начинающийся по виртуальному адресу внутри первой копии буфера, может быть использован как непрерывный.
Заплатим мы за это тем, что размер буфера должен быть кратен размеру страницы памяти,
а также двойным расходом виртуального адресного пространства.</p>
<h3 id="Транзакции"><a class="header" href="#Транзакции">Транзакции</a></h3>
<p>Добавим транзакции к интерфейсу буфера.
Каждая транзакция будет либо пишущей, либо читающей.</p>
<p>Пишущие транзакции будут удобны в следующей ситуации.
Мы будем писать логически атомарный блок данных по кусочкам.
И, возможно, он не влезет целиком.
А знать заранее полный размер мы не будем.
Тогда будет удобно сбросить транзакцию записи.
Кроме того, если исполнение кода переключится между записывающей и читающей сторонами,
читающая сторона не увидит в буфере только часть атомарного блока данных.</p>
<p>Для читающей стороны транзакции полезны другим.
Читающая сторона в некоторых случаях может не копировать данные из буфера к себе,
а обрабатывать данные прямо в буфере.
И отметить факт обработанности коммитом читающей транзакции, только когда ей эти данные больше не будут нужны.
Однако тут нужно быть осторожным.
Если читающая сторона не должна доверять пишущей, как в случае если читает код ядра, а пишет код пользователя,
она не должна, например сначала провалидировать структуру данных в буфере, а после спокойно ей пользоваться.
Потому что пишущая сторона может подменить данные после валидации, но до их использования читающей стороной.
Ядро может препятствовать такой атаке за счёт того,
что не даст процессор коду пользователя во время работы читающей транзакции.
Другой вариант — скопировать данные из буфера в собственную, не разделяемую, память.
А валидировать и использовать их уже там.</p>
<h3 id="Структура-циклического-буфера"><a class="header" href="#Структура-циклического-буфера">Структура циклического буфера</a></h3>
<p>В файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/ring_buffer.rs"><code>ku/src/ring_buffer.rs</code></a> определён <a href="https://en.wikipedia.org/wiki/Circular_buffer">циклический буфер</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RingBuffer {
    buf: Virt,
    head: AtomicUsize,
    tail: AtomicUsize,
    stats: [RingBufferStats; 2],
}
<span class="boring">}
</span></code></pre></pre>
<p>ёмкости <code>RingBuffer::REAL_SIZE</code>.
Его поля:</p>
<ul>
<li><code>RingBuffer::buf</code> — виртуальный адрес начала блока памяти с данными, которые хранятся в буфере.</li>
<li><code>RingBuffer::head</code> — количество байт, прочитанных из буфера за всю время. То есть, эта величина потенциально больше размера буфера. Вариант хранить в <code>RingBuffer</code> это значение по модулю размера буфера, чреват ошибками.</li>
<li><code>RingBuffer::tail</code> — количество байт, записанных в буфер за всю время.</li>
</ul>
<p>Поле <code>RingBuffer::stats</code> поддерживает статистики чтения и записи в буфер:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RingBufferStats {
    commited: AtomicUsize,
    commits: AtomicUsize,
    dropped: AtomicUsize,
    drops: AtomicUsize,
    errors: AtomicUsize,
    txs: AtomicUsize,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>RingBufferStats::txs</code> — количество транзакций чтения либо записи соответственно.</li>
<li><code>RingBufferStats::commits</code> — количество закоммиченных транзакций соответствующего типа.</li>
<li><code>RingBufferStats::drops</code> — количество оборванных (dropped, rolled back, aborted) транзакций соответствующего типа.</li>
<li><code>RingBufferStats::commited</code> — количество байт, прочитанных или записанных в закоммиченных транзакциях.</li>
<li><code>RingBufferStats::dropped</code> — количество байт, прочитанных или записанных в оборванных транзакциях.</li>
<li><code>RingBufferStats::errors</code> — количество ошибок в транзакциях.</li>
</ul>
<p>Методы <code>RingBuffer</code> создают транзакции:</p>
<ul>
<li><code>RingBuffer::read_tx()</code> — читающую;</li>
<li><code>RingBuffer::write_tx()</code> — пишущую.</li>
</ul>
<p>Транзакции устроены так:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RingBufferTx&lt;'a, T: Tag&gt; {
    ring_buffer: &amp;'a mut RingBuffer,
    head: usize,
    tail: usize,
    bytes: usize,
    _tag: PhantomData&lt;T&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Они хранят:</p>
<ul>
<li>Ссылку <code>RingBufferTx::ring_buffer</code> на исходный <code>RingBuffer</code>.</li>
<li><code>RingBufferTx::head</code> и <code>RingBufferTx::tail</code> — актуальные в рамках транзакции значения, в момент старта транзакции инициализирующиеся из полей <code>RingBuffer::head</code>.</li>
<li><code>RingBufferTx::bytes</code> — количество байт, прочитанных или записанных на текущий момент в данной транзакции.</li>
<li>Тег <code>RingBufferTx::_tag</code>, отличающий пишущие транзакции от читающих.</li>
</ul>
<h3 id="Задача-1--реализация-циклического-буфера"><a class="header" href="#Задача-1--реализация-циклического-буфера">Задача 1 — реализация циклического буфера</a></h3>
<h4 id="Читающая-транзакция"><a class="header" href="#Читающая-транзакция">Читающая транзакция</a></h4>
<p>Реализуйте метод</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn RingBufferTx&lt;'_, ReadTag&gt;::read(&amp;mut self) -&gt; &amp;[u8]
<span class="boring">}
</span></code></pre></pre>
<p>который возвращает в виде среза все доступные на момент запуска читающей транзакции байты из буфера, обновляя поля только самой транзакции <code>RingBufferTx</code>.</p>
<p>И метод</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn RingBufferTx&lt;'_, ReadTag&gt;::commit(&amp;mut self)
<span class="boring">}
</span></code></pre></pre>
<p>который коммитит читающую транзакцию, записывая обновлённое значение
<code>RingBuffer::head</code> и статистику <code>RingBuffer::read_stats()</code> в поля <code>RingBuffer</code>.</p>
<h4 id="Пишущая-транзакция"><a class="header" href="#Пишущая-транзакция">Пишущая транзакция</a></h4>
<p>Реализуйте метод</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn RingBufferTx&lt;'_, WriteTag&gt;::write(&amp;mut self, data: &amp;[u8]) -&gt; Result&lt;()&gt;
<span class="boring">}
</span></code></pre></pre>
<p>которая копирует в буфер байты среза <code>data</code>, обновляя поля самой транзакции <code>RingBufferTx</code> и статистики <code>RingBuffer::write_stats()</code>, но не трогает поля <code>RingBuffer::head</code> и <code>RingBuffer::tail</code>.
Если в буфере не остаётся места под <code>data</code> верните ошибку</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Error {
    Overflow {
        capacity: usize,
        len: usize,
        exceeding_object_len: usize,
    },
}
<span class="boring">}
</span></code></pre></pre>
<p>С информацией</p>
<ul>
<li>Об остававшемся месте в буфере на момент старта транзакции. То есть, полной доступной для транзакции ёмкости, — <code>Error::Overflow::capacity</code>.</li>
<li>Об уже записанном ранее в рамках той же транзакции объёме — <code>Error::Overflow::len</code>.</li>
<li>О размере объекта, который не влез — <code>Error::Overflow::exceeding_object_len</code>.</li>
</ul>
<p>Вам может пригодиться метод
<a href="https://doc.rust-lang.org/nightly/core/primitive.slice.html#method.copy_from_slice"><code>copy_from_slice()</code></a>
срезов.</p>
<p>Реализуйте метод</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn RingBufferTx&lt;'_, WriteTag&gt;::commit(&amp;mut self)
<span class="boring">}
</span></code></pre></pre>
<p>который коммитит пишущую транзакцию, обновляя значение
<code>RingBuffer::tail</code> и статистику <code>RingBuffer::write_stats()</code> в полях <code>RingBuffer</code>.</p>
<h4 id="Сброс-транзакции"><a class="header" href="#Сброс-транзакции">Сброс транзакции</a></h4>
<p>Реализуйте типаж <a href="https://doc.rust-lang.org/nightly/core/ops/trait.Drop.html"><code>core::ops::Drop</code></a> для транзакций обоих типов — метод</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn RingBufferTx::drop(&amp;mut self)
<span class="boring">}
</span></code></pre></pre>
<p>который обновляет соответствующие статистики <code>RingBufferTx::ring_buffer.stats[T::STATS_INDEX]</code>,
если в транзакции был прочитан или записан хотя бы один байт.</p>
<h4 id="Отображение-буфера-в-память-процесса"><a class="header" href="#Отображение-буфера-в-память-процесса">Отображение буфера в память процесса</a></h4>
<p>Реализуйте функцию</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn map_log(address_space: &amp;mut AddressSpace) -&gt; Result&lt;RingBuffer&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/mod.rs"><code>kernel/src/process/mod.rs</code></a>.
Она должна реализовать двойное отображение памяти буфера в адресное пространство <code>address_space</code> процесса.
То есть, она должна выделить
<code>RingBuffer::REAL_SIZE</code> байт в физической памяти и
<code>RingBuffer::MAPPED_SIZE</code> — в виртуальной.
И построить отображение выделенных физических фреймов дважды подряд в пространство <code>address_space</code>.</p>
<h4 id="Сброс-буфера"><a class="header" href="#Сброс-буфера">Сброс буфера</a></h4>
<p>За сброс буфера с сообщениями процесса пользователя в общий лог отвечает ядро.
Сам сброс осуществляет функция
<a href="../../doc/kernel/process/process/struct.Process.html#method.flush_log"><code>Process::flush_log()</code></a>.
А вызываться она должна:</p>
<ul>
<li>Из метода <a href="../../doc/kernel/process/process/struct.Process.html#method.trap"><code>Process::trap()</code></a> при исключениях в коде пользователя. Это уже делается.</li>
<li>Из диспетчера системных вызовов <a href="../../doc/kernel/process/syscall/fn.syscall.html"><code>kernel::process::syscall::syscall()</code></a>. Это вам придётся добавить самостоятельно. Чтобы не поменялся логический порядок записей, относящихся к одному процессу, сделайте сброс до того как ядро залогирует какое-либо своё сообщение при обработке системного вызова.</li>
</ul>
<h4 id="Структурированное-логирование-в-пространстве-пользователя"><a class="header" href="#Структурированное-логирование-в-пространстве-пользователя">Структурированное логирование в пространстве пользователя</a></h4>
<p>После того как вы реализуете <code>RingBuffer</code> наконец-то в пространстве пользователя заработает
структурированное логирование макросами библиотеки
<a href="https://docs.rs/tracing/">tracing</a> —
<code>info!()</code>, <code>debug!()</code> и т.д.</p>
<p>Устроено оно так.
В пространстве пользователя эти макросы приводят к сериализации сообщения вместе с его полями и
метаинформацией с помощью библиотеки <a href="https://docs.rs/serde/">serde</a> в
формат, задаваемый библиотекой <a href="https://docs.rs/postcard/">postcard</a>.
Соответствующий код расположен в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/log.rs"><code>ku/src/log.rs</code></a>.</p>
<p>При этом никаких системных вызовов, а значит и переключений контекстов, не происходит до тех пор,
пока буфер не переполнится.
В случае переполнения, вызывается
<a href="../../doc/lib/syscall/fn.sched_yield.html"><code>lib::syscall::sched_yield()</code></a>.
При попадании в ядро при любом системном вызове или исключении,
ядро сбрасывает накопившиеся в <code>RingBuffer</code> записи в лог функцией
<a href="../../doc/kernel/process/process/struct.Process.html#method.flush_log"><code>Process::flush_log()</code></a>.
Благодаря этому они не потеряются даже если приложение упадёт по ошибке.</p>
<p>После сброса переполнившегося буфера, выполняется повторная попытка записать в него не поместившееся сообщение.
Тут и пригождается откат транзакции.
Если и на этот раз сообщение не удалось записать — видимо оно слишком большое и не помещается в буфер —
выполняется запись небольшого префикса сообщения и
дополнительное служебное сообщение об ошибке полной записи некоторых сообщений.</p>
<blockquote>
<p>Подумайте, к каким проблемам может привести такая схема.</p>
</blockquote>
<h3 id="Проверьте-себя-16"><a class="header" href="#Проверьте-себя-16">Проверьте себя</a></h3>
<p>Теперь должен заработать тест <code>stress()</code> в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/5-um-1-ring-buffer.rs"><code>kernel/tests/5-um-1-ring-buffer.rs</code></a>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 5-um-1-ring-buffer)
...
5_um_1_ring_buffer::stress----------------------------------
15:01:59 0 D iteration = 0; read_stats = RingBufferStats { commited: 0, commits: 0, dropped: 0, drops: 0, errors: 0, txs: 0 }; write_stats = RingBufferStats { commited: 0, commits: 0, dropped: 0, drops: 0, errors: 0, txs: 0 }
15:02:01.333 0 D iteration = 1000; read_stats = RingBufferStats { commited: 1191484, commits: 438, dropped: 1306871, drops: 442, errors: 0, txs: 904 }; write_stats = RingBufferStats { commited: 1192706, commits: 567, dropped: 678585, drops: 435, errors: 651, txs: 1398 }
15:02:03.447 0 D iteration = 2000; read_stats = RingBufferStats { commited: 2357303, commits: 883, dropped: 2401911, drops: 819, errors: 0, txs: 1764 }; write_stats = RingBufferStats { commited: 2359122, commits: 1121, dropped: 1426607, drops: 883, errors: 1263, txs: 2762 }
15:02:05.485 0 D iteration = 3000; read_stats = RingBufferStats { commited: 3523519, commits: 1344, dropped: 3583669, drops: 1213, errors: 0, txs: 2651 }; write_stats = RingBufferStats { commited: 3527312, commits: 1671, dropped: 2039230, drops: 1254, errors: 1874, txs: 4097 }
15:02:07.577 0 D iteration = 4000; read_stats = RingBufferStats { commited: 4696968, commits: 1776, dropped: 4824359, drops: 1611, errors: 0, txs: 3515 }; write_stats = RingBufferStats { commited: 4696968, commits: 2237, dropped: 2690684, drops: 1644, errors: 2484, txs: 5453 }
15:02:09.603 0 D iteration = 5000; read_stats = RingBufferStats { commited: 5859816, commits: 2206, dropped: 5997402, drops: 2001, errors: 0, txs: 4378 }; write_stats = RingBufferStats { commited: 5859816, commits: 2811, dropped: 3301265, drops: 2021, errors: 3097, txs: 6816 }
15:02:11.741 0 D iteration = 6000; read_stats = RingBufferStats { commited: 7078240, commits: 2657, dropped: 7114728, drops: 2393, errors: 0, txs: 5253 }; write_stats = RingBufferStats { commited: 7078783, commits: 3400, dropped: 4011499, drops: 2424, errors: 3733, txs: 8213 }
15:02:13.905 0 D iteration = 7000; read_stats = RingBufferStats { commited: 8313431, commits: 3104, dropped: 8435844, drops: 2832, errors: 0, txs: 6173 }; write_stats = RingBufferStats { commited: 8313462, commits: 3982, dropped: 4718830, drops: 2854, errors: 4417, txs: 9661 }
15:02:15.883 0 D iteration = 8000; read_stats = RingBufferStats { commited: 9457469, commits: 3537, dropped: 9491752, drops: 3199, errors: 0, txs: 7006 }; write_stats = RingBufferStats { commited: 9458642, commits: 4539, dropped: 5338305, drops: 3279, errors: 4991, txs: 10976 }
15:02:18.051 0 D iteration = 9000; read_stats = RingBufferStats { commited: 10635416, commits: 3972, dropped: 10666640, drops: 3611, errors: 0, txs: 7880 }; write_stats = RingBufferStats { commited: 10639354, commits: 5114, dropped: 6080415, drops: 3732, errors: 5631, txs: 12382 }
5_um_1_ring_buffer::stress------------------------- [passed]
15:02:20.055 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<p>Если вам придётся его отлаживать, стоит поменять в нём константу</p>
<pre><code>const QUALITY: Quality = Quality::Paranoid;
</code></pre>
<p>на</p>
<pre><code>const QUALITY: Quality = Quality::Debuggable;
</code></pre>
<p>а вызовы <code>trace!()</code> на <code>debug!()</code>:</p>
<pre><code class="language-console">...
15:30:40.805 0 D write; operation = 'H' x 394, rollback; chunk_count = 10
15:30:40.813 0 D write; operation = 'o' x 3883, commit; chunk_count = 6
15:30:40.819 0 D write_error = RingBuffer(Overflow { capacity: 213, len: 176, exceeding_object_len: 203 })
15:30:40.827 0 D read_tx; data = 'o' x 3883, block_count = 1, total_len = 3883; len = 3883
15:30:40.843 0 D write_error = RingBuffer(Overflow { capacity: 213, len: 0, exceeding_object_len: 846 })
15:30:40.851 0 D read_tx; data = 'o' x 3883, block_count = 1, total_len = 3883; len = 3883
15:30:40.867 0 D write_error = RingBuffer(Overflow { capacity: 213, len: 0, exceeding_object_len: 979 })
15:30:40.875 0 D read_tx; data = 'o' x 3883, block_count = 1, total_len = 3883; len = 3883
15:30:40.891 0 D read; operation = 'H' x 394, rollback
15:30:40.897 0 D read; operation = 'o' x 3883, commit
...
15:30:41.495 0 D multiple write transactions in one read transaction; count = 2
15:30:41.499 0 D write; operation = 'T' x 13, commit; chunk_count = 6
15:30:41.505 0 D read_tx; data = 'T' x 13, block_count = 1, total_len = 13; len = 13
15:30:41.515 0 D write; operation = '7' x 2277, commit; chunk_count = 7
15:30:41.521 0 D write_error = RingBuffer(Overflow { capacity: 1806, len: 0, exceeding_object_len: 1905 })
15:30:41.529 0 D read_tx; data = 'T' x 13, '7' x 2277, block_count = 2, total_len = 2290; len = 2290
15:30:41.543 0 D write_error = RingBuffer(Overflow { capacity: 1806, len: 1124, exceeding_object_len: 1421 })
15:30:41.551 0 D read_tx; data = 'T' x 13, '7' x 2277, block_count = 2, total_len = 2290; len = 2290
15:30:41.563 0 D read; operation = 'T' x 13, commit
15:30:41.569 0 D read; operation = '7' x 2277, commit
...
</code></pre>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-20"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-20">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/process/mod.rs |   28 ++++++++++++++++++++++++++--
 ku/src/ring_buffer.rs     |   50 ++++++++++++++++++++++++++++++++++++++++----------
 2 files changed, 66 insertions(+), 12 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Системные-вызовы-для-работы-с-виртуальной-памятью"><a class="header" href="#Системные-вызовы-для-работы-с-виртуальной-памятью">Системные вызовы для работы с виртуальной памятью</a></h2>
<p>Добавим новые системные вызовы в файл <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/syscall.rs"><code>kernel/src/process/syscall.rs</code></a>.</p>
<p>Эти системные вызовы будут принимать идентификатор <code>Pid</code> целевого процесса.
То есть, они будут позволять вызывающему процессу выполнить действие над самим собой,
задав
<a href="../../doc/ku/process/pid/enum.Pid.html#variant.Current"><code>Pid::Current</code></a>
или явно собственный идентификатор
<a href="../../doc/ku/process/pid/enum.Pid.html#variant.Id"><code>Pid::Id</code></a>.
Или же над другим процессом, указав его
<a href="../../doc/ku/process/pid/enum.Pid.html#variant.Id"><code>Pid::Id</code></a>.</p>
<p>Системные вызовы, которые требуется реализовать в этой задаче —
<a href="../../doc/kernel/process/syscall/fn.map.html"><code>map()</code></a>,
<a href="../../doc/kernel/process/syscall/fn.unmap.html"><code>unmap()</code></a> и
<a href="../../doc/kernel/process/syscall/fn.copy_mapping.html"><code>copy_mapping()</code></a>, —
принимают на вход область памяти, которая должна быть выровнена на границы страниц.
В случае, когда либо её адрес либо её размер не выровнен, системные вызовы должны возвращать ошибку
<a href="../../doc/ku/error/enum.Error.html#variant.WrongAlignment"><code>Error::WrongAlignment</code></a>.</p>
<h3 id="Валидация-аргументов"><a class="header" href="#Валидация-аргументов">Валидация аргументов</a></h3>
<p>Реализуйте функции валидации аргументов системных вызовов.</p>
<h4 id="kernelprocesssyscallcheck_block"><a class="header" href="#kernelprocesssyscallcheck_block"><a href="../../doc/kernel/process/syscall/fn.check_block.html"><code>kernel::process::syscall::check_block()</code></a></a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_block(
    address: usize,
    size: usize,
) -&gt; Result&lt;Block&lt;Page&gt;&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Проверяет, что <code>address</code> и <code>size</code> задают корректно выровненный диапазон страниц, целиком лежащий внутри одной из
<a href="../../lab/book/2-mm-1-types.html#%D0%94%D0%B2%D0%B5-%D0%BF%D0%BE%D0%BB%D0%BE%D0%B2%D0%B8%D0%BD%D1%8B-%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B0%D0%B4%D1%80%D0%B5%D1%81%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%B0">двух непрерывных половин</a>
адресного пространства.</p>
<h4 id="kernelprocesssyscallcheck_page_flags"><a class="header" href="#kernelprocesssyscallcheck_page_flags"><a href="../../doc/kernel/process/syscall/fn.check_page_flags.html"><code>kernel::process::syscall::check_page_flags()</code></a></a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_page_flags(flags: usize) -&gt; Result&lt;PageTableFlags&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Проверяет, что <code>flags</code> задаёт валидный набор флагов отображения страниц,
в котором обязательно должны быть включены флаги присутствия страницы в памяти и
разрешения доступа для пространства пользователя.</p>
<h4 id="kernelprocesssyscallcheck_frame"><a class="header" href="#kernelprocesssyscallcheck_frame"><a href="../../doc/kernel/process/syscall/fn.check_frame.html"><code>kernel::process::syscall::check_frame()</code></a></a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_frame(
    process: &amp;mut MutexGuard&lt;Process&gt;,
    page: Page,
    flags: PageTableFlags,
) -&gt; Result&lt;Frame&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Проверяет, что заданная виртуальная страница <code>page</code> отображена
в адресное пространство процесса <code>process</code> с корректно заданными флагами <code>flags</code> и
возвращает физический фрейм, в который она отображена.</p>
<h4 id="kernelprocesssyscallcheck_process_permissions"><a class="header" href="#kernelprocesssyscallcheck_process_permissions"><a href="../../doc/kernel/process/syscall/fn.check_process_permissions.html"><code>kernel::process::syscall::check_process_permissions()</code></a></a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_process_permissions(
    process: MutexGuard&lt;Process&gt;,
    dst_pid: usize,
) -&gt; Result&lt;MutexGuard&lt;Process&gt;&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Проверяет, что процесс <code>process</code> имеет право модифицировать целевой процесс, заданный своим идентификатором <code>dst_pid</code>.
Модифицировать можно либо самого себя, задавая <code>Pid::Current</code> или явно собственный идентификатор <code>Pid::Id</code>.
Либо свой непосредственно дочерний процесс, задавая его идентификатор.
Поглотите блокировку <code>process</code>, выдав взамен блокировку на целевой процесс.
Если он совпадает с <code>process</code> необходимо избежать
<a href="https://en.wikipedia.org/wiki/Deadlock">взаимоблокировку</a>
себя же.
Вам пригодится метод <code>Pid::from_usize()</code>.</p>
<h3 id="Системные-вызовы-для-работы-с-памятью"><a class="header" href="#Системные-вызовы-для-работы-с-памятью">Системные вызовы для работы с памятью</a></h3>
<p>Используя написанные вспомогательные функции реализуйте системные вызовы.</p>
<h4 id="kernelprocesssyscallmap"><a class="header" href="#kernelprocesssyscallmap"><a href="../../doc/kernel/process/syscall/fn.map.html"><code>kernel::process::syscall::map()</code></a></a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn map(
    process: MutexGuard&lt;Process&gt;,
    dst_pid: usize,
    dst_address: usize,
    dst_size: usize,
    flags: usize,
) -&gt; Result&lt;SyscallResult&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Отображает в памяти процесса, заданного <code>dst_pid</code>, блок страниц размера <code>dst_size</code> байт начиная с виртуального адреса <code>dst_address</code> с флагами доступа <code>flags</code>.
Если <code>dst_address</code> равен нулю, ядро само выбирает свободный участок адресного пространства размера <code>dst_size</code>.
Выбранный виртуальный адрес возвращается как результирующее значение системного вызова.
Размер при этом не возвращается, так как он должен быть равен аргументу <code>dst_address</code>.</p>
<p>Обратите внимание, что выбранный ядром виртуальный адрес должен быть корректно доставлен в
функцию пользователя, которая вызвала
<a href="../../doc/lib/syscall/fn.map.html"><code>lib::syscall::map()</code></a>.
Референсная реализация этой функции в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/user/lib/src/syscall.rs"><code>user/lib/src/syscall.rs</code></a>
предполагает, что ваша реализация функции
<a href="../../doc/lib/syscall/fn.syscall.html"><code>lib::syscall::syscall()</code></a>
помещает этот адрес в первый элемент возвращаемого кортежа.
Вы можете изменить это соглашение, но тогда поправьте и реализацию
<a href="../../doc/lib/syscall/fn.map.html"><code>lib::syscall::map()</code></a>.</p>
<p>Также системный вызов
<a href="../../doc/kernel/process/syscall/fn.map.html"><code>kernel::process::syscall::map()</code></a>
должен поддерживать отсутствие флага
<a href="../../doc/ku/memory/mmu/struct.PageTableFlags.html#associatedconstant.PRESENT"><code>PageTableFlags::PRESENT</code></a>
во входном аргументе <code>flags</code>.
В этом случае происходит выделение адресного пространства — виртуальных страниц.
Но не происходит выделения физических фреймов и их отображения.
Такой режим используется для реализации
<a href="../../doc/lib/allocator/map/struct.MapAllocator.html#method.reserve"><code>lib::allocator::map::MapAllocator::reserve()</code></a>.
Сама структура
<a href="../../doc/lib/allocator/map/struct.MapAllocator.html"><code>lib::allocator::map::MapAllocator</code></a>,
код которой уже написан, реализует
<a href="../../lab/book/4-concurrency-1-memory-allocator.html#%D0%A2%D0%B8%D0%BF%D0%B0%D0%B6-kuallocatorbigbigallocator">знакомый</a>
вам типаж
<a href="../../doc/ku/allocator/big/trait.BigAllocator.html"><code>ku::allocator::big::BigAllocator</code></a>
через системные вызовы
<a href="../../doc/kernel/process/syscall/fn.map.html"><code>map()</code></a>,
<a href="../../doc/kernel/process/syscall/fn.unmap.html"><code>unmap()</code></a> и
<a href="../../doc/kernel/process/syscall/fn.copy_mapping.html"><code>copy_mapping()</code></a>.
И позволяет аллоцировать память уже в пространстве пользователя.</p>
<h3 id="kernelprocesssyscallunmap"><a class="header" href="#kernelprocesssyscallunmap"><a href="../../doc/kernel/process/syscall/fn.unmap.html"><code>kernel::process::syscall::unmap()</code></a></a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn unmap(
    process: MutexGuard&lt;Process&gt;,
    dst_pid: usize,
    dst_address: usize,
    dst_size: usize,
) -&gt; Result&lt;SyscallResult&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Выполняет противоположную
<a href="../../doc/kernel/process/syscall/fn.map.html"><code>kernel::process::syscall::map()</code></a>
операцию — удаляет заданный диапазон из виртуальной памяти целевого процесса.</p>
<h3 id="kernelprocesssyscallcopy_mapping"><a class="header" href="#kernelprocesssyscallcopy_mapping"><a href="../../doc/kernel/process/syscall/fn.copy_mapping.html"><code>kernel::process::syscall::copy_mapping()</code></a></a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn copy_mapping(
    process: MutexGuard&lt;Process&gt;,
    dst_pid: usize,
    src_address: usize,
    dst_address: usize,
    dst_size: usize,
    flags: usize,
) -&gt; Result&lt;SyscallResult&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Создаёт копию отображения виртуальной памяти из вызывающего процесса в процесс, заданный <code>dst_pid</code>.
Исходный диапазон начинается с виртуального адреса <code>src_address</code>, целевой — с виртуального адреса <code>dst_address</code>.
Размер диапазона — <code>dst_size</code> байт.
Системный вызов должен отобразить целевой диапазон в целевой процесс с флагами <code>flags</code>.
Естественно,
<a href="../../doc/kernel/process/syscall/fn.copy_mapping.html"><code>kernel::process::syscall::copy_mapping()</code></a>
не должен допускать целевое отображение с более широким по логическим привилегиям набором флагов, чем исходное.
При этом флаги
<a href="../../doc/ku/memory/mmu/struct.PageTableFlags.html#associatedconstant.WRITABLE"><code>PageTableFlags::WRITABLE</code></a> и
<a href="../../doc/ku/memory/mmu/struct.PageTableFlags.html#associatedconstant.COPY_ON_WRITE"><code>PageTableFlags::COPY_ON_WRITE</code></a>
с точки зрения ядра имеют одинаковые логические привилегии, — доступность страницы на запись.</p>
<p>После его выполнения у процессов появляется область
<a href="https://en.wikipedia.org/wiki/Shared_memory">разделяемой памяти</a>.</p>
<p>Делать этот системный вызов транзакционным не требуется, но вы можете попробовать.</p>
<blockquote>
<p>Под транзакционностью подразумевается что сначала выполняются проверки всех доступов и физических фреймов.
И только если они прошли, начинается копирование отображения виртуальных страниц.
То есть, либо будет скопировано отображение всех виртуальных страниц и вызов завершится успешно.
Либо вызов вернёт ошибку, не скопировав ни одно из отображений.
Такая реализация сложнее чем наивная, которая может скопировать часть отображений страниц,
а после этого вернуть ошибку.
И для неё придётся очень аккуратно работать с двумя блокировками на процессы и корректностью кода
с точки зрения семантики владения.</p>
<p>Чтобы реализовать транзакционность, придётся пожертвовать либо значительным дополнительным временем,
либо дополнительным временем и значительной дополнительной памятью.
Если вы пойдёте по пути использования дополнительной памяти, вам также придётся правильно
ответить на вопрос в каком адресном пространстве её выделять.
И в этом случае вам могут пригодиться:</p>
<ul>
<li>Метод <a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.new_in"><code>Vec::new_in()</code></a>.</li>
<li>Вспомогательная функция <a href="../../doc/kernel/process/syscall/fn.check_frames.html"><code>kernel::process::syscall::check_frames(process, block, flags)</code></a>. Она проверяет, что заданный блок виртуальных страниц <code>block</code> отображён в адресное пространство процесса <code>process</code> с корректно заданными флагами <code>flags</code>. И возвращает вектор физических фреймов, в которые отображены эти страницы.</li>
<li>Вспомогательная функция <a href="../../doc/kernel/process/syscall/fn.map_pages_to_frames.html"><code>kernel::process::syscall::map_pages_to_frames(process, src_frames, dst_pages, flags)</code></a>. Она выполняет отображение <code>src_frames</code> в <code>dst_pages</code> с флагами <code>flags</code> в адресное пространство процесса <code>process</code>.</li>
</ul>
</blockquote>
<h3 id="Проверьте-себя-17"><a class="header" href="#Проверьте-себя-17">Проверьте себя</a></h3>
<p>Теперь должны заработать тесты <code>map_syscall_group()</code> и <code>user_space_memory_allocator()</code> в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/5-um-2-memory-allocator.rs"><code>kernel/tests/5-um-2-memory-allocator.rs</code></a>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 5-um-2-memory-allocator)
...
5_um_2_memory_allocator::map_syscall_group------------------
18:00:18 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
18:00:18 0 I duplicate; address_space = &quot;process&quot; @ 0p7E0A000
18:00:18 0 I switch to; address_space = &quot;process&quot; @ 0p7E0A000
18:00:18 0 D extend mapping; block = [0v10000000, 0v10008C5C), size 35.090 KiB; page_block = [0v10000000, 0v10009000), size 36.000 KiB; flags =   R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
18:00:18 0 D elf loadable program header; file_block = [0v201FC8, 0v20AC24), size 35.090 KiB; memory_block = [0v10000000, 0v10008C5C), size 35.090 KiB; flags =   R
18:00:18 0 D extend mapping; block = [0v10009000, 0v1006679D), size 373.903 KiB; page_block = [0v10009000, 0v10067000), size 376.000 KiB; flags = X R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
18:00:18 0 D elf loadable program header; file_block = [0v20AC28, 0v268765), size 374.810 KiB; memory_block = [0v10008C60, 0v1006679D), size 374.810 KiB; flags = X R
18:00:18 0 D elf loadable program header; file_block = [0v268768, 0v268880), size 280 B; memory_block = [0v100667A0, 0v100668B8), size 280 B; flags =  WR
18:00:18 0 D extend mapping; block = [0v10067000, 0v1006E240), size 28.562 KiB; page_block = [0v10067000, 0v1006F000), size 32.000 KiB; flags =  WR; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
18:00:18 0 D elf loadable program header; file_block = [0v268880, 0v270198), size 30.273 KiB; memory_block = [0v100668B8, 0v1006E240), size 30.383 KiB; flags =  WR
18:00:18 0 I switch to; address_space = &quot;base&quot; @ 0p1000
18:00:18 0 I loaded ELF file; context = { rip: 0v1000FE40, rsp: 0v7F7FFFFFF000 }; file_size = 5.765 MiB; process = { pid: &lt;current&gt;, address_space: &quot;process&quot; @ 0p7E0A000, { rip: 0v1000FE40, rsp: 0v7F7FFFFFF000 } }
18:00:18 0 I user process page table entry; entry_point = 0v1000FE40; frame = Frame(32229 @ 0p7DE5000); flags = PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED | DIRTY
18:00:18 0 D process_frames = 169
18:00:18 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E0A000
18:00:18 0 I switch to; address_space = &quot;base&quot; @ 0p1000
18:00:18 0 I drop the current address space; address_space = &quot;0:0&quot; @ 0p7E0A000; switch_to = &quot;base&quot; @ 0p1000
5_um_2_memory_allocator::map_syscall_group--------- [passed]

5_um_2_memory_allocator::user_space_memory_allocator--------
18:00:19.047 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
18:00:19.057 0 I duplicate; address_space = &quot;process&quot; @ 0p7E0A000
18:00:19.063 0 I switch to; address_space = &quot;process&quot; @ 0p7E0A000
18:00:19.071 0 D extend mapping; block = [0v10000000, 0v10008C5C), size 35.090 KiB; page_block = [0v10000000, 0v10009000), size 36.000 KiB; flags =   R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
18:00:19.085 0 D elf loadable program header; file_block = [0v201FC8, 0v20AC24), size 35.090 KiB; memory_block = [0v10000000, 0v10008C5C), size 35.090 KiB; flags =   R
18:00:19.125 0 D extend mapping; block = [0v10009000, 0v1006679D), size 373.903 KiB; page_block = [0v10009000, 0v10067000), size 376.000 KiB; flags = X R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
18:00:19.139 0 D elf loadable program header; file_block = [0v20AC28, 0v268765), size 374.810 KiB; memory_block = [0v10008C60, 0v1006679D), size 374.810 KiB; flags = X R
18:00:19.169 0 D elf loadable program header; file_block = [0v268768, 0v268880), size 280 B; memory_block = [0v100667A0, 0v100668B8), size 280 B; flags =  WR
18:00:19.181 0 D extend mapping; block = [0v10067000, 0v1006E240), size 28.562 KiB; page_block = [0v10067000, 0v1006F000), size 32.000 KiB; flags =  WR; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
18:00:19.195 0 D elf loadable program header; file_block = [0v268880, 0v270198), size 30.273 KiB; memory_block = [0v100668B8, 0v1006E240), size 30.383 KiB; flags =  WR
18:00:19.223 0 I switch to; address_space = &quot;base&quot; @ 0p1000
18:00:19.229 0 I loaded ELF file; context = { rip: 0v1000FE40, rsp: 0v7F7FFFFFF000 }; file_size = 5.765 MiB; process = { pid: &lt;current&gt;, address_space: &quot;process&quot; @ 0p7E0A000, { rip: 0v1000FE40, rsp: 0v7F7FFFFFF000 } }
18:00:19.245 0 I allocate; slot = Process { pid: 0:0, address_space: &quot;0:0&quot; @ 0p7E0A000, { rip: 0v1000FE40, rsp: 0v7F7FFFFFF000 } }; process_count = 1
18:00:19.255 0 I user process page table entry; entry_point = 0v1000FE40; frame = Frame(32123 @ 0p7D7B000); flags = PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED | DIRTY
18:00:19.269 0 D process_frames = 169
18:00:19.275 0 I dequeue; pid = Some(0:0)
18:00:19.281 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E0A000
18:00:19.287 0 D entering the user mode; pid = 0:0; registers = { rax: 0x0, rdi: 0x7F7FFFFDB000, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v1000FE40, ss:rsp: 0x001B:0v7F7FFFFFF000, rflags: IF } }
18:00:19.305 0 I test_case = &quot;basic&quot;; pid = 0:0
18:00:19.313 0 D start_info = { allocations: 0 - 0 = 0, requested: 0 B - 0 B = 0 B, allocated: 0 B - 0 B = 0 B, pages: 0 - 0 = 0, loss: 0 B = 0.000% }; pid = 0:0
18:00:19.355 0 D box_contents = 2; pid = 0:0
18:00:19.355 0 D info = { allocations: 1 - 0 = 1, requested: 4.000 KiB - 0 B = 4.000 KiB, allocated: 4.000 KiB - 0 B = 4.000 KiB, pages: 1 - 0 = 1, loss: 0 B = 0.000% }; pid = 0:0
18:00:19.363 0 D info_diff = { allocations: 1 - 0 = 1, requested: 4.000 KiB - 0 B = 4.000 KiB, allocated: 4.000 KiB - 0 B = 4.000 KiB, pages: 1 - 0 = 1, loss: 0 B = 0.000% }; pid = 0:0
18:00:19.403 0 D end_info = { allocations: 1 - 1 = 0, requested: 4.000 KiB - 4.000 KiB = 0 B, allocated: 4.000 KiB - 4.000 KiB = 0 B, pages: 1 - 1 = 0, loss: 0 B = 0.000% }; pid = 0:0
18:00:19.405 0 D end_info_diff = { allocations: 1 - 1 = 0, requested: 4.000 KiB - 4.000 KiB = 0 B, allocated: 4.000 KiB - 4.000 KiB = 0 B, pages: 1 - 1 = 0, loss: 0 B = 0.000% }; pid = 0:0
18:00:19.407 0 I test_case = &quot;grow_and_shrink&quot;; pid = 0:0
18:00:19.409 0 D start_info = { allocations: 1 - 1 = 0, requested: 4.000 KiB - 4.000 KiB = 0 B, allocated: 4.000 KiB - 4.000 KiB = 0 B, pages: 1 - 1 = 0, loss: 0 B = 0.000% }; pid = 0:0
18:00:19.481 0 D leaving the user mode; pid = 0:0
18:00:19.487 0 I the process was preempted; pid = 0:0; user_context = { mode: user, cs:rip: 0x0023:0v1000DFE3, ss:rsp: 0x001B:0v7F7FFFFFDB58, rflags: IF }
18:00:19.497 0 I returned
18:00:19.501 0 I dequeue; pid = Some(0:0)
18:00:19.505 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E0A000
18:00:19.511 0 D entering the user mode; pid = 0:0; registers = { rax: 0x1, rdi: 0x7F7FFFFFDF20, rsi: 0x2455, { mode: user, cs:rip: 0x0023:0v1000DFE3, ss:rsp: 0x001B:0v7F7FFFFFDB58, rflags: IF } }
18:00:19.533 0 D contents_sum = 75491328; push_sum = 75491328; pid = 0:0
18:00:19.535 0 D info = { allocations: 7 - 6 = 1, requested: 256.000 KiB - 128.000 KiB = 128.000 KiB, allocated: 256.000 KiB - 128.000 KiB = 128.000 KiB, pages: 64 - 32 = 32, loss: 0 B = 0.000% }; pid = 0:0
18:00:19.537 0 D info_diff = { allocations: 6 - 5 = 1, requested: 252.000 KiB - 124.000 KiB = 128.000 KiB, allocated: 252.000 KiB - 124.000 KiB = 128.000 KiB, pages: 63 - 31 = 32, loss: 0 B = 0.000% }; pid = 0:0
18:00:19.589 0 D contents_sum = 75491328; pop_sum = 75491328; pid = 0:0
18:00:19.591 0 D end_info = { allocations: 12 - 12 = 0, requested: 380.000 KiB - 380.000 KiB = 0 B, allocated: 380.000 KiB - 380.000 KiB = 0 B, pages: 95 - 95 = 0, loss: 0 B = 0.000% }; pid = 0:0
18:00:19.615 0 I free; slot = Process { pid: 0:0, address_space: &quot;0:0&quot; @ 0p7E0A000, { rip: 0v1000DFE3, rsp: 0v7F7FFFFFDB58 } }; process_count = 0
18:00:19.625 0 I switch to; address_space = &quot;base&quot; @ 0p1000
18:00:19.629 0 I drop the current address space; address_space = &quot;0:0&quot; @ 0p7E0A000; switch_to = &quot;base&quot; @ 0p1000
18:00:19.687 0 I syscall = &quot;exit&quot;; pid = 0:0; code = 0; reason = Some(OK)
18:00:19.693 0 D leaving the user mode; pid = 0:0
18:00:19.697 0 I dequeue; pid = None
5_um_2_memory_allocator::user_space_memory_allocator [passed]
18:00:19.707 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<p>Как видно, тест <code>user_space_memory_allocator()</code> запускает те же проверки,
что и тесты <code>basic()</code> и <code>grow_and_shrink()</code> из
<a href="../../lab/book/4-concurrency-1-memory-allocator.html#%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-1--%D0%B0%D0%BB%D0%BB%D0%BE%D0%BA%D0%B0%D1%82%D0%BE%D1%80-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8-%D0%BE%D0%B1%D1%89%D0%B5%D0%B3%D0%BE-%D0%BD%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F">задачи про аллокатор памяти общего назначения в ядре</a>.
Но делает это в пространстве пользователя.</p>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-21"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-21">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> syscall.rs |  163 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------
 1 file changed, 145 insertions(+), 18 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="eager-fork"><a class="header" href="#eager-fork">Eager <code>fork()</code></a></h2>
<p>Системный вызов
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/fork.html"><code>fork()</code></a>
долгое время считался удачной абстракцией.
Но время показало, что у него есть и большое количество недостатков,
см. статью
<a href="https://www.microsoft.com/en-us/research/uploads/prod/2019/04/fork-hotos19.pdf">A <code>fork()</code> in the road</a>.
Хотя не стоит воспринимать
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/fork.html"><code>fork()</code></a>
как удачный интерфейс порождения процессов,
его реализация является хорошим упражнением.</p>
<p>Nikka воплощает некоторые идеи <a href="https://en.wikipedia.org/wiki/Exokernel">экзоядра</a>,
поэтому реализовывать
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/fork.html"><code>fork()</code></a>
будем в пространстве пользователя.
Естественно, от ядра потребуется небольшая помощь.
Тем более то, что реализует ядро, пригодится и для других целей.
Например, можно будет реализовать аналог современного системного вызова для порождения процессов —
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawn.html"><code>posix_spawn()</code></a>.
Естественно, также в пространстве пользователя.</p>
<p>Подробнее про концепцию экзоядра можно почитать в оригинальной статье —
<a href="https://pdos.csail.mit.edu/6.828/2008/readings/engler95exokernel.pdf">Exokernel: an operating system architecture for application-level resource management</a>.</p>
<h3 id="Системный-вызов-kernelprocesssyscallexofork"><a class="header" href="#Системный-вызов-kernelprocesssyscallexofork">Системный вызов <a href="../../doc/kernel/process/syscall/fn.exofork.html"><code>kernel::process::syscall::exofork()</code></a></a></h3>
<p>Реализуйте <a href="../../doc/kernel/process/syscall/fn.exofork.html">системный вызов</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn exofork(
    process: MutexGuard&lt;Process&gt;,
    context: MiniContext,
) -&gt; Result&lt;SyscallResult&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/syscall.rs"><code>kernel/src/process/syscall.rs</code></a>.</p>
<p>Он создаёт копию вызывающего процесса <code>process</code> и возвращает его <code>Pid</code>.
При этом новый процесс создаётся практически без адресного пространства и не готовый к работе.
Поэтому он, в частности, не ставится в очередь планировщика.</p>
<p>Этот системный вызов использует создание копии системной части адресного пространства процесса <code>process</code>,
которое
<a href="../../lab/book/2-mm-6-address-space-2-translate.html#%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-6--%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D0%B9-%D0%BA%D0%BE%D0%BF%D0%B8%D0%B8-%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BE%D1%82%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F">вы реализовали ранее</a>.
А вот пользовательскую часть адресного пространства он не копирует.
Этим займётся код на стороне пользователя.</p>
<p>Системный вызов <code>exofork()</code> возвращает <code>Pid::Id</code> с идентификатором потомка в процессе родителя и константу <code>Pid::Current</code> в процессе потомка.</p>
<p>Текущий контекст родителя — <code>context</code> — нужно записать в потомка.
Вы уже делали аналогично для
<a href="../../doc/kernel/process/syscall/fn.sched_yield.html"><code>sched_yield()</code></a>.
В родителя
<a href="../../doc/kernel/process/syscall/fn.exofork.html"><code>exofork()</code></a>
вернётся через функцию
<a href="../../doc/kernel/process/syscall/fn.sysret.html"><code>kernel::process::syscall::sysret()</code></a>,
которая получает <code>context</code> на вход и восстанавливает его.
А вот потомок будет позже запущен планировщиком через цепочку
<a href="../../doc/kernel/process/process/struct.Process.html#method.enter_user_mode"><code>kernel::process::process::Process::enter_user_mode()</code></a> -&gt;
<a href="../../doc/kernel/process/registers/struct.Registers.html#method.switch_to"><code>kernel::process::registers::Registers::switch_to()</code></a> -&gt;
<a href="https://www.felixcloutier.com/x86/iret:iretd:iretq"><code>iretq</code></a>.
И для
<a href="https://www.felixcloutier.com/x86/iret:iretd:iretq"><code>iretq</code></a>
нужно предоставить правильный контекст пользователя, в который нужно будет переключиться.</p>
<p>Обратите внимание на код библиотечной обёртки
<a href="../../doc/lib/syscall/fn.exofork.html"><code>lib::syscall::exofork()</code></a>
для этого системного вызова
в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/user/lib/src/syscall.rs"><code>user/lib/src/syscall.rs</code></a>.
Она предполагает, что ваша реализация функции
<a href="../../doc/lib/syscall/fn.syscall.html"><code>lib::syscall::syscall()</code></a>
возвращает два поля в кортеже — <code>child_pid</code> и <code>process_info</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (child_pid, process_info) = syscall(Syscall::EXOFORK.bits(), 0, 0, 0, 0, 0)?;
<span class="boring">}
</span></code></pre></pre>
<p>В поле <code>child_pid</code> должен быть <code>Pid::Id</code> с идентификатором потомка в процессе родителя или
<code>Pid::Current</code> в процессе потомка.
А в <code>process_info</code> — ссылка на системную информацию о текущем процессе
<a href="../../doc/ku/info/struct.ProcessInfo.html"><code>ku::info::ProcessInfo</code></a>.
Это поле имеет смысл только для потомка.
Соглашение такое: ядро при запуске нового процесса и через метод
<a href="../../doc/kernel/process/struct.Process.html#method.new"><code>kernel::process::Process::new()</code></a>
и через метод
<a href="../../doc/kernel/process/struct.Process.html#method.duplicate"><code>kernel::process::Process::duplicate()</code></a>
передаёт в одном из регистров ссылку на
<a href="../../doc/ku/info/struct.ProcessInfo.html"><code>ku::info::ProcessInfo</code></a>.
Метод
<a href="../../doc/kernel/process/struct.Process.html#method.new"><code>kernel::process::Process::new()</code></a>
использует регистр <code>rdi</code>.
А метод
<a href="../../doc/kernel/process/struct.Process.html#method.duplicate"><code>kernel::process::Process::duplicate()</code></a> —
<code>rsi</code>, предполагая что ошибка из системного вызова передаётся через <code>rax</code>, а <code>pid</code> — через <code>rdi</code>.
Вы можете поменять эти соглашения.
Но в любом случае проверьте, что в
<a href="../../doc/lib/syscall/fn.exofork.html"><code>lib::syscall::exofork()</code></a>
приходит правильные и <code>pid</code> и ссылка на
<a href="../../doc/ku/info/struct.ProcessInfo.html"><code>ku::info::ProcessInfo</code></a>.</p>
<h3 id="Системный-вызов-kernelprocesssyscallset_state"><a class="header" href="#Системный-вызов-kernelprocesssyscallset_state">Системный вызов <a href="../../doc/kernel/process/syscall/fn.set_state.html"><code>kernel::process::syscall::set_state()</code></a></a></h3>
<p>Реализуйте <a href="../../doc/kernel/process/syscall/fn.set_state.html">системный вызов</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_state(
    process: MutexGuard&lt;Process&gt;,
    dst_pid: usize,
    state: usize,
) -&gt; Result&lt;SyscallResult&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/syscall.rs"><code>kernel/src/process/syscall.rs</code></a>.</p>
<p>Он переводит целевой процесс, заданный идентификатором <code>dst_pid</code>, в заданное состояние <code>state</code>.
И ставит его в очередь планировщика в случае <code>State::Runnable</code>.
Не забудьте <a href="../../lab/book/5-um-2-memory.html#check_process_permissions">проверить права доступа</a> процесса <code>process</code> к процессу <code>dst_pid</code>.</p>
<h3 id="Рекурсивное-отображение-памяти"><a class="header" href="#Рекурсивное-отображение-памяти">Рекурсивное отображение памяти</a></h3>
<p>Для того чтобы в пространстве пользователя процесс мог прочитать собственное отображение страниц адресного пространства,
удобно использовать старый джедайский трюк —
<a href="https://os.phil-opp.com/page-tables/#recursive-mapping">рекурсивное отображение памяти</a>.</p>
<p>Реализуйте <a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.make_recursive_mapping">метод</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Mapping::make_recursive_mapping(&amp;mut self) -&gt; Result&lt;usize&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/memory/mapping.rs"><code>kernel/src/memory/mapping.rs</code></a>.
Выберете в таблице страниц корневого уровня свободную запись, например ближе к концу.
И используйте её как рекурсивную.
Сохраните её номер в поле
<a href="../../doc/kernel/memory/mapping/struct.Mapping.html#structfield.recursive_mapping"><code>Mapping::recursive_mapping</code></a>
и верните наружу.
Поправьте методы
<a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.duplicate_page_table"><code>Mapping::duplicate_page_table()</code></a> и
<a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.drop_page_table"><code>Mapping::drop_page_table()</code></a>,
чтобы они игнорировали эту запись корневой таблицы страниц.</p>
<h3 id="Библиотечные-функции"><a class="header" href="#Библиотечные-функции">Библиотечные функции</a></h3>
<p>В файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/user/lib/src/memory/mod.rs"><code>user/lib/src/memory/mod.rs</code></a> реализуйте вспомогательные функции кода пользователя.</p>
<h4 id="libmemorytemp_page"><a class="header" href="#libmemorytemp_page"><a href="../../doc/lib/memory/fn.temp_page.html"><code>lib::memory::temp_page()</code></a></a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn temp_page() -&gt; Result&lt;Page&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Заводит в адресном пространстве процесса страницу памяти для временных нужд.
Использует системный вызов
<a href="../../doc/lib/syscall/fn.map.html"><code>lib::syscall::map()</code></a>,
определённый в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/user/lib/src/syscall.rs"><code>user/lib/src/syscall.rs</code></a>,
реализацию которого в ядре <a href="../../lab/book/5-um-2-memory.html#map">вы уже написали</a>.</p>
<h4 id="libmemorycopy_page"><a class="header" href="#libmemorycopy_page"><a href="../../doc/lib/memory/fn.copy_page.html"><code>lib::memory::copy_page()</code></a></a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn copy_page(src: Page, dst: Page)
<span class="boring">}
</span></code></pre></pre>
<p>Копирует содержимое страницы <code>src</code> в страницу <code>dst</code> с помощью
<a href="https://doc.rust-lang.org/nightly/core/ptr/fn.copy_nonoverlapping.html">core::ptr::copy_nonoverlapping()</a>.</p>
<h4 id="libmemorypage_table"><a class="header" href="#libmemorypage_table"><a href="../../doc/lib/memory/fn.page_table.html"><code>lib::memory::page_table()</code></a></a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn page_table(address: Virt, level: u32) -&gt; &amp;'static PageTable
<span class="boring">}
</span></code></pre></pre>
<p>Пользуясь рекурсивной записью таблицы страниц,
выдаёт ссылку на таблицу страниц заданного уровня <code>level</code> для заданного виртуального адреса <code>address</code>.
Узнать номер рекурсивной записи в пространстве пользователя можно методом
<a href="../../doc/ku/info/struct.ProcessInfo.html#method.recursive_mapping"><code>ProcessInfo::recursive_mapping()</code></a>,
а получить саму структуру
<a href="../../doc/ku/info/struct.ProcessInfo.html"><code>ku::info::ProcessInfo</code></a>
можно функцией
<a href="../../doc/ku/info/fn.process_info.html"><code>ku::info::process_info()</code></a>.</p>
<h3 id="Основной-код-пользовательского-процесса-eager_fork"><a class="header" href="#Основной-код-пользовательского-процесса-eager_fork">Основной код пользовательского процесса <code>eager_fork</code></a></h3>
<p>В файле <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/user/eager_fork/src/main.rs"><code>user/eager_fork/src/main.rs</code></a> пользовательского процесса <code>eager_fork</code> реализуйте следующие функции.</p>
<h4 id="copy_page_table"><a class="header" href="#copy_page_table"><code>copy_page_table()</code></a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn copy_page_table(
    child: Pid,
    level: u32,
    virt_addr: Virt,
) -&gt; Result&lt;()&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Копирует таблицу страниц уровня <code>level</code> для виртуального адреса <code>virt_addr</code> из своего адресного пространства в пространство дочернего процесса <code>child</code>.
Работает рекурсивно.
Корень рекурсии запускает функция</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn copy_address_space(child: Pid) -&gt; Result&lt;()&gt; {
    copy_page_table(child, PAGE_DIRECTORY_LEVEL, Virt::default())
}
<span class="boring">}
</span></code></pre></pre>
<p>Проходится по таблице страниц, получая ссылку на неё с помощью
<a href="../../lab/book/5-um-3-eager-fork.html#page_table">реализованной вами ранее</a>
<code>lib::memory::page_table()</code>.
На записях <code>PageTableEntry</code>, которые доступны для пользовательского кода, либо рекурсивно спускается на следующий уровень таблицы страниц, либо на листьевом уровне копирует содержимое отображённой страницы.
Адрес отображаемой страницы вычисляет поэтапно на рекурсивных вызовах с помощью аргумента <code>virt_addr</code>,
номера обрабатываемой записи <code>PageTableEntry</code> и уровня таблицы страниц.</p>
<p>Для копирования страницы в целевой процесс, сначала выделяет временную страницу в собственном адресном пространстве с помощью функции <code>lib::memory::temp_page()</code>.
Копирует текущую отображаемую страницу туда с помощью
<a href="../../lab/book/5-um-3-eager-fork.html#copy_page">реализованной вами ранее</a>
функции <code>lib::memory::copy_page()</code>.
Затем, с помощью системных вызовов
<a href="../../doc/lib/syscall/fn.copy_mapping.html"><code>lib::syscall::copy_mapping()</code></a>
и
<a href="../../doc/lib/syscall/fn.unmap.html"><code>lib::syscall::unmap()</code></a>
передаёт скопированную временную страницу потомку <code>child</code>, отображая её в его адресном пространстве
по адресу исходной страницы в своём адресном пространстве.</p>
<p>Запись номер <code>ku::process_info().recursive_mapping()</code> корневой таблицы страниц, а также страницы,
предоставляющие пользовательскому процессу информацию о нём, системе и <code>RingBuffer</code> для логирования,
нужно проигнорировать.
То есть, страницы для которых <code>ku::process_info().contains_address()</code> возвращает <code>true</code>.
Их отобразит в память потомка ядро, выбирая новые, а не разделяемые, физические фреймы.</p>
<h4 id="eager_fork"><a class="header" href="#eager_fork"><code>eager_fork()</code></a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn eager_fork() -&gt; Result&lt;bool&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Создаёт процесс потомка с помощью
<a href="../../lab/book/5-um-3-eager-fork.html#%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%BD%D1%8B%D0%B9-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2-exofork">реализованного вами ранее</a>
системного вызова <code>syscall::exofork()</code>.
Далее копирует своё адресное пространство в пространство потомка с помощью функции <code>fn copy_address_space()</code>.
И запускает потомка системным вызовом <code>syscall::set_state()</code>, устанавливая его состояние в <code>State::Runnable</code>.
В потомке ничего не делает.
Возвращает <code>true</code> в процессе потомка и <code>false</code> в процессе родителя.</p>
<h3 id="Проверьте-себя-18"><a class="header" href="#Проверьте-себя-18">Проверьте себя</a></h3>
<p>Теперь должны заработать тесты <code>exofork_syscall()</code> и <code>eager_fork()</code> в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/5-um-3-eager-fork.rs"><code>kernel/tests/5-um-3-eager-fork.rs</code></a>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 5-um-3-eager-fork)
...
5_um_3_eager_fork::exofork_syscall--------------------------
15:26:59 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
15:26:59 0 I duplicate; address_space = &quot;process&quot; @ 0p7E0A000
15:26:59 0 I switch to; address_space = &quot;process&quot; @ 0p7E0A000
15:26:59 0 D extend mapping; block = [0v10000000, 0v10007644), size 29.566 KiB; page_block = [0v10000000, 0v10008000), size 32.000 KiB; flags =   R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
15:26:59 0 D elf loadable program header; file_block = [0v2016D9, 0v208D1D), size 29.566 KiB; memory_block = [0v10000000, 0v10007644), size 29.566 KiB; flags =   R
15:26:59 0 D extend mapping; block = [0v10008000, 0v100547CD), size 305.950 KiB; page_block = [0v10008000, 0v10055000), size 308.000 KiB; flags = X R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
15:26:59 0 D elf loadable program header; file_block = [0v208D29, 0v255EA6), size 308.372 KiB; memory_block = [0v10007650, 0v100547CD), size 308.372 KiB; flags = X R
15:26:59 0 D elf loadable program header; file_block = [0v255EA9, 0v255F99), size 240 B; memory_block = [0v100547D0, 0v100548C0), size 240 B; flags =  WR
15:26:59 0 D extend mapping; block = [0v10055000, 0v1005AAE0), size 22.719 KiB; page_block = [0v10055000, 0v1005B000), size 24.000 KiB; flags =  WR; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
15:26:59 0 D elf loadable program header; file_block = [0v255F99, 0v25C191), size 24.492 KiB; memory_block = [0v100548C0, 0v1005AAE0), size 24.531 KiB; flags =  WR
15:26:59 0 I switch to; address_space = &quot;base&quot; @ 0p1000
15:26:59 0 I loaded ELF file; context = { rip: 0v10007BC0, rsp: 0v7F7FFFFFF000 }; file_size = 5.474 MiB; process = { pid: &lt;current&gt;, address_space: &quot;process&quot; @ 0p7E0A000, { rip: 0v10007BC0, rsp: 0v7F7FFFFFF000 } }
15:26:59 0 I allocate; slot = Process { pid: 0:0, address_space: &quot;0:0&quot; @ 0p7E0A000, { rip: 0v10007BC0, rsp: 0v7F7FFFFFF000 } }; process_count = 1
15:26:59 0 I user process page table entry; entry_point = 0v10007BC0; frame = Frame(32234 @ 0p7DEA000); flags = PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED | DIRTY
15:26:59 0 D process_frames = 152
15:26:59 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
15:26:59 0 I duplicate; address_space = &quot;process&quot; @ 0p7D72000
15:26:59 0 I switch to; address_space = &quot;process&quot; @ 0p7D72000
15:26:59 0 D extend mapping; block = [0v10000000, 0v10007644), size 29.566 KiB; page_block = [0v10000000, 0v10008000), size 32.000 KiB; flags =   R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
15:26:59 0 D elf loadable program header; file_block = [0v2016D9, 0v208D1D), size 29.566 KiB; memory_block = [0v10000000, 0v10007644), size 29.566 KiB; flags =   R
15:26:59 0 D extend mapping; block = [0v10008000, 0v100547CD), size 305.950 KiB; page_block = [0v10008000, 0v10055000), size 308.000 KiB; flags = X R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
15:26:59 0 D elf loadable program header; file_block = [0v208D29, 0v255EA6), size 308.372 KiB; memory_block = [0v10007650, 0v100547CD), size 308.372 KiB; flags = X R
15:26:59 0 D elf loadable program header; file_block = [0v255EA9, 0v255F99), size 240 B; memory_block = [0v100547D0, 0v100548C0), size 240 B; flags =  WR
15:26:59 0 D extend mapping; block = [0v10055000, 0v1005AAE0), size 22.719 KiB; page_block = [0v10055000, 0v1005B000), size 24.000 KiB; flags =  WR; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
15:26:59 0 D elf loadable program header; file_block = [0v255F99, 0v25C191), size 24.492 KiB; memory_block = [0v100548C0, 0v1005AAE0), size 24.531 KiB; flags =  WR
15:27:00.013 0 I switch to; address_space = &quot;base&quot; @ 0p1000
15:27:00.017 0 I loaded ELF file; context = { rip: 0v10007BC0, rsp: 0v7F7FFFFFF000 }; file_size = 5.474 MiB; process = { pid: &lt;current&gt;, address_space: &quot;process&quot; @ 0p7D72000, { rip: 0v10007BC0, rsp: 0v7F7FFFFFF000 } }
15:27:00.031 0 I allocate; slot = Process { pid: 1:0, address_space: &quot;1:0&quot; @ 0p7D72000, { rip: 0v10007BC0, rsp: 0v7F7FFFFFF000 } }; process_count = 2
15:27:00.041 0 I user process page table entry; entry_point = 0v10007BC0; frame = Frame(32082 @ 0p7D52000); flags = PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED | DIRTY
15:27:00.055 0 D process_frames = 152
15:27:00.059 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E0A000
15:27:00.153 0 I page allocator init; free_page_count = 33688649728; block = [0v18000000000, 0v7F0000000000), size 125.500 TiB
15:27:00.161 0 I duplicate; address_space = &quot;process&quot; @ 0p7CDA000
15:27:00.167 0 I switch to; address_space = &quot;process&quot; @ 0p7CDA000
15:27:00.173 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E0A000
15:27:00.179 0 I allocate; slot = Process { pid: 2:0, address_space: &quot;2:0&quot; @ 0p7CDA000, { rip: 0v0, rsp: 0v0 } }; process_count = 3
15:27:00.189 0 I syscall = &quot;exofork&quot;; process = 0:0; child = 2:0
15:27:00.195 0 D child_pid = 2:0
15:27:00.199 0 D child = { pid: 2:0, address_space: &quot;2:0&quot; @ 0p7CDA000, { rip: 0v0, rsp: 0v0 } }
15:27:00.211 0 I free; slot = Process { pid: 0:0, address_space: &quot;0:0&quot; @ 0p7E0A000, { rip: 0v10007BC0, rsp: 0v7F7FFFFFF000 } }; process_count = 2
15:27:00.219 0 I switch to; address_space = &quot;base&quot; @ 0p1000
15:27:00.225 0 I drop the current address space; address_space = &quot;0:0&quot; @ 0p7E0A000; switch_to = &quot;base&quot; @ 0p1000
15:27:00.293 0 I free; slot = Process { pid: 1:0, address_space: &quot;1:0&quot; @ 0p7D72000, { rip: 0v10007BC0, rsp: 0v7F7FFFFFF000 } }; process_count = 1
15:27:00.303 0 I drop; address_space = &quot;1:0&quot; @ 0p7D72000
15:27:00.367 0 I dequeue; pid = Some(2:0)
15:27:00.373 0 I switch to; address_space = &quot;2:0&quot; @ 0p7CDA000
15:27:00.379 0 D entering the user mode; pid = 2:0; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7EFFFFFFB000, { mode: user, cs:rip: 0x0023:0v0, ss:rsp: 0x001B:0v0, rflags: IF } }
15:27:00.395 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v0, ss:rsp: 0x001B:0v0, rflags: IF }; info = { address: 0v0, code: 0b10100 = non-present page | execute | user }
15:27:00.425 0 I user mode trap; trap = &quot;Page Fault&quot;; number = 14; info = { address: 0v0, code: 0b10100 = non-present page | execute | user }; context = { mode: user, cs:rip: 0x0023:0v0, ss:rsp: 0x001B:0v0, rflags: IF }; pid = 2:0
15:27:00.441 0 I free; slot = Process { pid: 2:0, address_space: &quot;2:0&quot; @ 0p7CDA000, { rip: 0v0, rsp: 0v0 } }; process_count = 0
15:27:00.451 0 I switch to; address_space = &quot;base&quot; @ 0p1000
15:27:00.457 0 I drop the current address space; address_space = &quot;2:0&quot; @ 0p7CDA000; switch_to = &quot;base&quot; @ 0p1000
15:27:00.529 0 D leaving the user mode; pid = 2:0
15:27:00.535 0 I dequeue; pid = None
5_um_3_eager_fork::exofork_syscall----------------- [passed]

5_um_3_eager_fork::eager_fork-------------------------------
15:27:00.635 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
15:27:00.645 0 I duplicate; address_space = &quot;process&quot; @ 0p7CC4000
15:27:00.649 0 I switch to; address_space = &quot;process&quot; @ 0p7CC4000
15:27:00.657 0 D extend mapping; block = [0v10000000, 0v10007A34), size 30.551 KiB; page_block = [0v10000000, 0v10008000), size 32.000 KiB; flags =   R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
15:27:00.671 0 D elf loadable program header; file_block = [0v77B368, 0v782D9C), size 30.551 KiB; memory_block = [0v10000000, 0v10007A34), size 30.551 KiB; flags =   R
15:27:00.707 0 D extend mapping; block = [0v10008000, 0v1005D3F2), size 340.986 KiB; page_block = [0v10008000, 0v1005E000), size 344.000 KiB; flags = X R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
15:27:00.721 0 D elf loadable program header; file_block = [0v782DA8, 0v7D875A), size 342.424 KiB; memory_block = [0v10007A40, 0v1005D3F2), size 342.424 KiB; flags = X R
15:27:00.747 0 D elf loadable program header; file_block = [0v7D8760, 0v7D8860), size 256 B; memory_block = [0v1005D3F8, 0v1005D4F8), size 256 B; flags =  WR
15:27:00.759 0 D extend mapping; block = [0v1005E000, 0v100640A0), size 24.156 KiB; page_block = [0v1005E000, 0v10065000), size 28.000 KiB; flags =  WR; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
15:27:00.771 0 D elf loadable program header; file_block = [0v7D8860, 0v7DF3E0), size 26.875 KiB; memory_block = [0v1005D4F8, 0v100640A0), size 26.914 KiB; flags =  WR
15:27:00.799 0 I switch to; address_space = &quot;base&quot; @ 0p1000
15:27:00.803 0 I loaded ELF file; context = { rip: 0v1000F750, rsp: 0v7F7FFFFFF000 }; file_size = 5.763 MiB; process = { pid: &lt;current&gt;, address_space: &quot;process&quot; @ 0p7CC4000, { rip: 0v1000F750, rsp: 0v7F7FFFFFF000 } }
15:27:00.817 0 I allocate; slot = Process { pid: 2:1, address_space: &quot;2:1&quot; @ 0p7CC4000, { rip: 0v1000F750, rsp: 0v7F7FFFFFF000 } }; process_count = 1
15:27:00.827 0 I user process page table entry; entry_point = 0v1000F750; frame = Frame(32098 @ 0p7D62000); flags = PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED | DIRTY
15:27:00.841 0 D process_frames = 162
15:27:00.845 0 I dequeue; pid = Some(2:1)
15:27:00.849 0 I switch to; address_space = &quot;2:1&quot; @ 0p7CC4000
15:27:00.853 0 D entering the user mode; pid = 2:1; registers = { rax: 0x0, rdi: 0x7F7FFFFDB000, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v1000F750, ss:rsp: 0x001B:0v7F7FFFFFF000, rflags: IF } }
15:27:00.873 0 I name = &quot;eager_fork *&quot;; pedigree = [2:1]; len = 1; capacity = 3; pid = 2:1
15:27:01.021 0 I page allocator init; free_page_count = 33688649728; block = [0v18000000000, 0v7F0000000000), size 125.500 TiB
15:27:01.029 0 I duplicate; address_space = &quot;process&quot; @ 0p7D4C000
15:27:01.035 0 I switch to; address_space = &quot;process&quot; @ 0p7D4C000
15:27:01.041 0 I switch to; address_space = &quot;2:1&quot; @ 0p7CC4000
15:27:01.047 0 I allocate; slot = Process { pid: 1:1, address_space: &quot;1:1&quot; @ 0p7D4C000, { rip: 0v1000B487, rsp: 0v7F7FFFFFDB08 } }; process_count = 2
15:27:01.057 0 I syscall = &quot;exofork&quot;; process = 2:1; child = 1:1
15:27:01.063 0 D leaving the user mode; pid = 2:1
15:27:01.069 0 I the process was preempted; pid = 2:1; user_context = { mode: user, cs:rip: 0x0023:0v1002759D, ss:rsp: 0x001B:0v7F7FFFFFD968, rflags: IF ZF PF }
15:27:01.079 0 I returned
15:27:01.083 0 I dequeue; pid = Some(2:1)
15:27:01.087 0 I switch to; address_space = &quot;2:1&quot; @ 0p7CC4000
15:27:01.093 0 D entering the user mode; pid = 2:1; registers = { rax: 0xFE, rdi: 0x10060B38, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v1002759D, ss:rsp: 0x001B:0v7F7FFFFFD968, rflags: IF ZF PF } }
15:27:01.107 0 I syscall::exofork() done; child = Ok(1:1); pid = 2:1
15:27:01.289 0 I syscall::set_state(); child = 1:1; result = Ok(()); pid = 2:1
15:27:01.387 0 I page allocator init; free_page_count = 33688649728; block = [0v18000000000, 0v7F0000000000), size 125.500 TiB
15:27:01.397 0 I duplicate; address_space = &quot;process&quot; @ 0p7DF2000
15:27:01.401 0 I switch to; address_space = &quot;process&quot; @ 0p7DF2000
15:27:01.407 0 I switch to; address_space = &quot;2:1&quot; @ 0p7CC4000
15:27:01.413 0 I allocate; slot = Process { pid: 0:1, address_space: &quot;0:1&quot; @ 0p7DF2000, { rip: 0v1000B487, rsp: 0v7F7FFFFFDB08 } }; process_count = 3
15:27:01.423 0 I syscall = &quot;exofork&quot;; process = 2:1; child = 0:1
15:27:01.427 0 I syscall::exofork() done; child = Ok(0:1); pid = 2:1
15:27:01.599 0 I syscall::set_state(); child = 0:1; result = Ok(()); pid = 2:1
15:27:01.711 0 I page allocator init; free_page_count = 33688649728; block = [0v18000000000, 0v7F0000000000), size 125.500 TiB
15:27:01.721 0 I duplicate; address_space = &quot;process&quot; @ 0p7C1C000
15:27:01.725 0 I switch to; address_space = &quot;process&quot; @ 0p7C1C000
15:27:01.733 0 I switch to; address_space = &quot;2:1&quot; @ 0p7CC4000
15:27:01.739 0 I allocate; slot = Process { pid: 3:0, address_space: &quot;3:0&quot; @ 0p7C1C000, { rip: 0v1000B487, rsp: 0v7F7FFFFFDB08 } }; process_count = 4
15:27:01.749 0 I syscall = &quot;exofork&quot;; process = 2:1; child = 3:0
15:27:01.753 0 I syscall::exofork() done; child = Ok(3:0); pid = 2:1
15:27:01.925 0 I syscall::set_state(); child = 3:0; result = Ok(()); pid = 2:1
15:27:01.931 0 I free; slot = Process { pid: 2:1, address_space: &quot;2:1&quot; @ 0p7CC4000, { rip: 0v1002759D, rsp: 0v7F7FFFFFD968 } }; process_count = 3
15:27:01.941 0 I switch to; address_space = &quot;base&quot; @ 0p1000
15:27:01.945 0 I drop the current address space; address_space = &quot;2:1&quot; @ 0p7CC4000; switch_to = &quot;base&quot; @ 0p1000
15:27:02.017 0 I syscall = &quot;exit&quot;; pid = 2:1; code = 0; reason = Some(OK)
15:27:02.023 0 D leaving the user mode; pid = 2:1
15:27:02.027 0 I dequeue; pid = Some(1:1)
15:27:02.031 0 I switch to; address_space = &quot;1:1&quot; @ 0p7D4C000
15:27:02.037 0 D entering the user mode; pid = 1:1; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7EFFFFFFB000, { mode: user, cs:rip: 0x0023:0v1000B487, ss:rsp: 0x001B:0v7F7FFFFFDB08, rflags: IF } }
15:27:02.063 0 D leaving the user mode; pid = 1:1
15:27:02.067 0 I the process was preempted; pid = 1:1; user_context = { mode: user, cs:rip: 0x0023:0v1001D938, ss:rsp: 0x001B:0v7F7FFFFFD1A8, rflags: IF SF PF CF }
15:27:02.081 0 I returned
15:27:02.085 0 I dequeue; pid = Some(0:1)
15:27:02.089 0 I switch to; address_space = &quot;0:1&quot; @ 0p7DF2000
15:27:02.093 0 D entering the user mode; pid = 0:1; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7EFFFFFFB000, { mode: user, cs:rip: 0x0023:0v1000B487, ss:rsp: 0x001B:0v7F7FFFFFDB08, rflags: IF ZF PF } }
15:27:02.109 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 0:1
15:27:02.121 0 I just created; child = &lt;current&gt;; pid = 0:1; pid = 0:1
15:27:02.123 0 I name = &quot;eager_fork *1&quot;; pedigree = [2:1, 0:1]; len = 2; capacity = 3; pid = 0:1
15:27:02.241 0 I page allocator init; free_page_count = 33554432000; block = [0v18000000000, 0v7E8000000000), size 125.000 TiB
15:27:02.251 0 I duplicate; address_space = &quot;process&quot; @ 0p7CC4000
15:27:02.255 0 I switch to; address_space = &quot;process&quot; @ 0p7CC4000
15:27:02.263 0 I switch to; address_space = &quot;0:1&quot; @ 0p7DF2000
15:27:02.267 0 I allocate; slot = Process { pid: 2:2, address_space: &quot;2:2&quot; @ 0p7CC4000, { rip: 0v1000B487, rsp: 0v7F7FFFFFD648 } }; process_count = 4
15:27:02.277 0 I syscall = &quot;exofork&quot;; process = 0:1; child = 2:2
15:27:02.283 0 I syscall::exofork() done; child = Ok(2:2); pid = 0:1
15:27:02.363 0 D leaving the user mode; pid = 0:1
15:27:02.367 0 I the process was preempted; pid = 0:1; user_context = { mode: user, cs:rip: 0x0023:0v1002C383, ss:rsp: 0x001B:0v7F7FFFFFB9E8, rflags: IF ZF PF }
15:27:02.377 0 I returned
15:27:02.381 0 I dequeue; pid = Some(3:0)
15:27:02.387 0 I switch to; address_space = &quot;3:0&quot; @ 0p7C1C000
15:27:02.391 0 D entering the user mode; pid = 3:0; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7EFFFFFFB000, { mode: user, cs:rip: 0x0023:0v1000B487, ss:rsp: 0x001B:0v7F7FFFFFDB08, rflags: IF ZF PF } }
15:27:02.407 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 3:0
15:27:02.417 0 I just created; child = &lt;current&gt;; pid = 3:0; pid = 3:0
15:27:02.421 0 I name = &quot;eager_fork *2&quot;; pedigree = [2:1, 3:0]; len = 2; capacity = 3; pid = 3:0
15:27:02.549 0 I page allocator init; free_page_count = 33554432000; block = [0v18000000000, 0v7E8000000000), size 125.000 TiB
15:27:02.559 0 I duplicate; address_space = &quot;process&quot; @ 0p7D0C000
15:27:02.563 0 I switch to; address_space = &quot;process&quot; @ 0p7D0C000
15:27:02.571 0 I switch to; address_space = &quot;3:0&quot; @ 0p7C1C000
15:27:02.577 0 I allocate; slot = Process { pid: 4:0, address_space: &quot;4:0&quot; @ 0p7D0C000, { rip: 0v1000B487, rsp: 0v7F7FFFFFD648 } }; process_count = 5
15:27:02.585 0 I syscall = &quot;exofork&quot;; process = 3:0; child = 4:0
15:27:02.591 0 I syscall::exofork() done; child = Ok(4:0); pid = 3:0
15:27:02.663 0 D leaving the user mode; pid = 3:0
15:27:02.669 0 I the process was preempted; pid = 3:0; user_context = { mode: user, cs:rip: 0x0023:0v1002C383, ss:rsp: 0x001B:0v7F7FFFFFB9E8, rflags: IF ZF PF }
15:27:02.679 0 I returned
15:27:02.683 0 I dequeue; pid = Some(1:1)
15:27:02.687 0 I switch to; address_space = &quot;1:1&quot; @ 0p7D4C000
15:27:02.693 0 D entering the user mode; pid = 1:1; registers = { rax: 0xD1, rdi: 0x7F7FFFFFD2A8, rsi: 0x7F7FFFFFD6E0, { mode: user, cs:rip: 0x0023:0v1001D938, ss:rsp: 0x001B:0v7F7FFFFFD1A8, rflags: IF SF PF CF } }
15:27:02.051 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 1:1
15:27:02.063 0 I just created; child = &lt;current&gt;; pid = 1:1; pid = 1:1
15:27:02.711 0 I name = &quot;eager_fork *0&quot;; pedigree = [2:1, 1:1]; len = 2; capacity = 3; pid = 1:1
15:27:02.841 0 I page allocator init; free_page_count = 33554432000; block = [0v18000000000, 0v7E8000000000), size 125.000 TiB
15:27:02.851 0 I duplicate; address_space = &quot;process&quot; @ 0p7CFD000
15:27:02.855 0 I switch to; address_space = &quot;process&quot; @ 0p7CFD000
15:27:02.861 0 I switch to; address_space = &quot;1:1&quot; @ 0p7D4C000
15:27:02.867 0 I allocate; slot = Process { pid: 5:0, address_space: &quot;5:0&quot; @ 0p7CFD000, { rip: 0v1000B487, rsp: 0v7F7FFFFFD648 } }; process_count = 6
15:27:02.877 0 I syscall = &quot;exofork&quot;; process = 1:1; child = 5:0
15:27:02.883 0 I syscall::exofork() done; child = Ok(5:0); pid = 1:1
15:27:03.061 0 I syscall::set_state(); child = 5:0; result = Ok(()); pid = 1:1
15:27:03.163 0 I page allocator init; free_page_count = 33554432000; block = [0v18000000000, 0v7E8000000000), size 125.000 TiB
15:27:03.171 0 I duplicate; address_space = &quot;process&quot; @ 0p7AE8000
15:27:03.177 0 I switch to; address_space = &quot;process&quot; @ 0p7AE8000
15:27:03.183 0 I switch to; address_space = &quot;1:1&quot; @ 0p7D4C000
15:27:03.189 0 I allocate; slot = Process { pid: 6:0, address_space: &quot;6:0&quot; @ 0p7AE8000, { rip: 0v1000B487, rsp: 0v7F7FFFFFD648 } }; process_count = 7
15:27:03.199 0 I syscall = &quot;exofork&quot;; process = 1:1; child = 6:0
15:27:03.203 0 I syscall::exofork() done; child = Ok(6:0); pid = 1:1
15:27:03.375 0 I syscall::set_state(); child = 6:0; result = Ok(()); pid = 1:1
15:27:03.479 0 I page allocator init; free_page_count = 33554432000; block = [0v18000000000, 0v7E8000000000), size 125.000 TiB
15:27:03.489 0 I duplicate; address_space = &quot;process&quot; @ 0p7A3F000
15:27:03.493 0 I switch to; address_space = &quot;process&quot; @ 0p7A3F000
15:27:03.499 0 I switch to; address_space = &quot;1:1&quot; @ 0p7D4C000
15:27:03.505 0 I allocate; slot = Process { pid: 7:0, address_space: &quot;7:0&quot; @ 0p7A3F000, { rip: 0v1000B487, rsp: 0v7F7FFFFFD648 } }; process_count = 8
15:27:03.515 0 I syscall = &quot;exofork&quot;; process = 1:1; child = 7:0
15:27:03.519 0 I syscall::exofork() done; child = Ok(7:0); pid = 1:1
15:27:03.693 0 I syscall::set_state(); child = 7:0; result = Ok(()); pid = 1:1
15:27:03.701 0 I free; slot = Process { pid: 1:1, address_space: &quot;1:1&quot; @ 0p7D4C000, { rip: 0v1001D938, rsp: 0v7F7FFFFFD1A8 } }; process_count = 7
15:27:03.709 0 I switch to; address_space = &quot;base&quot; @ 0p1000
15:27:03.715 0 I drop the current address space; address_space = &quot;1:1&quot; @ 0p7D4C000; switch_to = &quot;base&quot; @ 0p1000
15:27:03.791 0 I syscall = &quot;exit&quot;; pid = 1:1; code = 0; reason = Some(OK)
15:27:03.797 0 D leaving the user mode; pid = 1:1
15:27:03.801 0 I dequeue; pid = Some(0:1)
15:27:03.805 0 I switch to; address_space = &quot;0:1&quot; @ 0p7DF2000
15:27:03.809 0 D entering the user mode; pid = 0:1; registers = { rax: 0xC00, rdi: 0x7EFFFFFA2000, rsi: 0x1002C000, { mode: user, cs:rip: 0x0023:0v1002C383, ss:rsp: 0x001B:0v7F7FFFFFB9E8, rflags: IF ZF PF } }
15:27:03.953 0 I syscall::set_state(); child = 2:2; result = Ok(()); pid = 0:1
15:27:04.063 0 I page allocator init; free_page_count = 33554432000; block = [0v18000000000, 0v7E8000000000), size 125.000 TiB
15:27:04.071 0 I duplicate; address_space = &quot;process&quot; @ 0p7DB3000
15:27:04.077 0 I switch to; address_space = &quot;process&quot; @ 0p7DB3000
15:27:04.083 0 I switch to; address_space = &quot;0:1&quot; @ 0p7DF2000
15:27:04.089 0 I allocate; slot = Process { pid: 1:2, address_space: &quot;1:2&quot; @ 0p7DB3000, { rip: 0v1000B487, rsp: 0v7F7FFFFFD648 } }; process_count = 8
15:27:04.099 0 I syscall = &quot;exofork&quot;; process = 0:1; child = 1:2
15:27:04.103 0 I syscall::exofork() done; child = Ok(1:2); pid = 0:1
15:27:04.163 0 D leaving the user mode; pid = 0:1
15:27:04.167 0 I the process was preempted; pid = 0:1; user_context = { mode: user, cs:rip: 0x0023:0v1002C383, ss:rsp: 0x001B:0v7F7FFFFFB9E8, rflags: IF ZF PF }
15:27:04.177 0 I returned
15:27:04.181 0 I dequeue; pid = Some(3:0)
15:27:04.187 0 I switch to; address_space = &quot;3:0&quot; @ 0p7C1C000
15:27:04.191 0 D entering the user mode; pid = 3:0; registers = { rax: 0x500, rdi: 0x7EFFFFFD6000, rsi: 0x10012000, { mode: user, cs:rip: 0x0023:0v1002C383, ss:rsp: 0x001B:0v7F7FFFFFB9E8, rflags: IF ZF PF } }
15:27:04.389 0 I syscall::set_state(); child = 4:0; result = Ok(()); pid = 3:0
15:27:04.493 0 I page allocator init; free_page_count = 33554432000; block = [0v18000000000, 0v7E8000000000), size 125.000 TiB
15:27:04.503 0 I duplicate; address_space = &quot;process&quot; @ 0p7940000
15:27:04.507 0 I switch to; address_space = &quot;process&quot; @ 0p7940000
15:27:04.515 0 I switch to; address_space = &quot;3:0&quot; @ 0p7C1C000
15:27:04.519 0 I allocate; slot = Process { pid: 8:0, address_space: &quot;8:0&quot; @ 0p7940000, { rip: 0v1000B487, rsp: 0v7F7FFFFFD648 } }; process_count = 9
15:27:04.529 0 I syscall = &quot;exofork&quot;; process = 3:0; child = 8:0
15:27:04.535 0 I syscall::exofork() done; child = Ok(8:0); pid = 3:0
15:27:04.709 0 I syscall::set_state(); child = 8:0; result = Ok(()); pid = 3:0
15:27:04.815 0 I page allocator init; free_page_count = 33554432000; block = [0v18000000000, 0v7E8000000000), size 125.000 TiB
15:27:04.823 0 I duplicate; address_space = &quot;process&quot; @ 0p7896000
15:27:04.829 0 I switch to; address_space = &quot;process&quot; @ 0p7896000
15:27:04.835 0 I switch to; address_space = &quot;3:0&quot; @ 0p7C1C000
15:27:04.841 0 I allocate; slot = Process { pid: 9:0, address_space: &quot;9:0&quot; @ 0p7896000, { rip: 0v1000B487, rsp: 0v7F7FFFFFD648 } }; process_count = 10
15:27:04.851 0 I syscall = &quot;exofork&quot;; process = 3:0; child = 9:0
15:27:04.855 0 I syscall::exofork() done; child = Ok(9:0); pid = 3:0
15:27:04.863 0 D leaving the user mode; pid = 3:0
15:27:04.869 0 I the process was preempted; pid = 3:0; user_context = { mode: user, cs:rip: 0x0023:0v1001CD90, ss:rsp: 0x001B:0v7F7FFFFFB7E0, rflags: IF SF AF PF CF }
15:27:04.881 0 I returned
15:27:04.885 0 I dequeue; pid = Some(5:0)
15:27:04.889 0 I switch to; address_space = &quot;5:0&quot; @ 0p7CFD000
15:27:04.895 0 D entering the user mode; pid = 5:0; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v1000B487, ss:rsp: 0x001B:0v7F7FFFFFD648, rflags: IF SF PF CF } }
15:27:04.909 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 5:0
15:27:04.919 0 I just created; child = &lt;current&gt;; pid = 5:0; pid = 5:0
15:27:04.923 0 I name = &quot;eager_fork *00&quot;; pedigree = [2:1, 1:1, 5:0]; len = 3; capacity = 3; pid = 5:0
15:27:04.947 0 I free; slot = Process { pid: 5:0, address_space: &quot;5:0&quot; @ 0p7CFD000, { rip: 0v1000B487, rsp: 0v7F7FFFFFD648 } }; process_count = 9
15:27:04.955 0 I switch to; address_space = &quot;base&quot; @ 0p1000
15:27:04.961 0 I drop the current address space; address_space = &quot;5:0&quot; @ 0p7CFD000; switch_to = &quot;base&quot; @ 0p1000
15:27:05.039 0 I syscall = &quot;exit&quot;; pid = 5:0; code = 0; reason = Some(OK)
15:27:05.045 0 D leaving the user mode; pid = 5:0
15:27:05.049 0 I dequeue; pid = Some(6:0)
15:27:05.053 0 I switch to; address_space = &quot;6:0&quot; @ 0p7AE8000
15:27:05.059 0 D entering the user mode; pid = 6:0; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v1000B487, ss:rsp: 0x001B:0v7F7FFFFFD648, rflags: IF SF PF CF } }
15:27:05.073 0 D leaving the user mode; pid = 6:0
15:27:05.077 0 I the process was preempted; pid = 6:0; user_context = { mode: user, cs:rip: 0x0023:0v1000B487, ss:rsp: 0x001B:0v7F7FFFFFD648, rflags: IF SF PF CF }
15:27:05.091 0 I returned
15:27:05.095 0 I dequeue; pid = Some(7:0)
15:27:05.099 0 I switch to; address_space = &quot;7:0&quot; @ 0p7A3F000
15:27:05.103 0 D entering the user mode; pid = 7:0; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v1000B487, ss:rsp: 0x001B:0v7F7FFFFFD648, rflags: IF SF PF CF } }
15:27:05.119 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 7:0
15:27:05.129 0 I just created; child = &lt;current&gt;; pid = 7:0; pid = 7:0
15:27:05.133 0 I name = &quot;eager_fork *02&quot;; pedigree = [2:1, 1:1, 7:0]; len = 3; capacity = 3; pid = 7:0
15:27:05.155 0 I free; slot = Process { pid: 7:0, address_space: &quot;7:0&quot; @ 0p7A3F000, { rip: 0v1000B487, rsp: 0v7F7FFFFFD648 } }; process_count = 8
15:27:05.165 0 I switch to; address_space = &quot;base&quot; @ 0p1000
15:27:05.171 0 I drop the current address space; address_space = &quot;7:0&quot; @ 0p7A3F000; switch_to = &quot;base&quot; @ 0p1000
15:27:05.251 0 I syscall = &quot;exit&quot;; pid = 7:0; code = 0; reason = Some(OK)
15:27:05.255 0 D leaving the user mode; pid = 7:0
15:27:05.261 0 I dequeue; pid = Some(2:2)
15:27:05.265 0 I switch to; address_space = &quot;2:2&quot; @ 0p7CC4000
15:27:05.269 0 D entering the user mode; pid = 2:2; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v1000B487, ss:rsp: 0x001B:0v7F7FFFFFD648, rflags: IF ZF PF } }
15:27:05.285 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 2:2
15:27:05.297 0 I just created; child = &lt;current&gt;; pid = 2:2; pid = 2:2
15:27:05.301 0 I name = &quot;eager_fork *10&quot;; pedigree = [2:1, 0:1, 2:2]; len = 3; capacity = 3; pid = 2:2
15:27:05.323 0 I free; slot = Process { pid: 2:2, address_space: &quot;2:2&quot; @ 0p7CC4000, { rip: 0v1000B487, rsp: 0v7F7FFFFFD648 } }; process_count = 7
15:27:05.333 0 I switch to; address_space = &quot;base&quot; @ 0p1000
15:27:05.337 0 I drop the current address space; address_space = &quot;2:2&quot; @ 0p7CC4000; switch_to = &quot;base&quot; @ 0p1000
15:27:05.417 0 I syscall = &quot;exit&quot;; pid = 2:2; code = 0; reason = Some(OK)
15:27:05.423 0 D leaving the user mode; pid = 2:2
15:27:05.427 0 I dequeue; pid = Some(0:1)
15:27:05.431 0 I switch to; address_space = &quot;0:1&quot; @ 0p7DF2000
15:27:05.435 0 D entering the user mode; pid = 0:1; registers = { rax: 0xF00, rdi: 0x7EFFFFED4000, rsi: 0x1000F000, { mode: user, cs:rip: 0x0023:0v1002C383, ss:rsp: 0x001B:0v7F7FFFFFB9E8, rflags: IF ZF PF } }
15:27:05.625 0 I syscall::set_state(); child = 1:2; result = Ok(()); pid = 0:1
15:27:05.745 0 I page allocator init; free_page_count = 33554432000; block = [0v18000000000, 0v7E8000000000), size 125.000 TiB
15:27:05.755 0 I duplicate; address_space = &quot;process&quot; @ 0p7D0F000
15:27:05.759 0 I switch to; address_space = &quot;process&quot; @ 0p7D0F000
15:27:05.767 0 I switch to; address_space = &quot;0:1&quot; @ 0p7DF2000
15:27:05.773 0 I allocate; slot = Process { pid: 2:3, address_space: &quot;2:3&quot; @ 0p7D0F000, { rip: 0v1000B487, rsp: 0v7F7FFFFFD648 } }; process_count = 8
15:27:05.781 0 I syscall = &quot;exofork&quot;; process = 0:1; child = 2:3
15:27:05.787 0 I syscall::exofork() done; child = Ok(2:3); pid = 0:1
15:27:05.987 0 I syscall::set_state(); child = 2:3; result = Ok(()); pid = 0:1
15:27:05.993 0 I free; slot = Process { pid: 0:1, address_space: &quot;0:1&quot; @ 0p7DF2000, { rip: 0v1002C383, rsp: 0v7F7FFFFFB9E8 } }; process_count = 7
15:27:06.003 0 I switch to; address_space = &quot;base&quot; @ 0p1000
15:27:06.001 0 I drop the current address space; address_space = &quot;0:1&quot; @ 0p7DF2000; switch_to = &quot;base&quot; @ 0p1000
15:27:06.077 0 I syscall = &quot;exit&quot;; pid = 0:1; code = 0; reason = Some(OK)
15:27:06.081 0 D leaving the user mode; pid = 0:1
15:27:06.085 0 I dequeue; pid = Some(4:0)
15:27:06.091 0 I switch to; address_space = &quot;4:0&quot; @ 0p7D0C000
15:27:06.095 0 D entering the user mode; pid = 4:0; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v1000B487, ss:rsp: 0x001B:0v7F7FFFFFD648, rflags: IF ZF PF } }
15:27:06.111 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 4:0
15:27:06.121 0 I just created; child = &lt;current&gt;; pid = 4:0; pid = 4:0
15:27:06.125 0 I name = &quot;eager_fork *20&quot;; pedigree = [2:1, 3:0, 4:0]; len = 3; capacity = 3; pid = 4:0
15:27:06.149 0 I free; slot = Process { pid: 4:0, address_space: &quot;4:0&quot; @ 0p7D0C000, { rip: 0v1000B487, rsp: 0v7F7FFFFFD648 } }; process_count = 6
15:27:06.157 0 I switch to; address_space = &quot;base&quot; @ 0p1000
15:27:06.163 0 I drop the current address space; address_space = &quot;4:0&quot; @ 0p7D0C000; switch_to = &quot;base&quot; @ 0p1000
15:27:06.243 0 I syscall = &quot;exit&quot;; pid = 4:0; code = 0; reason = Some(OK)
15:27:06.249 0 D leaving the user mode; pid = 4:0
15:27:06.253 0 I dequeue; pid = Some(8:0)
15:27:06.257 0 I switch to; address_space = &quot;8:0&quot; @ 0p7940000
15:27:06.261 0 D entering the user mode; pid = 8:0; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v1000B487, ss:rsp: 0x001B:0v7F7FFFFFD648, rflags: IF ZF PF } }
15:27:06.279 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 8:0
15:27:06.287 0 I just created; child = &lt;current&gt;; pid = 8:0; pid = 8:0
15:27:06.291 0 I name = &quot;eager_fork *21&quot;; pedigree = [2:1, 3:0, 8:0]; len = 3; capacity = 3; pid = 8:0
15:27:06.313 0 I free; slot = Process { pid: 8:0, address_space: &quot;8:0&quot; @ 0p7940000, { rip: 0v1000B487, rsp: 0v7F7FFFFFD648 } }; process_count = 5
15:27:06.323 0 I switch to; address_space = &quot;base&quot; @ 0p1000
15:27:06.327 0 I drop the current address space; address_space = &quot;8:0&quot; @ 0p7940000; switch_to = &quot;base&quot; @ 0p1000
15:27:06.407 0 I syscall = &quot;exit&quot;; pid = 8:0; code = 0; reason = Some(OK)
15:27:06.413 0 D leaving the user mode; pid = 8:0
15:27:06.417 0 I dequeue; pid = Some(3:0)
15:27:06.421 0 I switch to; address_space = &quot;3:0&quot; @ 0p7C1C000
15:27:06.427 0 D entering the user mode; pid = 3:0; registers = { rax: 0x7EFFFFFFB, rdi: 0x7EFFFFFFB000, rsi: 0x7EFFFFFFB000, { mode: user, cs:rip: 0x0023:0v1001CD90, ss:rsp: 0x001B:0v7F7FFFFFB7E0, rflags: IF SF AF PF CF } }
15:27:06.555 0 D leaving the user mode; pid = 3:0
15:27:06.559 0 I the process was preempted; pid = 3:0; user_context = { mode: user, cs:rip: 0x0023:0v1002C383, ss:rsp: 0x001B:0v7F7FFFFFB9E8, rflags: IF ZF PF }
15:27:06.569 0 I returned
15:27:06.573 0 I dequeue; pid = Some(6:0)
15:27:06.579 0 I switch to; address_space = &quot;6:0&quot; @ 0p7AE8000
15:27:06.583 0 D entering the user mode; pid = 6:0; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v1000B487, ss:rsp: 0x001B:0v7F7FFFFFD648, rflags: IF SF PF CF } }
15:27:06.599 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 6:0
15:27:06.609 0 I just created; child = &lt;current&gt;; pid = 6:0; pid = 6:0
15:27:06.611 0 I name = &quot;eager_fork *01&quot;; pedigree = [2:1, 1:1, 6:0]; len = 3; capacity = 3; pid = 6:0
15:27:06.635 0 I free; slot = Process { pid: 6:0, address_space: &quot;6:0&quot; @ 0p7AE8000, { rip: 0v1000B487, rsp: 0v7F7FFFFFD648 } }; process_count = 4
15:27:06.643 0 I switch to; address_space = &quot;base&quot; @ 0p1000
15:27:06.649 0 I drop the current address space; address_space = &quot;6:0&quot; @ 0p7AE8000; switch_to = &quot;base&quot; @ 0p1000
15:27:06.729 0 I syscall = &quot;exit&quot;; pid = 6:0; code = 0; reason = Some(OK)
15:27:06.733 0 D leaving the user mode; pid = 6:0
15:27:06.737 0 I dequeue; pid = Some(1:2)
15:27:06.743 0 I switch to; address_space = &quot;1:2&quot; @ 0p7DB3000
15:27:06.747 0 D entering the user mode; pid = 1:2; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v1000B487, ss:rsp: 0x001B:0v7F7FFFFFD648, rflags: IF ZF PF } }
15:27:06.763 0 D leaving the user mode; pid = 1:2
15:27:06.771 0 I the process was preempted; pid = 1:2; user_context = { mode: user, cs:rip: 0x0023:0v1000B487, ss:rsp: 0x001B:0v7F7FFFFFD648, rflags: IF ZF PF }
15:27:06.783 0 I returned
15:27:06.787 0 I dequeue; pid = Some(2:3)
15:27:06.791 0 I switch to; address_space = &quot;2:3&quot; @ 0p7D0F000
15:27:06.797 0 D entering the user mode; pid = 2:3; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v1000B487, ss:rsp: 0x001B:0v7F7FFFFFD648, rflags: IF ZF PF } }
15:27:06.813 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 2:3
15:27:06.823 0 I just created; child = &lt;current&gt;; pid = 2:3; pid = 2:3
15:27:06.827 0 I name = &quot;eager_fork *12&quot;; pedigree = [2:1, 0:1, 2:3]; len = 3; capacity = 3; pid = 2:3
15:27:06.849 0 I free; slot = Process { pid: 2:3, address_space: &quot;2:3&quot; @ 0p7D0F000, { rip: 0v1000B487, rsp: 0v7F7FFFFFD648 } }; process_count = 3
15:27:06.859 0 I switch to; address_space = &quot;base&quot; @ 0p1000
15:27:06.865 0 I drop the current address space; address_space = &quot;2:3&quot; @ 0p7D0F000; switch_to = &quot;base&quot; @ 0p1000
15:27:06.945 0 I syscall = &quot;exit&quot;; pid = 2:3; code = 0; reason = Some(OK)
15:27:06.949 0 D leaving the user mode; pid = 2:3
15:27:06.955 0 I dequeue; pid = Some(3:0)
15:27:06.959 0 I switch to; address_space = &quot;3:0&quot; @ 0p7C1C000
15:27:06.963 0 D entering the user mode; pid = 3:0; registers = { rax: 0x100, rdi: 0x7EFFFFD40000, rsi: 0x10055000, { mode: user, cs:rip: 0x0023:0v1002C383, ss:rsp: 0x001B:0v7F7FFFFFB9E8, rflags: IF ZF PF } }
15:27:07.049 0 I syscall::set_state(); child = 9:0; result = Ok(()); pid = 3:0
15:27:07.057 0 I free; slot = Process { pid: 3:0, address_space: &quot;3:0&quot; @ 0p7C1C000, { rip: 0v1002C383, rsp: 0v7F7FFFFFB9E8 } }; process_count = 2
15:27:07.067 0 I switch to; address_space = &quot;base&quot; @ 0p1000
15:27:07.071 0 I drop the current address space; address_space = &quot;3:0&quot; @ 0p7C1C000; switch_to = &quot;base&quot; @ 0p1000
15:27:07.149 0 I syscall = &quot;exit&quot;; pid = 3:0; code = 0; reason = Some(OK)
15:27:07.153 0 D leaving the user mode; pid = 3:0
15:27:07.159 0 I dequeue; pid = Some(1:2)
15:27:07.163 0 I switch to; address_space = &quot;1:2&quot; @ 0p7DB3000
15:27:07.167 0 D entering the user mode; pid = 1:2; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v1000B487, ss:rsp: 0x001B:0v7F7FFFFFD648, rflags: IF ZF PF } }
15:27:07.183 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 1:2
15:27:07.193 0 I just created; child = &lt;current&gt;; pid = 1:2; pid = 1:2
15:27:07.195 0 I name = &quot;eager_fork *11&quot;; pedigree = [2:1, 0:1, 1:2]; len = 3; capacity = 3; pid = 1:2
15:27:07.219 0 I free; slot = Process { pid: 1:2, address_space: &quot;1:2&quot; @ 0p7DB3000, { rip: 0v1000B487, rsp: 0v7F7FFFFFD648 } }; process_count = 1
15:27:07.229 0 I switch to; address_space = &quot;base&quot; @ 0p1000
15:27:07.235 0 I drop the current address space; address_space = &quot;1:2&quot; @ 0p7DB3000; switch_to = &quot;base&quot; @ 0p1000
15:27:07.313 0 I syscall = &quot;exit&quot;; pid = 1:2; code = 0; reason = Some(OK)
15:27:07.319 0 D leaving the user mode; pid = 1:2
15:27:07.323 0 I dequeue; pid = Some(9:0)
15:27:07.327 0 I switch to; address_space = &quot;9:0&quot; @ 0p7896000
15:27:07.333 0 D entering the user mode; pid = 9:0; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v1000B487, ss:rsp: 0x001B:0v7F7FFFFFD648, rflags: IF ZF PF } }
15:27:07.363 0 D leaving the user mode; pid = 9:0
15:27:07.367 0 I the process was preempted; pid = 9:0; user_context = { mode: user, cs:rip: 0x0023:0v1004AB7C, ss:rsp: 0x001B:0v7F7FFFFFD3D8, rflags: IF }
15:27:07.377 0 I returned
15:27:07.381 0 I dequeue; pid = Some(9:0)
15:27:07.385 0 I switch to; address_space = &quot;9:0&quot; @ 0p7896000
15:27:07.389 0 D entering the user mode; pid = 9:0; registers = { rax: 0x7F7FFFFFD618, rdi: 0x7F7FFFFFD760, rsi: 0x7F7FFFFFD500, { mode: user, cs:rip: 0x0023:0v1004AB7C, ss:rsp: 0x001B:0v7F7FFFFFD3D8, rflags: IF } }
15:27:07.349 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 9:0
15:27:07.359 0 I just created; child = &lt;current&gt;; pid = 9:0; pid = 9:0
15:27:07.361 0 I name = &quot;eager_fork *22&quot;; pedigree = [2:1, 3:0, 9:0]; len = 3; capacity = 3; pid = 9:0
15:27:07.425 0 I free; slot = Process { pid: 9:0, address_space: &quot;9:0&quot; @ 0p7896000, { rip: 0v1004AB7C, rsp: 0v7F7FFFFFD3D8 } }; process_count = 0
15:27:07.435 0 I switch to; address_space = &quot;base&quot; @ 0p1000
15:27:07.439 0 I drop the current address space; address_space = &quot;9:0&quot; @ 0p7896000; switch_to = &quot;base&quot; @ 0p1000
15:27:07.521 0 I syscall = &quot;exit&quot;; pid = 9:0; code = 0; reason = Some(OK)
15:27:07.527 0 D leaving the user mode; pid = 9:0
15:27:07.531 0 I dequeue; pid = None
15:27:07.541 0 D parent = 0:1; process = 1:2
15:27:07.549 0 D parent = 0:1; process = 2:2
15:27:07.553 0 D parent = 0:1; process = 2:3
15:27:07.557 0 D parent = 1:1; process = 5:0
15:27:07.563 0 D parent = 1:1; process = 6:0
15:27:07.567 0 D parent = 1:1; process = 7:0
15:27:07.573 0 D parent = 2:1; process = 0:1
15:27:07.577 0 D parent = 2:1; process = 1:1
15:27:07.581 0 D parent = 2:1; process = 3:0
15:27:07.587 0 D parent = 3:0; process = 4:0
15:27:07.591 0 D parent = 3:0; process = 8:0
15:27:07.595 0 D parent = 3:0; process = 9:0
15:27:07.601 0 D graphviz = digraph process_tree { node [ style = filled; fillcolor = &quot;#CCCCCC&quot;]; &quot;0:1&quot; -&gt; &quot;1:2&quot;; &quot;0:1&quot; -&gt; &quot;2:2&quot;; &quot;0:1&quot; -&gt; &quot;2:3&quot;; &quot;1:1&quot; -&gt; &quot;5:0&quot;; &quot;1:1&quot; -&gt; &quot;6:0&quot;; &quot;1:1&quot; -&gt; &quot;7:0&quot;; &quot;2:1&quot; -&gt; &quot;0:1&quot;; &quot;2:1&quot; -&gt; &quot;1:1&quot;; &quot;2:1&quot; -&gt; &quot;3:0&quot;; &quot;3:0&quot; -&gt; &quot;4:0&quot;; &quot;3:0&quot; -&gt; &quot;8:0&quot;; &quot;3:0&quot; -&gt; &quot;9:0&quot;; }
5_um_3_eager_fork::eager_fork---------------------- [passed]
15:27:07.623 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<p>В этом запуске видно, что корневым явился процесс с идентификатором <code>2:1</code>:</p>
<pre><code class="language-console">$ grep pedigree log
15:27:00.873 0 I name = &quot;eager_fork *&quot;; pedigree = [2:1]; len = 1; capacity = 3; pid = 2:1
15:27:02.123 0 I name = &quot;eager_fork *1&quot;; pedigree = [2:1, 0:1]; len = 2; capacity = 3; pid = 0:1
15:27:02.421 0 I name = &quot;eager_fork *2&quot;; pedigree = [2:1, 3:0]; len = 2; capacity = 3; pid = 3:0
15:27:02.711 0 I name = &quot;eager_fork *0&quot;; pedigree = [2:1, 1:1]; len = 2; capacity = 3; pid = 1:1
15:27:04.923 0 I name = &quot;eager_fork *00&quot;; pedigree = [2:1, 1:1, 5:0]; len = 3; capacity = 3; pid = 5:0
15:27:05.133 0 I name = &quot;eager_fork *02&quot;; pedigree = [2:1, 1:1, 7:0]; len = 3; capacity = 3; pid = 7:0
15:27:05.301 0 I name = &quot;eager_fork *10&quot;; pedigree = [2:1, 0:1, 2:2]; len = 3; capacity = 3; pid = 2:2
15:27:06.125 0 I name = &quot;eager_fork *20&quot;; pedigree = [2:1, 3:0, 4:0]; len = 3; capacity = 3; pid = 4:0
15:27:06.291 0 I name = &quot;eager_fork *21&quot;; pedigree = [2:1, 3:0, 8:0]; len = 3; capacity = 3; pid = 8:0
15:27:06.611 0 I name = &quot;eager_fork *01&quot;; pedigree = [2:1, 1:1, 6:0]; len = 3; capacity = 3; pid = 6:0
15:27:06.827 0 I name = &quot;eager_fork *12&quot;; pedigree = [2:1, 0:1, 2:3]; len = 3; capacity = 3; pid = 2:3
15:27:07.195 0 I name = &quot;eager_fork *11&quot;; pedigree = [2:1, 0:1, 1:2]; len = 3; capacity = 3; pid = 1:2
15:27:07.361 0 I name = &quot;eager_fork *22&quot;; pedigree = [2:1, 3:0, 9:0]; len = 3; capacity = 3; pid = 9:0
</code></pre>
<p>Он запустил трёх потомков — <code>1:1</code>, <code>0:1</code> и <code>3:0</code>.
А, например, родословная процесса <code>6:0</code> — <code>pedigree = [2:1, 1:1, 6:0]</code>.</p>
<p>Получилось такое дерево процессов:
<img src="5-um-3-eager-fork.svg" alt="" /></p>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-22"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-22">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/memory/mapping.rs  |   16 ++++++++++++++--
 kernel/src/process/syscall.rs |   39 +++++++++++++++++++++++++++++++++++----
 user/eager_fork/src/main.rs   |   54 ++++++++++++++++++++++++++++++++++++++++++++++++++----
 user/lib/src/memory/mod.rs    |   34 ++++++++++++++++++++++++++++------
 4 files changed, 127 insertions(+), 16 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Обработка-исключений-в-режиме-пользователя"><a class="header" href="#Обработка-исключений-в-режиме-пользователя">Обработка исключений в режиме пользователя</a></h2>
<h3 id="Пользовательская-часть-системного-вызова-set_trap_handler"><a class="header" href="#Пользовательская-часть-системного-вызова-set_trap_handler">Пользовательская часть системного вызова <code>set_trap_handler</code></a></h3>
<p>Посмотрите на <a href="../../doc/lib/syscall/fn.set_trap_handler.html">функцию</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lib::syscall::set_trap_handler(
    dst_pid: Pid,
    trap_handler: fn(&amp;TrapInfo),
    trap_stack: Block&lt;Page&gt;,
) -&gt; Result&lt;()&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/user/lib/src/syscall.rs"><code>user/lib/src/syscall.rs</code></a>.</p>
<p>Она делает не совсем то, чего можно было бы ожидать.
А именно, она не передаёт адрес функции <code>trap_handler</code> в системный вызов.
Вместо этого она устанавливает в качестве обработчика прерываний функцию
<a href="../../doc/lib/syscall/fn.trap_trampoline.html"><code>lib::syscall::trap_trampoline()</code></a>,
а <code>trap_handler</code> просто сохраняет в статическую переменную
<a href="../../doc/lib/syscall/static.TRAP_HANDLER.html"><code>static TRAP_HANDLER: AtomicPtr&lt;()&gt;</code></a>.</p>
<p>Это позволяет функции <code>trap_handler</code> не заниматься той технической машинерией
по сохранению и восстановлению контекста, которую мы сейчас реализуем в
<a href="../../doc/lib/syscall/fn.trap_trampoline.html"><code>lib::syscall::trap_trampoline()</code></a>.</p>
<h3 id="Трамплин-обработчика-прерываний"><a class="header" href="#Трамплин-обработчика-прерываний">Трамплин обработчика прерываний</a></h3>
<p>Реализуйте <a href="../../doc/lib/syscall/fn.trap_trampoline.html">функцию</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; fn trap_trampoline() -&gt; !
<span class="boring">}
</span></code></pre></pre>
<p>в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/user/lib/src/syscall.rs"><code>user/lib/src/syscall.rs</code></a>.</p>
<p>Она будет получать управление, если в коде пользователя возникло прерывание, например Page Fault.
Прерывание может возникнуть в неожиданный момент, поэтому нужно сохранить содержимое всех регистров в стеке.
Стек, на котором эта функция будет запущена, — специальный.
Он может отличаться от стека в момент возникновения исключения.
Причём на момент вызова
<a href="../../doc/lib/syscall/fn.trap_trampoline.html"><code>lib::syscall::trap_trampoline()</code></a>
в стеке лежит структура
<a href="../../doc/ku/process/trap_info/struct.TrapInfo.html"><code>ku::process::trap_info::TrapInfo</code></a>
с информацией о возникшем прерывании.
Эту инофрмацию записывает в стек процесса ядро.</p>
<p>Это похоже на метод
<a href="../../doc/kernel/process/registers/struct.Registers.html#method.switch_to"><code>Registers::switch_to()</code></a>
<a href="../../lab/book/3-process-3-user-mode.html#%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-7--%D0%BF%D0%B5%D1%80%D0%B5%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0-%D0%B2-%D1%80%D0%B5%D0%B6%D0%B8%D0%BC-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F-%D0%B8-%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%82-%D0%B8%D0%B7-%D0%BD%D0%B5%D0%B3%D0%BE">который вы реализовали</a>
в одной из прошлых лабораторок.</p>
<p><strong>Важно</strong> также сохранить в стек текущее состояние регистра флагов <code>RFLAGS</code>.</p>
<p>После сохранения регистров нужно вызвать <a href="../../doc/lib/syscall/fn.trap_handler_invoker.html">функцию</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; fn lib::syscall::trap_handler_invoker(
    info: &amp;mut TrapInfo, // rdi
)
<span class="boring">}
</span></code></pre></pre>
<p>Передав ей в регистре <code>RDI</code> адрес
<a href="../../doc/ku/process/trap_info/struct.TrapInfo.html"><code>ku::process::trap_info::TrapInfo</code></a>,
на который указывал регистр <code>RSP</code> в момент вызова
<a href="../../doc/lib/syscall/fn.trap_trampoline.html"><code>lib::syscall::trap_trampoline()</code></a>.
Мы только что положили в стек регистры, и <code>RSP</code> сдвинулся.
Поэтому для получения адреса
<a href="../../doc/ku/process/trap_info/struct.TrapInfo.html"><code>ku::process::trap_info::TrapInfo</code></a>,
нужно прибавить к <code>RSP</code> объём сохранённых регистров.
После вызова
<a href="../../doc/lib/syscall/fn.trap_handler_invoker.html"><code>lib::syscall::trap_handler_invoker()</code></a>
нужно восстановить регистры из стека.</p>
<p>Далее нужно переключить стек — <code>RSP</code> — на состояние, в котором он был в момент возникновения прерывания.
И вернуть <code>RIP</code> в точку, в которой прерывание возникло.
Посмотрите, что делает
<a href="../../doc/lib/syscall/fn.trap_handler_invoker.html"><code>lib::syscall::trap_handler_invoker()</code></a>:</p>
<ul>
<li>Вызывает функцию, сохранённую в переменной <a href="../../doc/lib/syscall/static.TRAP_HANDLER.html"><code>static TRAP_HANDLER: AtomicPtr&lt;()&gt;</code></a>.</li>
<li>Выполняет <a href="../../doc/ku/process/trap_info/struct.TrapInfo.html#method.prepare_for_ret"><code>TrapInfo::prepare_for_ret()</code></a>.</li>
</ul>
<p>А
<a href="../../doc/ku/process/trap_info/struct.TrapInfo.html#method.prepare_for_ret"><code>TrapInfo::prepare_for_ret()</code></a>
кладёт в стек времени возникновения прерывания регистр <code>RIP</code> — адрес кода, который исполнялся в этот момент.
Значит, если мы установим <code>RSP</code> на место в памяти, где сохранён <code>RIP</code> и сделаем <code>ret</code>, то инструкция <code>ret</code> одновременно</p>
<ul>
<li>Вернёт управление в то место, которое исполнялось в момент прерывания.</li>
<li>Вернёт стек — регистр <code>RSP</code> — в состояние на момент возникновения прерывания.</li>
</ul>
<p>Что нам и нужно. Таким образом,
<a href="../../doc/lib/syscall/fn.trap_trampoline.html"><code>lib::syscall::trap_trampoline()</code></a>
должна переключить <code>RSP</code> на этот адрес и выполнить инструкцию
<a href="https://www.felixcloutier.com/x86/ret"><code>ret</code></a>.
Лежит нужный нам <code>RSP</code> в поле
<code>TrapInfo::context</code>(../../doc/ku/process/trap_info/struct.TrapInfo.html#structfield.context)
структуры</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, Debug)]
#[repr(C)]
pub struct TrapInfo {
    number: usize,
    info: Info,
    context: MiniContext,

    /// `TrapInfo` can be pushed onto the same stack the `context` is pointing to.
    /// Eg. if the trap is recursive - the trap has happened inside a trap handler.
    /// In this case [`lib::syscall::trap_trampoline`] and [`lib::syscall::trap_handler_invoker`]
    /// will push a return address onto the `context` stack.
    /// That will effectively overwrite the `TrapInfo`.
    /// This field exists only to protect meaningfull fields of the `TrapInfo` from beeing overwritten.
    return_address_placeholder: [u8; Self::PLACEHOLDER_SIZE],
}
<span class="boring">}
</span></code></pre></pre>
<p>И к нему можно обратиться по
<a href="../../doc/ku/process/trap_info/constant.RSP_OFFSET_IN_TRAP_INFO.html">смещению</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const RSP_OFFSET_IN_TRAP_INFO: usize = offset_of!(TrapInfo, context) + RSP_OFFSET_IN_MINI_CONTEXT;
<span class="boring">}
</span></code></pre></pre>
<p>от начала структуры
<a href="../../doc/ku/process/trap_info/struct.TrapInfo.html"><code>ku::process::trap_info::TrapInfo</code></a>,
которое сейчас находится в <code>RSP</code>.</p>
<h3 id="Ядерная-часть-системного-вызова-set_trap_handler"><a class="header" href="#Ядерная-часть-системного-вызова-set_trap_handler">Ядерная часть системного вызова <code>set_trap_handler</code></a></h3>
<p>Реализуйте
<a href="../../doc/kernel/process/syscall/fn.set_trap_handler.html">системный вызов</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn kernel::process::syscall::set_trap_handler(
    process: MutexGuard&lt;Process&gt;,
    dst_pid: usize,
    rip: usize,
    stack_address: usize,
    stack_size: usize,
) -&gt; Result&lt;SyscallResult&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/syscall.rs"><code>kernel/src/process/syscall.rs</code></a>.</p>
<p>Он устанавливает для целевого процесса, заданного идентификатором <code>dst_pid</code>,
пользовательский обработчик прерывания с виртуальным адресом <code>rip</code>.
И стеком, который задаётся блоком виртуальных адресов начиная с <code>stack_address</code> и размера <code>stack_size</code>.
Стек может быть не выровнен по границе страниц.
Проверять его на права доступа пока бессмысленно, так как пользовательский код может изменить доступы к этим адресам позже.
Проверять права доступа к памяти надо непосредственно перед доступом.
В случае обработчика прерываний доступ будет позднее, в методе
<a href="../../doc/kernel/process/process/struct.Process.html#method.trap"><code>Process::trap()</code></a>,
и проверку придётся отложить до соответствующего момента.</p>
<p>Вам пригодятся методы
<a href="../../doc/kernel/process/process/struct.Process.html#method.set_trap_context"><code>Process::set_trap_context()</code></a> и
<a href="../../doc/kernel/process/process/struct.TrapContext.html#method.new"><code>TrapContext::new()</code></a>.
<a href="../../doc/kernel/process/process/struct.TrapContext.html"><code>kernel::process::process::TrapContext</code></a> —
это просто пара из контекста пользовательского обработчика
<a href="../../doc/kernel/process/process/struct.TrapContext.html#structfield.mini_context"><code>TrapContext::mini_context</code></a>
и его стека
<a href="../../doc/kernel/process/process/struct.TrapContext.html#structfield.stack"><code>TrapContext::stack</code></a>,
который нужен для определения рекурсивности прерывания в функции
<a href="../../doc/kernel/process/process/struct.Process.html#method.trap"><code>Process::trap()</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub(crate) struct TrapContext {
    mini_context: MiniContext,
    stack: Block&lt;Virt&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="Передача-прерывания-из-режима-ядра-в-режим-пользователя"><a class="header" href="#Передача-прерывания-из-режима-ядра-в-режим-пользователя">Передача прерывания из режима ядра в режим пользователя</a></h3>
<p>Реализуйте
<a href="../../doc/kernel/process/process/struct.Process.html#method.trap">метод</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Process::trap(
    &amp;mut self,
    context: &amp;mut InterruptContext,
    number: usize,
    info: Info,
) -&gt; bool
<span class="boring">}
</span></code></pre></pre>
<p>в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/process.rs"><code>kernel/src/process/process.rs</code></a>.
Она вызывается из функции
<a href="../../doc/kernel/interrupts/fn.generic_trap.html"><code>kernel::interrupts::generic_trap()</code></a> в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/interrupts.rs"><code>kernel/src/interrupts.rs</code></a>,
если прерывание произошло в режиме пользователя.</p>
<p>Её задача — вернуть управление в код пользователя (запускается она в режиме ядра) в контекст
пользовательского обработчика прерывания
<a href="../../doc/kernel/process/process/struct.Process.html#structfield.trap_context"><code>Process::trap_context</code></a>.
Делает это она аналогично
<a href="../../lab/book/4-concurrency-3-preemption.html#%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-6--%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D0%B2%D1%8B%D1%82%D0%B5%D1%81%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D0%BA%D0%BE%D0%B3%D0%BE-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%B0-%D0%BF%D0%BE-%D0%BF%D1%80%D0%B5%D1%80%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D1%8E">реализованному вами ранее</a>
методу
<a href="../../doc/kernel/process/process/struct.Process.html#method.preempt"><code>Process::preempt()</code></a>,
подменяя контекст прерывания <code>context</code> из
обработчика которого вызывается.</p>
<p>Учтите, что возможна ситуация, когда пользовательский обработчик прерывания сам вызовет исключение.
Например, в
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/user/cow_fork/src/main.rs"><code>cow_fork</code></a>
так и будет.
Обработчик Page Fault сам будет иногда вызывать Page Fault.
Который сам же и починит, будучи вызванным фактически рекурсивно.
Поэтому нельзя безусловно использовать значение регистра <code>RSP</code> из
<a href="../../doc/kernel/process/process/struct.Process.html#structfield.trap_context"><code>Process::trap_context</code></a>.
Так как тогда рекурсивный вызов обработчика прерывания перезапишет стек первоначального вызова.
Нужно проверить, что стек <code>context</code> указывает внутрь стека, который задаётся
<a href="../../doc/kernel/process/process/struct.Process.html#structfield.trap_context"><code>Process::trap_context</code></a>.
Если это так, это означает что пользовательский код как раз исполняет обработчик прерывания, так как использует его стек.
Тогда переключать стек не нужно, значение <code>RSP</code> должно остаться как было в <code>context</code>.
Если же пользовательский <code>RSP</code> указывает не в стек обработчика прерываний, то его нужно туда переключить.
Ведь, возможно, Page Fault был вызван попыткой обратиться в обычный стек и если запустить
пользовательский обработчик прерываний, не переключив стек, Page Fault повторится и программа зациклится в рекурсивных вызовах обработчика прерываний.
Соберите
<a href="../../doc/ku/process/mini_context/struct.MiniContext.html"><code>ku::process::mini_context::MiniContext</code></a>
из
<a href="../../doc/kernel/process/process/struct.Process.html#structfield.trap_context"><code>Process::trap_context</code></a>.
и <code>context</code> описанным образом.</p>
<p>С помощью метода
<a href="../../doc/ku/process/mini_context/struct.MiniContext.html#method.push"><code>MiniContext::push()</code></a>
выделите на стеке пользователя блок памяти под структуру
<a href="../../doc/ku/process/trap_info/struct.TrapInfo.html"><code>ku::process::trap_info::TrapInfo</code></a>.
Помните, — доверять пользовательскому стеку нельзя!
Он может быт некорректным изначально или просто уже исчерпаться.
Поэтому обязательно проверьте, что выделенный блок памяти доступен пользователю для записи методом
<a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.check_permission_mut"><code>AddressSpace::check_permission_mut&lt;T&gt;()</code></a>.
Только после этого в него можно записать структуру
<a href="../../doc/ku/process/trap_info/struct.TrapInfo.html"><code>ku::process::trap_info::TrapInfo</code></a>
с описанием возникшего прерывания и его контекста из <code>context</code>.
Метод
<a href="../../doc/kernel/memory/address_space/struct.AddressSpace.html#method.check_permission_mut"><code>AddressSpace::check_permission_mut&lt;T&gt;()</code></a>
возвращает срез, а у нас на самом деле один элемент, — просто используйте <code>[0]</code>.</p>
<p>Если пользовательский обработчик прерываний не установлен,
или же в процессе записи информации в его стек возникла какая-либо ошибка, верните <code>false</code>.
Иначе, подмените в <code>context</code> контекст, в котором возникло прерывание,
на контекст пользовательского обработчика, чтобы в итоге попасть в него.
И верните <code>true</code> в вызывающую функцию.</p>
<h3 id="Проверьте-себя-19"><a class="header" href="#Проверьте-себя-19">Проверьте себя</a></h3>
<p>Теперь должен заработать тест <code>trap_handler()</code> в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/5-um-4-trap-handler.rs"><code>kernel/tests/5-um-4-trap-handler.rs</code></a>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 5-um-4-trap-handler)
...
5_um_4_trap_handler::trap_handler---------------------------
20:23:47 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
20:23:47 0 I duplicate; address_space = &quot;process&quot; @ 0p7E0A000
20:23:47 0 I switch to; address_space = &quot;process&quot; @ 0p7E0A000
20:23:47 0 D extend mapping; block = [0v10000000, 0v10007AAC), size 30.668 KiB; page_block = [0v10000000, 0v10008000), size 32.000 KiB; flags =   R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
20:23:47 0 D elf loadable program header; file_block = [0v201D83, 0v20982F), size 30.668 KiB; memory_block = [0v10000000, 0v10007AAC), size 30.668 KiB; flags =   R
20:23:47 0 D extend mapping; block = [0v10008000, 0v1005A3BD), size 328.935 KiB; page_block = [0v10008000, 0v1005B000), size 332.000 KiB; flags = X R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
20:23:47 0 D elf loadable program header; file_block = [0v209833, 0v25C140), size 330.263 KiB; memory_block = [0v10007AB0, 0v1005A3BD), size 330.263 KiB; flags = X R
20:23:47 0 D elf loadable program header; file_block = [0v25C143, 0v25C253), size 272 B; memory_block = [0v1005A3C0, 0v1005A4D0), size 272 B; flags =  WR
20:23:47 0 D extend mapping; block = [0v1005B000, 0v10060E10), size 23.516 KiB; page_block = [0v1005B000, 0v10061000), size 24.000 KiB; flags =  WR; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
20:23:47 0 D elf loadable program header; file_block = [0v25C253, 0v262B6B), size 26.273 KiB; memory_block = [0v1005A4D0, 0v10060E10), size 26.312 KiB; flags =  WR
20:23:47 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:23:47 0 I loaded ELF file; context = { rip: 0v1000B250, rsp: 0v7F7FFFFFF000 }; file_size = 5.581 MiB; process = { pid: &lt;current&gt;, address_space: &quot;process&quot; @ 0p7E0A000, { rip: 0v1000B250, rsp: 0v7F7FFFFFF000 } }
20:23:47 0 I allocate; slot = Process { pid: 0:0, address_space: &quot;0:0&quot; @ 0p7E0A000, { rip: 0v1000B250, rsp: 0v7F7FFFFFF000 } }; process_count = 1
20:23:47 0 I user process page table entry; entry_point = 0v1000B250; frame = Frame(32233 @ 0p7DE9000); flags = PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED | DIRTY
20:23:47 0 D process_frames = 155
20:23:47 0 I dequeue; pid = Some(0:0)
20:23:47 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E0A000
20:23:47 0 D entering the user mode; pid = 0:0; registers = { rax: 0x0, rdi: 0x7F7FFFFDB000, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v1000B250, ss:rsp: 0x001B:0v7F7FFFFFF000, rflags: IF } }
20:23:47 0 I trap_stack = [0v7F7FFFFD7000, 0v7F7FFFFDB000), size 16.000 KiB; pid = 0:0
20:23:47 0 I stored from main(); value = 333333333; pid = 0:0
20:23:47 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10023BD6, ss:rsp: 0x001B:0v7F7FFFFFDBE8, rflags: IF AF PF }; info = { address: 0v7F7FFFFD6000, code: 0b100 = non-present page | read | user }
20:23:47 0 D leaving the user mode; pid = 0:0
20:23:47 0 I the process was preempted; pid = 0:0; user_context = { mode: user, cs:rip: 0x0023:0v1000D320, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF PF }
20:23:47 0 I returned
20:23:47 0 I dequeue; pid = Some(0:0)
20:23:47 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E0A000
20:23:47 0 D entering the user mode; pid = 0:0; registers = { rax: 0x1005B8E8, rdi: 0x7F7FFFFD6000, rsi: 0x7F7FFFFFE7C8, { mode: user, cs:rip: 0x0023:0v1000D320, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: AF PF } }
20:23:47 0 I trap handler called for a page fault on an address; value = 140187732369408; hex_value = 0x7F7FFFFD6000; pid = 0:0
20:23:47 0 I stored from simple_trap_handler(); value = 777777777; pid = 0:0
20:23:47 0 I stored from main(); value = 555555555; pid = 0:0
20:23:47 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10023BD6, ss:rsp: 0x001B:0v7F7FFFFFDBE8, rflags: IF AF PF }; info = { address: 0v7F7FFFFD6000, code: 0b100 = non-present page | read | user }
20:23:47 0 I recursive page fault at level; value = 0; hex_value = 0x0; pid = 0:0
20:23:47 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000A393, ss:rsp: 0x001B:0v7F7FFFFDAD88, rflags: IF }; info = { address: 0v7F7FFFFD6008, code: 0b100 = non-present page | read | user }
20:23:47 0 D leaving the user mode; pid = 0:0
20:23:47 0 I the process was preempted; pid = 0:0; user_context = { mode: user, cs:rip: 0x0023:0v1000D320, ss:rsp: 0x001B:0v7F7FFFFDAD50, rflags: IF }
20:23:47 0 I returned
20:23:47 0 I dequeue; pid = Some(0:0)
20:23:47 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E0A000
20:23:47 0 D entering the user mode; pid = 0:0; registers = { rax: 0x7F7FFFFD6000, rdi: 0x7F7FFFFDAEB8, rsi: 0x1005C978, { mode: user, cs:rip: 0x0023:0v1000D320, ss:rsp: 0x001B:0v7F7FFFFDAD50, rflags:  } }
20:23:48.001 0 I recursive page fault at level; value = 1; hex_value = 0x1; pid = 0:0
20:23:48.009 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000A393, ss:rsp: 0x001B:0v7F7FFFFDAB10, rflags: IF }; info = { address: 0v7F7FFFFD6010, code: 0b100 = non-present page | read | user }
20:23:48.025 0 I recursive page fault at level; value = 2; hex_value = 0x2; pid = 0:0
20:23:48.033 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000A393, ss:rsp: 0x001B:0v7F7FFFFDA898, rflags: IF }; info = { address: 0v7F7FFFFD6018, code: 0b100 = non-present page | read | user }
20:23:48.047 0 I recursive page fault at level; value = 3; hex_value = 0x3; pid = 0:0
20:23:48.055 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000A393, ss:rsp: 0x001B:0v7F7FFFFDA620, rflags: IF }; info = { address: 0v7F7FFFFD6020, code: 0b100 = non-present page | read | user }
20:23:48.069 0 I recursive page fault at level; value = 4; hex_value = 0x4; pid = 0:0
20:23:48.077 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000A393, ss:rsp: 0x001B:0v7F7FFFFDA3A8, rflags: IF }; info = { address: 0v7F7FFFFD6028, code: 0b100 = non-present page | read | user }
20:23:48.091 0 I recursive page fault at level; value = 5; hex_value = 0x5; pid = 0:0
20:23:48.099 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000A393, ss:rsp: 0x001B:0v7F7FFFFDA130, rflags: IF }; info = { address: 0v7F7FFFFD6030, code: 0b100 = non-present page | read | user }
20:23:48.113 0 I recursive page fault at level; value = 6; hex_value = 0x6; pid = 0:0
20:23:48.121 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000A393, ss:rsp: 0x001B:0v7F7FFFFD9EB8, rflags: IF }; info = { address: 0v7F7FFFFD6038, code: 0b100 = non-present page | read | user }
20:23:48.135 0 I recursive page fault at level; value = 7; hex_value = 0x7; pid = 0:0
20:23:48.143 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000A393, ss:rsp: 0x001B:0v7F7FFFFD9C40, rflags: IF }; info = { address: 0v7F7FFFFD6040, code: 0b100 = non-present page | read | user }
20:23:48.157 0 D leaving the user mode; pid = 0:0
20:23:48.161 0 I the process was preempted; pid = 0:0; user_context = { mode: user, cs:rip: 0x0023:0v1000D320, ss:rsp: 0x001B:0v7F7FFFFD9C08, rflags: IF }
20:23:48.171 0 I returned
20:23:48.175 0 I dequeue; pid = Some(0:0)
20:23:48.179 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E0A000
20:23:48.183 0 D entering the user mode; pid = 0:0; registers = { rax: 0x7F7FFFFD6038, rdi: 0x7F7FFFFD9D70, rsi: 0x1005C978, { mode: user, cs:rip: 0x0023:0v1000D320, ss:rsp: 0x001B:0v7F7FFFFD9C08, rflags:  } }
20:23:48.197 0 I recursive page fault at level; value = 8; hex_value = 0x8; pid = 0:0
20:23:48.205 0 I setting the simple trap handler from the recursive trap handler, new trap_stack rsp; value = 140187732369408; hex_value = 0x7F7FFFFD6000; pid = 0:0
20:23:48.217 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000A393, ss:rsp: 0x001B:0v7F7FFFFD9C40, rflags: IF }; info = { address: 0v7F7FFFFD6040, code: 0b100 = non-present page | read | user }
20:23:48.231 0 I trap handler called for a page fault on an address; value = 140187732369472; hex_value = 0x7F7FFFFD6040; pid = 0:0
20:23:47.925 0 I stored from recursive_trap_handler(); value = 777777785; pid = 0:0
20:23:48.251 0 I free; slot = Process { pid: 0:0, address_space: &quot;0:0&quot; @ 0p7E0A000, { rip: 0v1000D320, rsp: 0v7F7FFFFD9C08 } }; process_count = 0
20:23:48.259 0 I switch to; address_space = &quot;base&quot; @ 0p1000
20:23:48.265 0 I drop the current address space; address_space = &quot;0:0&quot; @ 0p7E0A000; switch_to = &quot;base&quot; @ 0p1000
20:23:48.323 0 I syscall = &quot;exit&quot;; pid = 0:0; code = 0; reason = Some(OK)
20:23:48.327 0 D leaving the user mode; pid = 0:0
20:23:48.333 0 I dequeue; pid = None
5_um_4_trap_handler::trap_handler------------------ [passed]
20:23:48.341 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-23"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-23">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/process/process.rs |   50 ++++++++++++++++++++++++++++++++++++++++++++++++--
 kernel/src/process/syscall.rs |   12 ++++++++++--
 user/lib/src/syscall.rs       |   48 ++++++++++++++++++++++++++++++++++++++++++++++--
 3 files changed, 104 insertions(+), 6 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="copy-on-write-fork"><a class="header" href="#copy-on-write-fork">Copy-on-write fork</a></h2>
<p>Теперь у нас есть всё необходимое для реализации copy-on-write <code>fork()</code> в пространстве пользователя.
Программа <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/user/cow_fork/src/main.rs"><code>user/cow_fork/src/main.rs</code></a> структурно похожа на <a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/user/eager_fork/src/main.rs"><code>user/eager_fork/src/main.rs</code></a>
и на <code>eager_fork</code> можно ориентироваться при реализации.</p>
<h4 id="Ленивое-копирование-адресного-пространства"><a class="header" href="#Ленивое-копирование-адресного-пространства">Ленивое копирование адресного пространства</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn copy_page_table(
    child: Pid,
    level: u32,
    trap_stack: Block&lt;Page&gt;,
    virt_addr: Virt,
) -&gt; Result&lt;()&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Выполняется аналогично <a href="../../lab/book/5-um-3-eager-fork.html#copy_page_table">соответствующей процедуре</a> <code>eager_fork</code>.
Отличается от которой в паре моментов:</p>
<ul>
<li>К игнорируемым страницам добавляется <code>trap_stack</code>, его копировать не нужно. У потомка изначально будет полностью отдельный стек для обработки исключений.</li>
<li>Вместо копирования страниц функцией <code>lib::memory::copy_page()</code> создаёт в потомке отображение. Оно ссылается на тот же физический фрейм, на который ссылается соответствующая виртуальная страница в родителе. При этом для страниц, которые отображены с одним из флагов <a href="../../doc/ku/memory/mmu/struct.PageTableFlags.html#associatedconstant.WRITABLE"><code>PageTableFlags::WRITABLE</code></a> или <a href="../../doc/ku/memory/mmu/struct.PageTableFlags.html#associatedconstant.COPY_ON_WRITE"><code>PageTableFlags::COPY_ON_WRITE</code></a>, в обоих адресных пространствах меняет флаги отображения страницы так, чтобы <a href="../../doc/ku/memory/mmu/struct.PageTableFlags.html#associatedconstant.COPY_ON_WRITE"><code>PageTableFlags::COPY_ON_WRITE</code></a> был включён, а <a href="../../doc/ku/memory/mmu/struct.PageTableFlags.html#associatedconstant.WRITABLE"><code>PageTableFlags::WRITABLE</code></a> — выключен. Копирование содержимого страницы функцией <code>lib::memory::copy_page()</code> таким образом лениво откладывается до возникновения Page Fault.</li>
</ul>
<h4 id="Пользовательский-обработчик-исключений-page-fault"><a class="header" href="#Пользовательский-обработчик-исключений-page-fault">Пользовательский обработчик исключений Page Fault</a></h4>
<p>Когда программа попытается записать в страницу, помеченную в <code>copy_page_table()</code> как
<a href="../../doc/ku/memory/mmu/struct.PageTableFlags.html#associatedconstant.COPY_ON_WRITE"><code>PageTableFlags::COPY_ON_WRITE</code></a>
и только на чтение,
возникнет Page Fault и ядро передаст управление в
<a href="../../lab/book/5-um-4-trap-handler.html#%D0%A2%D1%80%D0%B0%D0%BC%D0%BF%D0%BB%D0%B8%D0%BD-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B0-%D0%BF%D1%80%D0%B5%D1%80%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B9">реализованный вами ранее</a>
<code>trap_trampoline()</code>, который в свою очередь запустит</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn trap_handler(info: &amp;TrapInfo)
<span class="boring">}
</span></code></pre></pre>
<p>Эта функция работает в очень стеснённых условиях.</p>
<p>Возможно, вся память программы, кроме стека <code>trap_stack</code>, на котором сейчас работает эта функция, доступна только на чтение.
В том числе <code>RingBuffer</code>, который используется для логирования в пространстве пользователя макросами библиотеки <a href="https://docs.rs/tracing/">tracing</a> — <code>info!()</code>, <code>debug!()</code> и т.д.
Так как при этом нужно писать, то такое логирование в <code>trap_handler()</code> не доступно.
<code>panic!()</code> тоже не доступен, так как он использует логирование.
В других частях <code>cow_fork</code> логированием можно пользоваться, потому что <code>trap_handler()</code> починит возникающие при этом Page Fault.
Для логирования в <code>trap_handler()</code> можно воспользоваться
<a href="../../lab/book/3-process-4-syscall.html#%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-12--%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%BD%D1%8B%D0%B9-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2-log_value">одним из первых реализованных системных вызовов</a> —
<code>syscall::log_value()</code>.</p>
<p>Вторая неприятность заключается в том, что в процессе–потомке в <code>trap_handler()</code> не доступны
<code>ku::ProcessInfo</code> и <code>ku::SystemInfo</code> даже на чтение.
Поэтому потомок не может узнать свой идентификатор <code>Pid</code>.
Так как не работает, в том числе функция <code>ku::process::pid()</code>.
Поэтому в <code>trap_handler()</code> идентифицировать процесс для выполняемых системных вызовов нужно как <code>Pid::Current</code>.</p>
<p>Также учтите, что эти ограничения распространяются на вспомогательные функции, которые <code>trap_handler()</code> использует.
Впрочем, оба эти ограничения — во многом следствие нашей реализации <code>cow_fork</code>,
а не характерная особенность обработки прерываний в пространстве пользователя.</p>
<p>При получении управления, <code>trap_handler()</code>:</p>
<ul>
<li>Проверяет, что прерывание — это действительно <code>PageFault</code> и он вызван записью. Иначе обработчик прекращает исполнение программы, вызвав <code>syscall::exit()</code> с кодом ошибки.</li>
<li>С помощью <a href="../../lab/book/5-um-3-eager-fork.html#temp_page">реализованной ранее</a> функции <code>lib::memory::temp_page()</code> находит временную страницу.</li>
<li>Копирует содержимое страницы, обращение к которой привело к Page Fault, во временную, с помощью <a href="../../lab/book/5-um-3-eager-fork.html#copy_page">реализованной вами ранее</a> функции <code>lib::memory::copy_page()</code>.</li>
<li>С помощью системного вызова <code>syscall::copy_mapping()</code> заменяет физический фрейм под скопированной страницей на фрейм временной страницы, одновременно меняя флаг <a href="../../doc/ku/memory/mmu/struct.PageTableFlags.html#associatedconstant.COPY_ON_WRITE"><code>PageTableFlags::COPY_ON_WRITE</code></a> на <a href="../../doc/ku/memory/mmu/struct.PageTableFlags.html#associatedconstant.WRITABLE"><code>PageTableFlags::WRITABLE</code></a> в её отображении.</li>
<li>С помощью системного вызова <code>syscall::unmap()</code> удаляет из адресного пространства не нужную более временную страницу.</li>
</ul>
<h4 id="cow_fork"><a class="header" href="#cow_fork"><code>cow_fork()</code></a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn cow_fork() -&gt; Result&lt;bool&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Эта функции похожа на соответствующую функцию <code>eager_fork()</code>, но в ней добавляется работа по инициализации обработчика прерываний.
Функция <code>cow_fork()</code>:</p>
<ul>
<li>Выделяет себе — родительскому процессу — стек для обработки исключений с помощью <code>syscall::map()</code> и устанавливает себе функцией <code>syscall::set_trap_handler()</code> обработчик исключений <code>trap_handler()</code>.</li>
<li>Создаёт процесс потомка с помощью <a href="../../lab/book/5-um-3-eager-fork.html#%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%BD%D1%8B%D0%B9-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2-exofork">реализованного вами ранее</a> системного вызова <code>syscall::exofork()</code>.</li>
<li>Далее лениво копирует своё адресное пространство в пространство потомка с помощью функции <code>fn copy_address_space()</code>.</li>
<li>Выделяет потомку отдельный стек для обработки исключений с помощью <code>syscall::map()</code> и устанавливает уже ему обработчик исключений <code>trap_handler()</code> функцией <code>syscall::set_trap_handler()</code>.</li>
<li>Запускает потомка системным вызовом <code>syscall::set_state()</code>, устанавливая его состояние в <code>State::Runnable</code>.</li>
</ul>
<p>В потомке <code>cow_fork()</code> ничего не делает.
Возвращает она <code>true</code> в процессе потомка и <code>false</code> в процессе родителя.</p>
<h3 id="Проверьте-себя-20"><a class="header" href="#Проверьте-себя-20">Проверьте себя</a></h3>
<p>Теперь должны заработать тест <code>cow_fork()</code> в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/5-um-5-cow-fork.rs"><code>kernel/tests/5-um-5-cow-fork.rs</code></a>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 5-um-5-cow-fork)
...
5_um_5_cow_fork::cow_fork-----------------------------------
16:28:55 0 I page allocator init; free_page_count = 33822867456; block = [0v18000000000, 0v7F8000000000), size 126.000 TiB
16:28:55 0 I duplicate; address_space = &quot;process&quot; @ 0p7E09000
16:28:55 0 I switch to; address_space = &quot;process&quot; @ 0p7E09000
16:28:55 0 D extend mapping; block = [0v10000000, 0v1000817C), size 32.371 KiB; page_block = [0v10000000, 0v10009000), size 36.000 KiB; flags =   R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
16:28:55 0 D elf loadable program header; file_block = [0v202177, 0v20A2F3), size 32.371 KiB; memory_block = [0v10000000, 0v1000817C), size 32.371 KiB; flags =   R
16:28:55 0 D extend mapping; block = [0v10009000, 0v1006286D), size 358.106 KiB; page_block = [0v10009000, 0v10063000), size 360.000 KiB; flags = X R; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
16:28:55 0 D elf loadable program header; file_block = [0v20A2F7, 0v2649E4), size 361.731 KiB; memory_block = [0v10008180, 0v1006286D), size 361.731 KiB; flags = X R
16:28:55 0 D elf loadable program header; file_block = [0v2649E7, 0v264B07), size 288 B; memory_block = [0v10062870, 0v10062990), size 288 B; flags =  WR
16:28:55 0 D extend mapping; block = [0v10063000, 0v10069BE8), size 26.977 KiB; page_block = [0v10063000, 0v1006A000), size 28.000 KiB; flags =  WR; page_flags = PRESENT | WRITABLE | USER_ACCESSIBLE
16:28:55 0 D elf loadable program header; file_block = [0v264B07, 0v26BD2F), size 28.539 KiB; memory_block = [0v10062990, 0v10069BE8), size 28.586 KiB; flags =  WR
16:28:55 0 I switch to; address_space = &quot;base&quot; @ 0p1000
16:28:55 0 I loaded ELF file; context = { rip: 0v10011650, rsp: 0v7F7FFFFFF000 }; file_size = 5.832 MiB; process = { pid: &lt;current&gt;, address_space: &quot;process&quot; @ 0p7E09000, { rip: 0v10011650, rsp: 0v7F7FFFFFF000 } }
16:28:55 0 I allocate; slot = Process { pid: 0:0, address_space: &quot;0:0&quot; @ 0p7E09000, { rip: 0v10011650, rsp: 0v7F7FFFFFF000 } }; process_count = 1
16:28:55 0 I user process page table entry; entry_point = 0v10011650; frame = Frame(32226 @ 0p7DE2000); flags = PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED | DIRTY
16:28:55 0 D process_frames = 164
16:28:57 0 I dequeue; pid = Some(0:0)
16:28:57 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E09000
16:28:57 0 D entering the user mode; pid = 0:0; registers = { rax: 0x0, rdi: 0x7F7FFFFDB000, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v10011650, ss:rsp: 0x001B:0v7F7FFFFFF000, rflags: IF } }
16:28:57 0 I name = &quot;cow_fork *&quot;; pedigree = [0:0]; len = 1; capacity = 3; pid = 0:0
16:28:57 0 I page allocator init; free_page_count = 33688649728; block = [0v18000000000, 0v7F0000000000), size 125.500 TiB
16:28:57 0 I duplicate; address_space = &quot;process&quot; @ 0p7D61000
16:28:57 0 I switch to; address_space = &quot;process&quot; @ 0p7D61000
16:28:57 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E09000
16:28:57 0 I allocate; slot = Process { pid: 1:0, address_space: &quot;1:0&quot; @ 0p7D61000, { rip: 0v1000AAE7, rsp: 0v7F7FFFFFD588 } }; process_count = 2
16:28:57 0 I syscall = &quot;exofork&quot;; process = 0:0; child = 1:0
16:28:57 0 I syscall::exofork() done; child = Ok(1:0); pid = 0:0
16:28:57 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1001318E, ss:rsp: 0x001B:0v7F7FFFFFBA78, rflags: IF }; info = { address: 0v7F7FFFFFBB60, code: 0b111 = protection violation | write | user }
16:28:57 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10010C2F, ss:rsp: 0x001B:0v7F7FFFFFB9E8, rflags: IF AF }; info = { address: 0v7F7FFFFFC0B8, code: 0b111 = protection violation | write | user }
16:28:57 0 D leaving the user mode; pid = 0:0
16:28:57 0 I the process was preempted; pid = 0:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF }
16:28:57 0 I returned
16:28:57 0 I dequeue; pid = Some(0:0)
16:28:57 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E09000
16:28:57 0 D entering the user mode; pid = 0:0; registers = { rax: 0x7F7FFFFFC0B8, rdi: 0x0, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF } }
16:28:57 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000D013, ss:rsp: 0x001B:0v7F7FFFFFC8F8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFD438, code: 0b111 = protection violation | write | user }
16:28:57 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000B851, ss:rsp: 0x001B:0v7F7FFFFFD598, rflags: IF ZF AF PF CF }; info = { address: 0v7F7FFFFFE348, code: 0b111 = protection violation | write | user }
16:28:57 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1002DF08, ss:rsp: 0x001B:0v7F7FFFFFD278, rflags: IF ZF PF }; info = { address: 0v10066ED8, code: 0b111 = protection violation | write | user }
16:28:57 0 D leaving the user mode; pid = 0:0
16:28:57 0 I the process was preempted; pid = 0:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF ZF PF }
16:28:57 0 I returned
16:28:57 0 I dequeue; pid = Some(0:0)
16:28:57 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E09000
16:28:57 0 D entering the user mode; pid = 0:0; registers = { rax: 0x0, rdi: 0x10066ED8, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF ZF PF } }
16:28:57 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1002D9B1, ss:rsp: 0x001B:0v7F7FFFFFD1C8, rflags: IF }; info = { address: 0v10067020, code: 0b111 = protection violation | write | user }
16:28:57 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1002E452, ss:rsp: 0x001B:0v7F7FFFFFD138, rflags: IF ZF PF }; info = { address: 0v10069BE0, code: 0b111 = protection violation | write | user }
16:28:57 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1002FC77, ss:rsp: 0x001B:0v7F7FFFFFAF78, rflags: IF AF PF }; info = { address: 0v7F7FFFFFAF98, code: 0b111 = protection violation | write | user }
16:28:57 0 D leaving the user mode; pid = 0:0
16:28:57 0 I the process was preempted; pid = 0:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF PF }
16:28:57 0 I returned
16:28:57 0 I dequeue; pid = Some(0:0)
16:28:57 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E09000
16:28:57 0 D entering the user mode; pid = 0:0; registers = { rax: 0x7F7FFFFFBF00, rdi: 0x7F7FFFFFB940, rsi: 0x7F7FFFFFB540, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF PF } }
16:28:57 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10052E60, ss:rsp: 0x001B:0v7F7FFFFF9FE8, rflags: IF AF }; info = { address: 0v7F7FFFFF9FE0, code: 0b111 = protection violation | write | user }
16:28:57 0 I copy_address_space done; child = 1:0; trap_stack = [0v7F7FFFFD7000, 0v7F7FFFFDB000), size 16.000 KiB, Page[~127.500 TiB, ~127.500 TiB); pid = 0:0
16:28:57 0 I syscall::set_state(); child = 1:0; result = Ok(()); pid = 0:0
16:28:57 0 I page allocator init; free_page_count = 33688649728; block = [0v18000000000, 0v7F0000000000), size 125.500 TiB
16:28:57 0 I duplicate; address_space = &quot;process&quot; @ 0p7D36000
16:28:57 0 I switch to; address_space = &quot;process&quot; @ 0p7D36000
16:28:57 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E09000
16:28:57 0 I allocate; slot = Process { pid: 2:0, address_space: &quot;2:0&quot; @ 0p7D36000, { rip: 0v1000AAE7, rsp: 0v7F7FFFFFD588 } }; process_count = 3
16:28:57 0 I syscall = &quot;exofork&quot;; process = 0:0; child = 2:0
16:28:57 0 I syscall::exofork() done; child = Ok(2:0); pid = 0:0
16:28:57 0 D leaving the user mode; pid = 0:0
16:28:57 0 I the process was preempted; pid = 0:0; user_context = { mode: user, cs:rip: 0x0023:0v1001318C, ss:rsp: 0x001B:0v7F7FFFFFBA68, rflags: IF }
16:28:57 0 I returned
16:28:57 0 I dequeue; pid = Some(1:0)
16:28:57 0 I switch to; address_space = &quot;1:0&quot; @ 0p7D61000
16:28:57 0 D entering the user mode; pid = 1:0; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7EFFFFFFB000, { mode: user, cs:rip: 0x0023:0v1000AAE7, ss:rsp: 0x001B:0v7F7FFFFFD588, rflags: IF } }
16:28:57 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000AAE9, ss:rsp: 0x001B:0v7F7FFFFFD598, rflags: IF }; info = { address: 0v7F7FFFFFE820, code: 0b111 = protection violation | write | user }
16:28:57 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10018677, ss:rsp: 0x001B:0v7F7FFFFDAD68, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFD590, code: 0b111 = protection violation | write | user }
16:28:57 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015BD2, ss:rsp: 0x001B:0v7F7FFFFFD478, rflags: IF }; info = { address: 0v10069BC0, code: 0b111 = protection violation | write | user }
16:28:57 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10046BD1, ss:rsp: 0x001B:0v7F7FFFFFD290, rflags: IF PF }; info = { address: 0v10067DB8, code: 0b111 = protection violation | write | user }
16:28:57 0 D leaving the user mode; pid = 1:0
16:28:57 0 I the process was preempted; pid = 1:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF PF }
16:28:57 0 I returned
16:28:58.005 0 I dequeue; pid = Some(0:0)
16:28:58.009 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E09000
16:28:58.015 0 D entering the user mode; pid = 0:0; registers = { rax: 0x0, rdi: 0x0, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v1001318C, ss:rsp: 0x001B:0v7F7FFFFFBA68, rflags: IF } }
16:28:58.081 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1001318E, ss:rsp: 0x001B:0v7F7FFFFFBA78, rflags: IF }; info = { address: 0v7F7FFFFFBB60, code: 0b111 = protection violation | write | user }
16:28:58.099 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10010C2F, ss:rsp: 0x001B:0v7F7FFFFFB9E8, rflags: IF AF }; info = { address: 0v7F7FFFFFC0B8, code: 0b111 = protection violation | write | user }
16:28:58.117 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000D013, ss:rsp: 0x001B:0v7F7FFFFFC8F8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFD438, code: 0b111 = protection violation | write | user }
16:28:58.133 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000B851, ss:rsp: 0x001B:0v7F7FFFFFD598, rflags: IF ZF AF PF CF }; info = { address: 0v7F7FFFFFE348, code: 0b111 = protection violation | write | user }
16:28:58.149 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10046BD1, ss:rsp: 0x001B:0v7F7FFFFFD290, rflags: IF PF }; info = { address: 0v10067DB8, code: 0b111 = protection violation | write | user }
16:28:58.165 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1002FC77, ss:rsp: 0x001B:0v7F7FFFFFAF78, rflags: IF AF PF }; info = { address: 0v7F7FFFFFAF98, code: 0b111 = protection violation | write | user }
16:28:58.179 0 D leaving the user mode; pid = 0:0
16:28:58.185 0 I the process was preempted; pid = 0:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF PF }
16:28:58.195 0 I returned
16:28:58.199 0 I dequeue; pid = Some(1:0)
16:28:58.203 0 I switch to; address_space = &quot;1:0&quot; @ 0p7D61000
16:28:58.209 0 D entering the user mode; pid = 1:0; registers = { rax: 0x1, rdi: 0x10067DB8, rsi: 0x1, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF PF } }
16:28:58.225 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015AA7, ss:rsp: 0x001B:0v7F7FFFFFCFC8, rflags: IF AF }; info = { address: 0v7F7FFFFFCFC8, code: 0b111 = protection violation | write | user }
16:28:58.241 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10025184, ss:rsp: 0x001B:0v7F7FFFFFBFD8, rflags: IF AF PF }; info = { address: 0v7F7FFFFFBFE0, code: 0b111 = protection violation | write | user }
16:28:57.971 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 1:0
16:28:58.261 0 I just created; child = &lt;current&gt;; pid = 1:0; pid = 1:0
16:28:58.261 0 I name = &quot;cow_fork *0&quot;; pedigree = [0:0, 1:0]; len = 2; capacity = 3; pid = 1:0
16:28:58.363 0 I page allocator init; free_page_count = 33554432000; block = [0v18000000000, 0v7E8000000000), size 125.000 TiB
16:28:58.373 0 I duplicate; address_space = &quot;process&quot; @ 0p7D69000
16:28:58.379 0 I switch to; address_space = &quot;process&quot; @ 0p7D69000
16:28:58.385 0 I switch to; address_space = &quot;1:0&quot; @ 0p7D61000
16:28:58.391 0 I allocate; slot = Process { pid: 3:0, address_space: &quot;3:0&quot; @ 0p7D69000, { rip: 0v1000AAE7, rsp: 0v7F7FFFFFD0A8 } }; process_count = 4
16:28:58.401 0 I syscall = &quot;exofork&quot;; process = 1:0; child = 3:0
16:28:58.405 0 I syscall::exofork() done; child = Ok(3:0); pid = 1:0
16:28:58.545 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1001318E, ss:rsp: 0x001B:0v7F7FFFFFB598, rflags: IF }; info = { address: 0v7F7FFFFFB680, code: 0b111 = protection violation | write | user }
16:28:58.563 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000D013, ss:rsp: 0x001B:0v7F7FFFFFB7D8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFC318, code: 0b111 = protection violation | write | user }
16:28:58.579 0 D leaving the user mode; pid = 1:0
16:28:58.583 0 I the process was preempted; pid = 1:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF ZF PF }
16:28:58.593 0 I returned
16:28:58.597 0 I dequeue; pid = Some(0:0)
16:28:58.601 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E09000
16:28:58.607 0 D entering the user mode; pid = 0:0; registers = { rax: 0x7F7FFFFFBF00, rdi: 0x7F7FFFFFB940, rsi: 0x7F7FFFFFB540, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF PF } }
16:28:58.623 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10052E60, ss:rsp: 0x001B:0v7F7FFFFF9FE8, rflags: IF AF }; info = { address: 0v7F7FFFFF9FE0, code: 0b111 = protection violation | write | user }
16:28:58.149 0 I copy_address_space done; child = 2:0; trap_stack = [0v7F7FFFFD7000, 0v7F7FFFFDB000), size 16.000 KiB, Page[~127.500 TiB, ~127.500 TiB); pid = 0:0
16:28:58.655 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10013B12, ss:rsp: 0x001B:0v7F7FFFFFD2B8, rflags: IF }; info = { address: 0v10069BB8, code: 0b111 = protection violation | write | user }
16:28:58.673 0 I syscall::set_state(); child = 2:0; result = Ok(()); pid = 0:0
16:28:58.757 0 I page allocator init; free_page_count = 33688649728; block = [0v18000000000, 0v7F0000000000), size 125.500 TiB
16:28:58.767 0 I duplicate; address_space = &quot;process&quot; @ 0p7CE9000
16:28:58.773 0 I switch to; address_space = &quot;process&quot; @ 0p7CE9000
16:28:58.779 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E09000
16:28:58.785 0 I allocate; slot = Process { pid: 4:0, address_space: &quot;4:0&quot; @ 0p7CE9000, { rip: 0v1000AAE7, rsp: 0v7F7FFFFFD588 } }; process_count = 5
16:28:58.795 0 I syscall = &quot;exofork&quot;; process = 0:0; child = 4:0
16:28:58.799 0 I syscall::exofork() done; child = Ok(4:0); pid = 0:0
16:28:58.939 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1001318E, ss:rsp: 0x001B:0v7F7FFFFFBA78, rflags: IF }; info = { address: 0v7F7FFFFFBB60, code: 0b111 = protection violation | write | user }
16:28:58.957 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10010C2F, ss:rsp: 0x001B:0v7F7FFFFFB9E8, rflags: IF AF }; info = { address: 0v7F7FFFFFC0B8, code: 0b111 = protection violation | write | user }
16:28:58.975 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000D013, ss:rsp: 0x001B:0v7F7FFFFFC8F8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFD438, code: 0b111 = protection violation | write | user }
16:28:59.001 0 D leaving the user mode; pid = 0:0
16:28:59.005 0 I the process was preempted; pid = 0:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF ZF PF }
16:28:59.015 0 I returned
16:28:59.019 0 I dequeue; pid = Some(1:0)
16:28:59.023 0 I switch to; address_space = &quot;1:0&quot; @ 0p7D61000
16:28:59.029 0 D entering the user mode; pid = 1:0; registers = { rax: 0x7F7FFFFFC318, rdi: 0x0, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF ZF PF } }
16:28:59.045 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000D043, ss:rsp: 0x001B:0v7F7FFFFFCA38, rflags: IF SF }; info = { address: 0v7F7FFFFFD000, code: 0b111 = protection violation | write | user }
16:28:59.061 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000B86F, ss:rsp: 0x001B:0v7F7FFFFFD0B8, rflags: IF ZF AF PF CF }; info = { address: 0v7F7FFFFFE030, code: 0b111 = protection violation | write | user }
16:28:59.079 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1002DF08, ss:rsp: 0x001B:0v7F7FFFFFCD98, rflags: IF ZF PF }; info = { address: 0v10066ED8, code: 0b111 = protection violation | write | user }
16:28:59.093 0 D leaving the user mode; pid = 1:0
16:28:59.099 0 I the process was preempted; pid = 1:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF ZF PF }
16:28:59.107 0 I returned
16:28:59.113 0 I dequeue; pid = Some(2:0)
16:28:59.117 0 I switch to; address_space = &quot;2:0&quot; @ 0p7D36000
16:28:59.121 0 D entering the user mode; pid = 2:0; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7EFFFFFFB000, { mode: user, cs:rip: 0x0023:0v1000AAE7, ss:rsp: 0x001B:0v7F7FFFFFD588, rflags: IF AF PF } }
16:28:59.135 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000AAE9, ss:rsp: 0x001B:0v7F7FFFFFD598, rflags: IF AF PF }; info = { address: 0v7F7FFFFFE820, code: 0b111 = protection violation | write | user }
16:28:59.153 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10018677, ss:rsp: 0x001B:0v7F7FFFFDAD68, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFD590, code: 0b111 = protection violation | write | user }
16:28:59.169 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015BD2, ss:rsp: 0x001B:0v7F7FFFFFD478, rflags: IF }; info = { address: 0v10069BC0, code: 0b111 = protection violation | write | user }
16:28:59.185 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10046BD1, ss:rsp: 0x001B:0v7F7FFFFFD290, rflags: IF PF }; info = { address: 0v10067DB8, code: 0b111 = protection violation | write | user }
16:28:59.199 0 D leaving the user mode; pid = 2:0
16:28:59.205 0 I the process was preempted; pid = 2:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF PF }
16:28:59.215 0 I returned
16:28:59.219 0 I dequeue; pid = Some(0:0)
16:28:59.223 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E09000
16:28:59.227 0 D entering the user mode; pid = 0:0; registers = { rax: 0x7F7FFFFFD438, rdi: 0x0, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF ZF PF } }
16:28:59.243 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000B851, ss:rsp: 0x001B:0v7F7FFFFFD598, rflags: IF ZF AF PF CF }; info = { address: 0v7F7FFFFFE348, code: 0b111 = protection violation | write | user }
16:28:59.261 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10046BD1, ss:rsp: 0x001B:0v7F7FFFFFD290, rflags: IF PF }; info = { address: 0v10067DB8, code: 0b111 = protection violation | write | user }
16:28:59.277 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1002FC77, ss:rsp: 0x001B:0v7F7FFFFFAF78, rflags: IF AF PF }; info = { address: 0v7F7FFFFFAF98, code: 0b111 = protection violation | write | user }
16:28:59.293 0 D leaving the user mode; pid = 0:0
16:28:59.297 0 I the process was preempted; pid = 0:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF PF }
16:28:59.307 0 I returned
16:28:59.311 0 I dequeue; pid = Some(1:0)
16:28:59.317 0 I switch to; address_space = &quot;1:0&quot; @ 0p7D61000
16:28:59.321 0 D entering the user mode; pid = 1:0; registers = { rax: 0x0, rdi: 0x10066ED8, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF ZF PF } }
16:28:59.337 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1002D9B1, ss:rsp: 0x001B:0v7F7FFFFFCCE8, rflags: IF }; info = { address: 0v10067020, code: 0b111 = protection violation | write | user }
16:28:59.353 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1002E452, ss:rsp: 0x001B:0v7F7FFFFFCC58, rflags: IF ZF PF }; info = { address: 0v10069BE0, code: 0b111 = protection violation | write | user }
16:28:59.369 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1002545E, ss:rsp: 0x001B:0v7F7FFFFFAFF8, rflags: IF AF }; info = { address: 0v7F7FFFFFAFF0, code: 0b111 = protection violation | write | user }
16:28:59.387 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10039862, ss:rsp: 0x001B:0v7F7FFFFF9FF8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFF9FF0, code: 0b111 = protection violation | write | user }
16:28:59.401 0 D leaving the user mode; pid = 1:0
16:28:59.407 0 I the process was preempted; pid = 1:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF ZF PF }
16:28:59.417 0 I returned
16:28:59.421 0 I dequeue; pid = Some(2:0)
16:28:59.425 0 I switch to; address_space = &quot;2:0&quot; @ 0p7D36000
16:28:59.431 0 D entering the user mode; pid = 2:0; registers = { rax: 0x1, rdi: 0x10067DB8, rsi: 0x1, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF PF } }
16:28:59.447 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015AA7, ss:rsp: 0x001B:0v7F7FFFFFCFC8, rflags: IF AF }; info = { address: 0v7F7FFFFFCFC8, code: 0b111 = protection violation | write | user }
16:28:59.463 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10025184, ss:rsp: 0x001B:0v7F7FFFFFBFD8, rflags: IF AF PF }; info = { address: 0v7F7FFFFFBFE0, code: 0b111 = protection violation | write | user }
16:28:59.185 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 2:0
16:28:59.479 0 I just created; child = &lt;current&gt;; pid = 2:0; pid = 2:0
16:28:59.479 0 I name = &quot;cow_fork *1&quot;; pedigree = [0:0, 2:0]; len = 2; capacity = 3; pid = 2:0
16:28:59.583 0 I page allocator init; free_page_count = 33554432000; block = [0v18000000000, 0v7E8000000000), size 125.000 TiB
16:28:59.593 0 I duplicate; address_space = &quot;process&quot; @ 0p7D42000
16:28:59.597 0 I switch to; address_space = &quot;process&quot; @ 0p7D42000
16:28:59.605 0 I switch to; address_space = &quot;2:0&quot; @ 0p7D36000
16:28:59.609 0 I allocate; slot = Process { pid: 5:0, address_space: &quot;5:0&quot; @ 0p7D42000, { rip: 0v1000AAE7, rsp: 0v7F7FFFFFD0A8 } }; process_count = 6
16:28:59.619 0 I syscall = &quot;exofork&quot;; process = 2:0; child = 5:0
16:28:59.625 0 I syscall::exofork() done; child = Ok(5:0); pid = 2:0
16:28:59.763 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1001318E, ss:rsp: 0x001B:0v7F7FFFFFB598, rflags: IF }; info = { address: 0v7F7FFFFFB680, code: 0b111 = protection violation | write | user }
16:28:59.783 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000D013, ss:rsp: 0x001B:0v7F7FFFFFB7D8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFC318, code: 0b111 = protection violation | write | user }
16:28:59.797 0 D leaving the user mode; pid = 2:0
16:28:59.803 0 I the process was preempted; pid = 2:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF ZF PF }
16:28:59.813 0 I returned
16:28:59.817 0 I dequeue; pid = Some(0:0)
16:28:59.821 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E09000
16:28:59.827 0 D entering the user mode; pid = 0:0; registers = { rax: 0x7F7FFFFFBF00, rdi: 0x7F7FFFFFB940, rsi: 0x7F7FFFFFB540, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF PF } }
16:28:59.843 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10052E60, ss:rsp: 0x001B:0v7F7FFFFF9FE8, rflags: IF AF }; info = { address: 0v7F7FFFFF9FE0, code: 0b111 = protection violation | write | user }
16:28:59.261 0 I copy_address_space done; child = 4:0; trap_stack = [0v7F7FFFFD7000, 0v7F7FFFFDB000), size 16.000 KiB, Page[~127.500 TiB, ~127.500 TiB); pid = 0:0
16:28:59.877 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10013B12, ss:rsp: 0x001B:0v7F7FFFFFD2B8, rflags: IF }; info = { address: 0v10069BB8, code: 0b111 = protection violation | write | user }
16:28:59.891 0 D leaving the user mode; pid = 0:0
16:28:59.895 0 I the process was preempted; pid = 0:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF }
16:28:59.905 0 I returned
16:28:59.909 0 I dequeue; pid = Some(1:0)
16:28:59.915 0 I switch to; address_space = &quot;1:0&quot; @ 0p7D61000
16:28:59.919 0 D entering the user mode; pid = 1:0; registers = { rax: 0x7F7FFFFFA5FE, rdi: 0x7F7FFFFFAB60, rsi: 0x3A, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF ZF PF } }
16:28:59.369 0 I copy_address_space done; child = 3:0; trap_stack = [0v7F7FFFFD7000, 0v7F7FFFFDB000), size 16.000 KiB, Page[~127.500 TiB, ~127.500 TiB); pid = 1:0
16:28:59.953 0 I syscall::set_state(); child = 3:0; result = Ok(()); pid = 1:0
16:29:00.039 0 I page allocator init; free_page_count = 33554432000; block = [0v18000000000, 0v7E8000000000), size 125.000 TiB
16:29:00.049 0 I duplicate; address_space = &quot;process&quot; @ 0p7C91000
16:29:00.055 0 I switch to; address_space = &quot;process&quot; @ 0p7C91000
16:29:00.061 0 I switch to; address_space = &quot;1:0&quot; @ 0p7D61000
16:29:00.067 0 I allocate; slot = Process { pid: 6:0, address_space: &quot;6:0&quot; @ 0p7C91000, { rip: 0v1000AAE7, rsp: 0v7F7FFFFFD0A8 } }; process_count = 7
16:29:00.077 0 I syscall = &quot;exofork&quot;; process = 1:0; child = 6:0
16:29:00.081 0 I syscall::exofork() done; child = Ok(6:0); pid = 1:0
16:29:00.221 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1001318E, ss:rsp: 0x001B:0v7F7FFFFFB598, rflags: IF }; info = { address: 0v7F7FFFFFB680, code: 0b111 = protection violation | write | user }
16:29:00.241 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000D013, ss:rsp: 0x001B:0v7F7FFFFFB7D8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFC318, code: 0b111 = protection violation | write | user }
16:29:00.257 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000D043, ss:rsp: 0x001B:0v7F7FFFFFCA38, rflags: IF SF }; info = { address: 0v7F7FFFFFD000, code: 0b111 = protection violation | write | user }
16:29:00.275 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000B86F, ss:rsp: 0x001B:0v7F7FFFFFD0B8, rflags: IF ZF AF PF CF }; info = { address: 0v7F7FFFFFE030, code: 0b111 = protection violation | write | user }
16:29:00.289 0 D leaving the user mode; pid = 1:0
16:29:00.293 0 I the process was preempted; pid = 1:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF ZF AF PF CF }
16:29:00.307 0 I returned
16:29:00.311 0 I dequeue; pid = Some(2:0)
16:29:00.315 0 I switch to; address_space = &quot;2:0&quot; @ 0p7D36000
16:29:00.321 0 D entering the user mode; pid = 2:0; registers = { rax: 0x7F7FFFFFC318, rdi: 0x0, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF ZF PF } }
16:29:00.337 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000D043, ss:rsp: 0x001B:0v7F7FFFFFCA38, rflags: IF SF }; info = { address: 0v7F7FFFFFD000, code: 0b111 = protection violation | write | user }
16:29:00.353 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000B86F, ss:rsp: 0x001B:0v7F7FFFFFD0B8, rflags: IF ZF AF PF CF }; info = { address: 0v7F7FFFFFE030, code: 0b111 = protection violation | write | user }
16:29:00.371 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10046BD1, ss:rsp: 0x001B:0v7F7FFFFFCDB0, rflags: IF }; info = { address: 0v10067DB8, code: 0b111 = protection violation | write | user }
16:29:00.387 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1002545E, ss:rsp: 0x001B:0v7F7FFFFFAFF8, rflags: IF AF }; info = { address: 0v7F7FFFFFAFF0, code: 0b111 = protection violation | write | user }
16:29:00.403 0 D leaving the user mode; pid = 2:0
16:29:00.407 0 I the process was preempted; pid = 2:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF }
16:29:00.417 0 I returned
16:29:00.421 0 I dequeue; pid = Some(0:0)
16:29:00.425 0 I switch to; address_space = &quot;0:0&quot; @ 0p7E09000
16:29:00.431 0 D entering the user mode; pid = 0:0; registers = { rax: 0x10069BB8, rdi: 0x10069BB8, rsi: 0x1000DAE0, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF } }
16:29:00.447 0 I syscall::set_state(); child = 4:0; result = Ok(()); pid = 0:0
16:29:00.455 0 I free; slot = Process { pid: 0:0, address_space: &quot;0:0&quot; @ 0p7E09000, { rip: 0v10013820, rsp: 0v7F7FFFFDAFC8 } }; process_count = 6
16:29:00.465 0 I switch to; address_space = &quot;base&quot; @ 0p1000
16:29:00.471 0 I drop the current address space; address_space = &quot;0:0&quot; @ 0p7E09000; switch_to = &quot;base&quot; @ 0p1000
16:29:00.529 0 I syscall = &quot;exit&quot;; pid = 0:0; code = 0; reason = Some(OK)
16:29:00.535 0 D leaving the user mode; pid = 0:0
16:29:00.541 0 I dequeue; pid = Some(3:0)
16:29:00.545 0 I switch to; address_space = &quot;3:0&quot; @ 0p7D69000
16:29:00.549 0 D entering the user mode; pid = 3:0; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v1000AAE7, ss:rsp: 0x001B:0v7F7FFFFFD0A8, rflags: IF PF } }
16:29:00.565 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000AAE9, ss:rsp: 0x001B:0v7F7FFFFFD0B8, rflags: IF PF }; info = { address: 0v7F7FFFFFE340, code: 0b111 = protection violation | write | user }
16:29:00.581 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10018677, ss:rsp: 0x001B:0v7F7FFFFDAD68, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFD0B0, code: 0b111 = protection violation | write | user }
16:29:00.595 0 D leaving the user mode; pid = 3:0
16:29:00.601 0 I the process was preempted; pid = 3:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAD30, rflags: IF ZF PF }
16:29:00.611 0 I returned
16:29:00.615 0 I dequeue; pid = Some(1:0)
16:29:00.621 0 I switch to; address_space = &quot;1:0&quot; @ 0p7D61000
16:29:00.625 0 D entering the user mode; pid = 1:0; registers = { rax: 0x10000C68, rdi: 0x7F7FFFFFD4C0, rsi: 0x7F7FFFFFD4E0, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF ZF AF PF CF } }
16:29:00.641 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10046BD1, ss:rsp: 0x001B:0v7F7FFFFFCDB0, rflags: IF }; info = { address: 0v10067DB8, code: 0b111 = protection violation | write | user }
16:29:00.657 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1002545E, ss:rsp: 0x001B:0v7F7FFFFFAFF8, rflags: IF AF }; info = { address: 0v7F7FFFFFAFF0, code: 0b111 = protection violation | write | user }
16:29:00.675 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10039862, ss:rsp: 0x001B:0v7F7FFFFF9FF8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFF9FF0, code: 0b111 = protection violation | write | user }
16:29:00.689 0 D leaving the user mode; pid = 1:0
16:29:00.695 0 I the process was preempted; pid = 1:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF ZF PF }
16:29:00.705 0 I returned
16:29:00.709 0 I dequeue; pid = Some(2:0)
16:29:00.713 0 I switch to; address_space = &quot;2:0&quot; @ 0p7D36000
16:29:00.719 0 D entering the user mode; pid = 2:0; registers = { rax: 0x7EFFFFFFB000, rdi: 0x7F7FFFFFB040, rsi: 0x7EFFFFFFD000, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF } }
16:29:00.735 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10039862, ss:rsp: 0x001B:0v7F7FFFFF9FF8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFF9FF0, code: 0b111 = protection violation | write | user }
16:29:00.371 0 I copy_address_space done; child = 5:0; trap_stack = [0v7F7FFFFD7000, 0v7F7FFFFDB000), size 16.000 KiB, Page[~127.500 TiB, ~127.500 TiB); pid = 2:0
16:29:00.767 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10013B12, ss:rsp: 0x001B:0v7F7FFFFFCDD8, rflags: IF }; info = { address: 0v10069BB8, code: 0b111 = protection violation | write | user }
16:29:00.785 0 I syscall::set_state(); child = 5:0; result = Ok(()); pid = 2:0
16:29:00.873 0 I page allocator init; free_page_count = 33554432000; block = [0v18000000000, 0v7E8000000000), size 125.000 TiB
16:29:00.883 0 I duplicate; address_space = &quot;process&quot; @ 0p7D88000
16:29:00.887 0 I switch to; address_space = &quot;process&quot; @ 0p7D88000
16:29:00.895 0 I switch to; address_space = &quot;2:0&quot; @ 0p7D36000
16:29:00.901 0 I allocate; slot = Process { pid: 0:1, address_space: &quot;0:1&quot; @ 0p7D88000, { rip: 0v1000AAE7, rsp: 0v7F7FFFFFD0A8 } }; process_count = 7
16:29:00.909 0 I syscall = &quot;exofork&quot;; process = 2:0; child = 0:1
16:29:00.915 0 I syscall::exofork() done; child = Ok(0:1); pid = 2:0
16:29:01.053 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1001318E, ss:rsp: 0x001B:0v7F7FFFFFB598, rflags: IF }; info = { address: 0v7F7FFFFFB680, code: 0b111 = protection violation | write | user }
16:29:01.073 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000D013, ss:rsp: 0x001B:0v7F7FFFFFB7D8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFC318, code: 0b111 = protection violation | write | user }
16:29:01.087 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000D043, ss:rsp: 0x001B:0v7F7FFFFFCA38, rflags: IF SF }; info = { address: 0v7F7FFFFFD000, code: 0b111 = protection violation | write | user }
16:29:01.105 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000B86F, ss:rsp: 0x001B:0v7F7FFFFFD0B8, rflags: IF ZF AF PF CF }; info = { address: 0v7F7FFFFFE030, code: 0b111 = protection violation | write | user }
16:29:01.121 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10046BD1, ss:rsp: 0x001B:0v7F7FFFFFCDB0, rflags: IF }; info = { address: 0v10067DB8, code: 0b111 = protection violation | write | user }
16:29:01.137 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1002545E, ss:rsp: 0x001B:0v7F7FFFFFAFF8, rflags: IF AF }; info = { address: 0v7F7FFFFFAFF0, code: 0b111 = protection violation | write | user }
16:29:01.155 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10039862, ss:rsp: 0x001B:0v7F7FFFFF9FF8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFF9FF0, code: 0b111 = protection violation | write | user }
16:29:01.121 0 I copy_address_space done; child = 0:1; trap_stack = [0v7F7FFFFD7000, 0v7F7FFFFDB000), size 16.000 KiB, Page[~127.500 TiB, ~127.500 TiB); pid = 2:0
16:29:01.187 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10013B12, ss:rsp: 0x001B:0v7F7FFFFFCDD8, rflags: IF }; info = { address: 0v10069BB8, code: 0b111 = protection violation | write | user }
16:29:01.201 0 D leaving the user mode; pid = 2:0
16:29:01.207 0 I the process was preempted; pid = 2:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF }
16:29:01.217 0 I returned
16:29:01.221 0 I dequeue; pid = Some(4:0)
16:29:01.225 0 I switch to; address_space = &quot;4:0&quot; @ 0p7CE9000
16:29:01.231 0 D entering the user mode; pid = 4:0; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7EFFFFFFB000, { mode: user, cs:rip: 0x0023:0v1000AAE7, ss:rsp: 0x001B:0v7F7FFFFFD588, rflags: IF AF PF } }
16:29:01.245 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000AAE9, ss:rsp: 0x001B:0v7F7FFFFFD598, rflags: IF AF PF }; info = { address: 0v7F7FFFFFE820, code: 0b111 = protection violation | write | user }
16:29:01.261 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10018677, ss:rsp: 0x001B:0v7F7FFFFDAD68, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFD590, code: 0b111 = protection violation | write | user }
16:29:01.277 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015BD2, ss:rsp: 0x001B:0v7F7FFFFFD478, rflags: IF }; info = { address: 0v10069BC0, code: 0b111 = protection violation | write | user }
16:29:01.291 0 D leaving the user mode; pid = 4:0
16:29:01.297 0 I the process was preempted; pid = 4:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF }
16:29:01.305 0 I returned
16:29:01.311 0 I dequeue; pid = Some(3:0)
16:29:01.315 0 I switch to; address_space = &quot;3:0&quot; @ 0p7D69000
16:29:01.319 0 D entering the user mode; pid = 3:0; registers = { rax: 0x7F7FFFFDAF00, rdi: 0x7F7FFFFDAD90, rsi: 0x7F7FFFFDADB8, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAD30, rflags: IF ZF PF } }
16:29:01.337 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015517, ss:rsp: 0x001B:0v7F7FFFFFCF18, rflags: IF AF PF }; info = { address: 0v7F7FFFFFCF20, code: 0b111 = protection violation | write | user }
16:29:01.353 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015BD2, ss:rsp: 0x001B:0v7F7FFFFFCF98, rflags: IF }; info = { address: 0v10069BC0, code: 0b111 = protection violation | write | user }
16:29:01.369 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10046BD1, ss:rsp: 0x001B:0v7F7FFFFFCDB0, rflags: IF }; info = { address: 0v10067DB8, code: 0b111 = protection violation | write | user }
16:29:01.385 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10020A87, ss:rsp: 0x001B:0v7F7FFFFFBF78, rflags: IF AF PF }; info = { address: 0v7F7FFFFFBF90, code: 0b111 = protection violation | write | user }
16:29:01.401 0 D leaving the user mode; pid = 3:0
16:29:01.405 0 I the process was preempted; pid = 3:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF PF }
16:29:01.415 0 I returned
16:29:01.419 0 I dequeue; pid = Some(1:0)
16:29:01.425 0 I switch to; address_space = &quot;1:0&quot; @ 0p7D61000
16:29:01.429 0 D entering the user mode; pid = 1:0; registers = { rax: 0x7F7FFFFFA5FE, rdi: 0x7F7FFFFFAB60, rsi: 0x3A, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF ZF PF } }
16:29:00.639 0 I copy_address_space done; child = 6:0; trap_stack = [0v7F7FFFFD7000, 0v7F7FFFFDB000), size 16.000 KiB, Page[~127.500 TiB, ~127.500 TiB); pid = 1:0
16:29:01.463 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10013B12, ss:rsp: 0x001B:0v7F7FFFFFCDD8, rflags: IF }; info = { address: 0v10069BB8, code: 0b111 = protection violation | write | user }
16:29:01.479 0 I syscall::set_state(); child = 6:0; result = Ok(()); pid = 1:0
16:29:01.569 0 I page allocator init; free_page_count = 33554432000; block = [0v18000000000, 0v7E8000000000), size 125.000 TiB
16:29:01.579 0 I duplicate; address_space = &quot;process&quot; @ 0p7C52000
16:29:01.583 0 I switch to; address_space = &quot;process&quot; @ 0p7C52000
16:29:01.591 0 I switch to; address_space = &quot;1:0&quot; @ 0p7D61000
16:29:01.595 0 I allocate; slot = Process { pid: 7:0, address_space: &quot;7:0&quot; @ 0p7C52000, { rip: 0v1000AAE7, rsp: 0v7F7FFFFFD0A8 } }; process_count = 8
16:29:01.605 0 I syscall = &quot;exofork&quot;; process = 1:0; child = 7:0
16:29:01.611 0 I syscall::exofork() done; child = Ok(7:0); pid = 1:0
16:29:01.751 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1001318E, ss:rsp: 0x001B:0v7F7FFFFFB598, rflags: IF }; info = { address: 0v7F7FFFFFB680, code: 0b111 = protection violation | write | user }
16:29:01.771 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000D013, ss:rsp: 0x001B:0v7F7FFFFFB7D8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFC318, code: 0b111 = protection violation | write | user }
16:29:01.787 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000D043, ss:rsp: 0x001B:0v7F7FFFFFCA38, rflags: IF SF }; info = { address: 0v7F7FFFFFD000, code: 0b111 = protection violation | write | user }
16:29:01.801 0 D leaving the user mode; pid = 1:0
16:29:01.807 0 I the process was preempted; pid = 1:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF SF }
16:29:01.817 0 I returned
16:29:01.821 0 I dequeue; pid = Some(5:0)
16:29:01.825 0 I switch to; address_space = &quot;5:0&quot; @ 0p7D42000
16:29:01.829 0 D entering the user mode; pid = 5:0; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v1000AAE7, ss:rsp: 0x001B:0v7F7FFFFFD0A8, rflags: IF PF } }
16:29:01.845 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000AAE9, ss:rsp: 0x001B:0v7F7FFFFFD0B8, rflags: IF PF }; info = { address: 0v7F7FFFFFE340, code: 0b111 = protection violation | write | user }
16:29:01.861 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10018677, ss:rsp: 0x001B:0v7F7FFFFDAD68, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFD0B0, code: 0b111 = protection violation | write | user }
16:29:01.877 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015517, ss:rsp: 0x001B:0v7F7FFFFFCF18, rflags: IF AF PF }; info = { address: 0v7F7FFFFFCF20, code: 0b111 = protection violation | write | user }
16:29:01.893 0 D leaving the user mode; pid = 5:0
16:29:01.897 0 I the process was preempted; pid = 5:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF PF }
16:29:01.907 0 I returned
16:29:01.913 0 I dequeue; pid = Some(2:0)
16:29:01.917 0 I switch to; address_space = &quot;2:0&quot; @ 0p7D36000
16:29:01.921 0 D entering the user mode; pid = 2:0; registers = { rax: 0x10069BB8, rdi: 0x10069BB8, rsi: 0x1000DAE0, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF } }
16:29:01.937 0 I syscall::set_state(); child = 0:1; result = Ok(()); pid = 2:0
16:29:02.027 0 I page allocator init; free_page_count = 33554432000; block = [0v18000000000, 0v7E8000000000), size 125.000 TiB
16:29:02.037 0 I duplicate; address_space = &quot;process&quot; @ 0p7CC4000
16:29:02.041 0 I switch to; address_space = &quot;process&quot; @ 0p7CC4000
16:29:02.047 0 I switch to; address_space = &quot;2:0&quot; @ 0p7D36000
16:29:02.053 0 I allocate; slot = Process { pid: 8:0, address_space: &quot;8:0&quot; @ 0p7CC4000, { rip: 0v1000AAE7, rsp: 0v7F7FFFFFD0A8 } }; process_count = 9
16:29:02.063 0 I syscall = &quot;exofork&quot;; process = 2:0; child = 8:0
16:29:02.069 0 I syscall::exofork() done; child = Ok(8:0); pid = 2:0
16:29:02.209 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1001318E, ss:rsp: 0x001B:0v7F7FFFFFB598, rflags: IF }; info = { address: 0v7F7FFFFFB680, code: 0b111 = protection violation | write | user }
16:29:02.227 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000D013, ss:rsp: 0x001B:0v7F7FFFFFB7D8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFC318, code: 0b111 = protection violation | write | user }
16:29:02.243 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000D043, ss:rsp: 0x001B:0v7F7FFFFFCA38, rflags: IF SF }; info = { address: 0v7F7FFFFFD000, code: 0b111 = protection violation | write | user }
16:29:02.259 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000B86F, ss:rsp: 0x001B:0v7F7FFFFFD0B8, rflags: IF ZF AF PF CF }; info = { address: 0v7F7FFFFFE030, code: 0b111 = protection violation | write | user }
16:29:02.275 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10046BD1, ss:rsp: 0x001B:0v7F7FFFFFCDB0, rflags: IF }; info = { address: 0v10067DB8, code: 0b111 = protection violation | write | user }
16:29:02.289 0 D leaving the user mode; pid = 2:0
16:29:02.295 0 I the process was preempted; pid = 2:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF }
16:29:02.305 0 I returned
16:29:02.309 0 I dequeue; pid = Some(4:0)
16:29:02.313 0 I switch to; address_space = &quot;4:0&quot; @ 0p7CE9000
16:29:02.319 0 D entering the user mode; pid = 4:0; registers = { rax: 0x10069BC0, rdi: 0x10069BC0, rsi: 0x7EFFFFFFB000, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF } }
16:29:02.335 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10046BD1, ss:rsp: 0x001B:0v7F7FFFFFD290, rflags: IF PF }; info = { address: 0v10067DB8, code: 0b111 = protection violation | write | user }
16:29:02.351 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015AA7, ss:rsp: 0x001B:0v7F7FFFFFCFC8, rflags: IF AF }; info = { address: 0v7F7FFFFFCFC8, code: 0b111 = protection violation | write | user }
16:29:02.367 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10025184, ss:rsp: 0x001B:0v7F7FFFFFBFD8, rflags: IF AF PF }; info = { address: 0v7F7FFFFFBFE0, code: 0b111 = protection violation | write | user }
16:29:02.335 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 4:0
16:29:02.383 0 I just created; child = &lt;current&gt;; pid = 4:0; pid = 4:0
16:29:02.385 0 I name = &quot;cow_fork *2&quot;; pedigree = [0:0, 4:0]; len = 2; capacity = 3; pid = 4:0
16:29:02.493 0 I page allocator init; free_page_count = 33554432000; block = [0v18000000000, 0v7E8000000000), size 125.000 TiB
16:29:02.503 0 I duplicate; address_space = &quot;process&quot; @ 0p7D16000
16:29:02.507 0 I switch to; address_space = &quot;process&quot; @ 0p7D16000
16:29:02.515 0 I switch to; address_space = &quot;4:0&quot; @ 0p7CE9000
16:29:02.519 0 I allocate; slot = Process { pid: 9:0, address_space: &quot;9:0&quot; @ 0p7D16000, { rip: 0v1000AAE7, rsp: 0v7F7FFFFFD0A8 } }; process_count = 10
16:29:02.529 0 I syscall = &quot;exofork&quot;; process = 4:0; child = 9:0
16:29:02.535 0 I syscall::exofork() done; child = Ok(9:0); pid = 4:0
16:29:02.589 0 D leaving the user mode; pid = 4:0
16:29:02.593 0 I the process was preempted; pid = 4:0; user_context = { mode: user, cs:rip: 0x0023:0v1002135E, ss:rsp: 0x001B:0v7F7FFFFFB408, rflags: IF AF }
16:29:02.603 0 I returned
16:29:02.607 0 I dequeue; pid = Some(3:0)
16:29:02.611 0 I switch to; address_space = &quot;3:0&quot; @ 0p7D69000
16:29:02.617 0 D entering the user mode; pid = 3:0; registers = { rax: 0x7F7FFFFFCC80, rdi: 0x7E7FFFFFB000, rsi: 0x7F7FFFFFCC80, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF PF } }
16:29:01.367 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 3:0
16:29:02.633 0 I just created; child = &lt;current&gt;; pid = 3:0; pid = 3:0
16:29:02.635 0 I name = &quot;cow_fork *00&quot;; pedigree = [0:0, 1:0, 3:0]; len = 3; capacity = 3; pid = 3:0
16:29:02.655 0 I free; slot = Process { pid: 3:0, address_space: &quot;3:0&quot; @ 0p7D69000, { rip: 0v10013820, rsp: 0v7F7FFFFDAFC8 } }; process_count = 9
16:29:02.665 0 I switch to; address_space = &quot;base&quot; @ 0p1000
16:29:02.671 0 I drop the current address space; address_space = &quot;3:0&quot; @ 0p7D69000; switch_to = &quot;base&quot; @ 0p1000
16:29:02.735 0 I syscall = &quot;exit&quot;; pid = 3:0; code = 0; reason = Some(OK)
16:29:02.741 0 D leaving the user mode; pid = 3:0
16:29:02.745 0 I dequeue; pid = Some(6:0)
16:29:02.749 0 I switch to; address_space = &quot;6:0&quot; @ 0p7C91000
16:29:02.755 0 D entering the user mode; pid = 6:0; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v1000AAE7, ss:rsp: 0x001B:0v7F7FFFFFD0A8, rflags: IF ZF PF } }
16:29:02.769 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000AAE9, ss:rsp: 0x001B:0v7F7FFFFFD0B8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFE340, code: 0b111 = protection violation | write | user }
16:29:02.787 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10018677, ss:rsp: 0x001B:0v7F7FFFFDAD68, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFD0B0, code: 0b111 = protection violation | write | user }
16:29:02.801 0 D leaving the user mode; pid = 6:0
16:29:02.805 0 I the process was preempted; pid = 6:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAD30, rflags: IF ZF PF }
16:29:02.815 0 I returned
16:29:02.819 0 I dequeue; pid = Some(1:0)
16:29:02.825 0 I switch to; address_space = &quot;1:0&quot; @ 0p7D61000
16:29:02.829 0 D entering the user mode; pid = 1:0; registers = { rax: 0xFF, rdi: 0xFFFFFFFFFFFFF7F8, rsi: 0x100, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF SF } }
16:29:02.845 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000B86F, ss:rsp: 0x001B:0v7F7FFFFFD0B8, rflags: IF ZF AF PF CF }; info = { address: 0v7F7FFFFFE030, code: 0b111 = protection violation | write | user }
16:29:02.863 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10046BD1, ss:rsp: 0x001B:0v7F7FFFFFCDB0, rflags: IF }; info = { address: 0v10067DB8, code: 0b111 = protection violation | write | user }
16:29:02.879 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1002545E, ss:rsp: 0x001B:0v7F7FFFFFAFF8, rflags: IF AF }; info = { address: 0v7F7FFFFFAFF0, code: 0b111 = protection violation | write | user }
16:29:02.895 0 D leaving the user mode; pid = 1:0
16:29:02.899 0 I the process was preempted; pid = 1:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF }
16:29:02.909 0 I returned
16:29:02.913 0 I dequeue; pid = Some(5:0)
16:29:02.917 0 I switch to; address_space = &quot;5:0&quot; @ 0p7D42000
16:29:02.923 0 D entering the user mode; pid = 5:0; registers = { rax: 0x0, rdi: 0x7F7FFFFFE358, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF PF } }
16:29:02.939 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015BD2, ss:rsp: 0x001B:0v7F7FFFFFCF98, rflags: IF }; info = { address: 0v10069BC0, code: 0b111 = protection violation | write | user }
16:29:02.955 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10046BD1, ss:rsp: 0x001B:0v7F7FFFFFCDB0, rflags: IF }; info = { address: 0v10067DB8, code: 0b111 = protection violation | write | user }
16:29:02.971 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10020A87, ss:rsp: 0x001B:0v7F7FFFFFBF78, rflags: IF AF PF }; info = { address: 0v7F7FFFFFBF90, code: 0b111 = protection violation | write | user }
16:29:02.989 0 D leaving the user mode; pid = 5:0
16:29:02.995 0 I the process was preempted; pid = 5:0; user_context = { mode: user, cs:rip: 0x0023:0v100537B0, ss:rsp: 0x001B:0v7F7FFFFFC920, rflags: IF AF PF }
16:29:03.003 0 I returned
16:29:03.005 0 I dequeue; pid = Some(0:1)
16:29:03.009 0 I switch to; address_space = &quot;0:1&quot; @ 0p7D88000
16:29:03.013 0 D entering the user mode; pid = 0:1; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v1000AAE7, ss:rsp: 0x001B:0v7F7FFFFFD0A8, rflags: IF AF } }
16:29:03.027 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000AAE9, ss:rsp: 0x001B:0v7F7FFFFFD0B8, rflags: IF AF }; info = { address: 0v7F7FFFFFE340, code: 0b111 = protection violation | write | user }
16:29:03.045 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10018677, ss:rsp: 0x001B:0v7F7FFFFDAD68, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFD0B0, code: 0b111 = protection violation | write | user }
16:29:03.061 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015517, ss:rsp: 0x001B:0v7F7FFFFFCF18, rflags: IF AF PF }; info = { address: 0v7F7FFFFFCF20, code: 0b111 = protection violation | write | user }
16:29:03.077 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015BD2, ss:rsp: 0x001B:0v7F7FFFFFCF98, rflags: IF }; info = { address: 0v10069BC0, code: 0b111 = protection violation | write | user }
16:29:03.091 0 D leaving the user mode; pid = 0:1
16:29:03.097 0 I the process was preempted; pid = 0:1; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF }
16:29:03.107 0 I returned
16:29:03.111 0 I dequeue; pid = Some(2:0)
16:29:03.115 0 I switch to; address_space = &quot;2:0&quot; @ 0p7D36000
16:29:03.121 0 D entering the user mode; pid = 2:0; registers = { rax: 0x1, rdi: 0x10067DB8, rsi: 0x1, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF } }
16:29:03.137 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1002545E, ss:rsp: 0x001B:0v7F7FFFFFAFF8, rflags: IF AF }; info = { address: 0v7F7FFFFFAFF0, code: 0b111 = protection violation | write | user }
16:29:03.153 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10039862, ss:rsp: 0x001B:0v7F7FFFFF9FF8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFF9FF0, code: 0b111 = protection violation | write | user }
16:29:02.271 0 I copy_address_space done; child = 8:0; trap_stack = [0v7F7FFFFD7000, 0v7F7FFFFDB000), size 16.000 KiB, Page[~127.500 TiB, ~127.500 TiB); pid = 2:0
16:29:03.187 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10013B12, ss:rsp: 0x001B:0v7F7FFFFFCDD8, rflags: IF }; info = { address: 0v10069BB8, code: 0b111 = protection violation | write | user }
16:29:03.203 0 I syscall::set_state(); child = 8:0; result = Ok(()); pid = 2:0
16:29:03.211 0 I free; slot = Process { pid: 2:0, address_space: &quot;2:0&quot; @ 0p7D36000, { rip: 0v10013820, rsp: 0v7F7FFFFDAFC8 } }; process_count = 8
16:29:03.219 0 I switch to; address_space = &quot;base&quot; @ 0p1000
16:29:03.225 0 I drop the current address space; address_space = &quot;2:0&quot; @ 0p7D36000; switch_to = &quot;base&quot; @ 0p1000
16:29:03.287 0 I syscall = &quot;exit&quot;; pid = 2:0; code = 0; reason = Some(OK)
16:29:03.291 0 D leaving the user mode; pid = 2:0
16:29:03.297 0 I dequeue; pid = Some(4:0)
16:29:03.301 0 I switch to; address_space = &quot;4:0&quot; @ 0p7CE9000
16:29:03.305 0 D entering the user mode; pid = 4:0; registers = { rax: 0x7EFFFFFFB000, rdi: 0x7F7FFFFFB438, rsi: 0x7EFFFFFFB000, { mode: user, cs:rip: 0x0023:0v1002135E, ss:rsp: 0x001B:0v7F7FFFFFB408, rflags: IF AF } }
16:29:03.411 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1001318E, ss:rsp: 0x001B:0v7F7FFFFFB598, rflags: IF }; info = { address: 0v7F7FFFFFB680, code: 0b111 = protection violation | write | user }
16:29:03.431 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000D013, ss:rsp: 0x001B:0v7F7FFFFFB7D8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFC318, code: 0b111 = protection violation | write | user }
16:29:03.447 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000D043, ss:rsp: 0x001B:0v7F7FFFFFCA38, rflags: IF SF }; info = { address: 0v7F7FFFFFD000, code: 0b111 = protection violation | write | user }
16:29:03.463 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000B86F, ss:rsp: 0x001B:0v7F7FFFFFD0B8, rflags: IF ZF AF PF CF }; info = { address: 0v7F7FFFFFE030, code: 0b111 = protection violation | write | user }
16:29:03.479 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10046BD1, ss:rsp: 0x001B:0v7F7FFFFFCDB0, rflags: IF }; info = { address: 0v10067DB8, code: 0b111 = protection violation | write | user }
16:29:03.493 0 D leaving the user mode; pid = 4:0
16:29:03.499 0 I the process was preempted; pid = 4:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF }
16:29:03.509 0 I returned
16:29:03.513 0 I dequeue; pid = Some(6:0)
16:29:03.517 0 I switch to; address_space = &quot;6:0&quot; @ 0p7C91000
16:29:03.523 0 D entering the user mode; pid = 6:0; registers = { rax: 0x7F7FFFFDAF00, rdi: 0x7F7FFFFDAD90, rsi: 0x7F7FFFFDADB8, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAD30, rflags: IF ZF PF } }
16:29:03.539 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015517, ss:rsp: 0x001B:0v7F7FFFFFCF18, rflags: IF AF PF }; info = { address: 0v7F7FFFFFCF20, code: 0b111 = protection violation | write | user }
16:29:03.555 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015BD2, ss:rsp: 0x001B:0v7F7FFFFFCF98, rflags: IF }; info = { address: 0v10069BC0, code: 0b111 = protection violation | write | user }
16:29:03.569 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10046BD1, ss:rsp: 0x001B:0v7F7FFFFFCDB0, rflags: IF }; info = { address: 0v10067DB8, code: 0b111 = protection violation | write | user }
16:29:03.585 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10020A87, ss:rsp: 0x001B:0v7F7FFFFFBF78, rflags: IF AF PF }; info = { address: 0v7F7FFFFFBF90, code: 0b111 = protection violation | write | user }
16:29:03.569 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 6:0
16:29:03.603 0 I just created; child = &lt;current&gt;; pid = 6:0; pid = 6:0
16:29:03.603 0 I name = &quot;cow_fork *01&quot;; pedigree = [0:0, 1:0, 6:0]; len = 3; capacity = 3; pid = 6:0
16:29:03.625 0 I free; slot = Process { pid: 6:0, address_space: &quot;6:0&quot; @ 0p7C91000, { rip: 0v10013820, rsp: 0v7F7FFFFDAD30 } }; process_count = 7
16:29:03.635 0 I switch to; address_space = &quot;base&quot; @ 0p1000
16:29:03.639 0 I drop the current address space; address_space = &quot;6:0&quot; @ 0p7C91000; switch_to = &quot;base&quot; @ 0p1000
16:29:03.705 0 I syscall = &quot;exit&quot;; pid = 6:0; code = 0; reason = Some(OK)
16:29:03.709 0 D leaving the user mode; pid = 6:0
16:29:03.715 0 I dequeue; pid = Some(1:0)
16:29:03.719 0 I switch to; address_space = &quot;1:0&quot; @ 0p7D61000
16:29:03.723 0 D entering the user mode; pid = 1:0; registers = { rax: 0x7EFFFFFFB000, rdi: 0x7F7FFFFFB040, rsi: 0x7EFFFFFFD000, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF } }
16:29:03.741 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10039862, ss:rsp: 0x001B:0v7F7FFFFF9FF8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFF9FF0, code: 0b111 = protection violation | write | user }
16:29:02.859 0 I copy_address_space done; child = 7:0; trap_stack = [0v7F7FFFFD7000, 0v7F7FFFFDB000), size 16.000 KiB, Page[~127.500 TiB, ~127.500 TiB); pid = 1:0
16:29:03.773 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10013B12, ss:rsp: 0x001B:0v7F7FFFFFCDD8, rflags: IF }; info = { address: 0v10069BB8, code: 0b111 = protection violation | write | user }
16:29:03.787 0 D leaving the user mode; pid = 1:0
16:29:03.793 0 I the process was preempted; pid = 1:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF }
16:29:03.803 0 I returned
16:29:03.807 0 I dequeue; pid = Some(5:0)
16:29:03.811 0 I switch to; address_space = &quot;5:0&quot; @ 0p7D42000
16:29:03.817 0 D entering the user mode; pid = 5:0; registers = { rax: 0x9E, rdi: 0x9D, rsi: 0x9E, { mode: user, cs:rip: 0x0023:0v100537B0, ss:rsp: 0x001B:0v7F7FFFFFC920, rflags: IF AF PF } }
16:29:02.951 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 5:0
16:29:02.985 0 I just created; child = &lt;current&gt;; pid = 5:0; pid = 5:0
16:29:03.831 0 I name = &quot;cow_fork *10&quot;; pedigree = [0:0, 2:0, 5:0]; len = 3; capacity = 3; pid = 5:0
16:29:03.853 0 I free; slot = Process { pid: 5:0, address_space: &quot;5:0&quot; @ 0p7D42000, { rip: 0v100537B0, rsp: 0v7F7FFFFFC920 } }; process_count = 6
16:29:03.863 0 I switch to; address_space = &quot;base&quot; @ 0p1000
16:29:03.867 0 I drop the current address space; address_space = &quot;5:0&quot; @ 0p7D42000; switch_to = &quot;base&quot; @ 0p1000
16:29:03.931 0 I syscall = &quot;exit&quot;; pid = 5:0; code = 0; reason = Some(OK)
16:29:03.937 0 D leaving the user mode; pid = 5:0
16:29:03.943 0 I dequeue; pid = Some(0:1)
16:29:03.947 0 I switch to; address_space = &quot;0:1&quot; @ 0p7D88000
16:29:03.953 0 D entering the user mode; pid = 0:1; registers = { rax: 0x10069BC0, rdi: 0x10069BC0, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF } }
16:29:03.969 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10046BD1, ss:rsp: 0x001B:0v7F7FFFFFCDB0, rflags: IF }; info = { address: 0v10067DB8, code: 0b111 = protection violation | write | user }
16:29:03.985 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10020A87, ss:rsp: 0x001B:0v7F7FFFFFBF78, rflags: IF AF PF }; info = { address: 0v7F7FFFFFBF90, code: 0b111 = protection violation | write | user }
16:29:04.001 0 D leaving the user mode; pid = 0:1
16:29:04.005 0 I the process was preempted; pid = 0:1; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF PF }
16:29:04.015 0 I returned
16:29:04.019 0 I dequeue; pid = Some(8:0)
16:29:04.023 0 I switch to; address_space = &quot;8:0&quot; @ 0p7CC4000
16:29:04.029 0 D entering the user mode; pid = 8:0; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v1000AAE7, ss:rsp: 0x001B:0v7F7FFFFFD0A8, rflags: IF } }
16:29:04.043 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000AAE9, ss:rsp: 0x001B:0v7F7FFFFFD0B8, rflags: IF }; info = { address: 0v7F7FFFFFE340, code: 0b111 = protection violation | write | user }
16:29:04.059 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10018677, ss:rsp: 0x001B:0v7F7FFFFDAD68, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFD0B0, code: 0b111 = protection violation | write | user }
16:29:04.077 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015517, ss:rsp: 0x001B:0v7F7FFFFFCF18, rflags: IF AF PF }; info = { address: 0v7F7FFFFFCF20, code: 0b111 = protection violation | write | user }
16:29:04.091 0 D leaving the user mode; pid = 8:0
16:29:04.095 0 I the process was preempted; pid = 8:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF PF }
16:29:04.105 0 I returned
16:29:04.109 0 I dequeue; pid = Some(4:0)
16:29:04.115 0 I switch to; address_space = &quot;4:0&quot; @ 0p7CE9000
16:29:04.119 0 D entering the user mode; pid = 4:0; registers = { rax: 0x1, rdi: 0x10067DB8, rsi: 0x1, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF } }
16:29:04.135 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1002545E, ss:rsp: 0x001B:0v7F7FFFFFAFF8, rflags: IF AF }; info = { address: 0v7F7FFFFFAFF0, code: 0b111 = protection violation | write | user }
16:29:04.153 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10039862, ss:rsp: 0x001B:0v7F7FFFFF9FF8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFF9FF0, code: 0b111 = protection violation | write | user }
16:29:03.479 0 I copy_address_space done; child = 9:0; trap_stack = [0v7F7FFFFD7000, 0v7F7FFFFDB000), size 16.000 KiB, Page[~127.500 TiB, ~127.500 TiB); pid = 4:0
16:29:04.185 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10013B12, ss:rsp: 0x001B:0v7F7FFFFFCDD8, rflags: IF }; info = { address: 0v10069BB8, code: 0b111 = protection violation | write | user }
16:29:04.201 0 D leaving the user mode; pid = 4:0
16:29:04.205 0 I the process was preempted; pid = 4:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF }
16:29:04.215 0 I returned
16:29:04.219 0 I dequeue; pid = Some(1:0)
16:29:04.223 0 I switch to; address_space = &quot;1:0&quot; @ 0p7D61000
16:29:04.229 0 D entering the user mode; pid = 1:0; registers = { rax: 0x10069BB8, rdi: 0x10069BB8, rsi: 0x1000DAE0, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF } }
16:29:04.245 0 I syscall::set_state(); child = 7:0; result = Ok(()); pid = 1:0
16:29:04.251 0 I free; slot = Process { pid: 1:0, address_space: &quot;1:0&quot; @ 0p7D61000, { rip: 0v10013820, rsp: 0v7F7FFFFDAFC8 } }; process_count = 5
16:29:04.261 0 I switch to; address_space = &quot;base&quot; @ 0p1000
16:29:04.267 0 I drop the current address space; address_space = &quot;1:0&quot; @ 0p7D61000; switch_to = &quot;base&quot; @ 0p1000
16:29:04.327 0 I syscall = &quot;exit&quot;; pid = 1:0; code = 0; reason = Some(OK)
16:29:04.333 0 D leaving the user mode; pid = 1:0
16:29:04.337 0 I dequeue; pid = Some(0:1)
16:29:04.343 0 I switch to; address_space = &quot;0:1&quot; @ 0p7D88000
16:29:04.347 0 D entering the user mode; pid = 0:1; registers = { rax: 0x7F7FFFFFCC80, rdi: 0x7E7FFFFFB000, rsi: 0x7F7FFFFFCC80, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF PF } }
16:29:03.969 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 0:1
16:29:04.363 0 I just created; child = &lt;current&gt;; pid = 0:1; pid = 0:1
16:29:04.365 0 I name = &quot;cow_fork *11&quot;; pedigree = [0:0, 2:0, 0:1]; len = 3; capacity = 3; pid = 0:1
16:29:04.387 0 I free; slot = Process { pid: 0:1, address_space: &quot;0:1&quot; @ 0p7D88000, { rip: 0v10013820, rsp: 0v7F7FFFFDAFC8 } }; process_count = 4
16:29:04.397 0 I switch to; address_space = &quot;base&quot; @ 0p1000
16:29:04.401 0 I drop the current address space; address_space = &quot;0:1&quot; @ 0p7D88000; switch_to = &quot;base&quot; @ 0p1000
16:29:04.465 0 I syscall = &quot;exit&quot;; pid = 0:1; code = 0; reason = Some(OK)
16:29:04.471 0 D leaving the user mode; pid = 0:1
16:29:04.475 0 I dequeue; pid = Some(8:0)
16:29:04.481 0 I switch to; address_space = &quot;8:0&quot; @ 0p7CC4000
16:29:04.485 0 D entering the user mode; pid = 8:0; registers = { rax: 0x0, rdi: 0x7F7FFFFFE358, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF PF } }
16:29:04.499 0 D leaving the user mode; pid = 8:0
16:29:04.505 0 I the process was preempted; pid = 8:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF PF }
16:29:04.515 0 I returned
16:29:04.519 0 I dequeue; pid = Some(4:0)
16:29:04.523 0 I switch to; address_space = &quot;4:0&quot; @ 0p7CE9000
16:29:04.527 0 D entering the user mode; pid = 4:0; registers = { rax: 0x10069BB8, rdi: 0x10069BB8, rsi: 0x1000DAE0, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF } }
16:29:04.543 0 I syscall::set_state(); child = 9:0; result = Ok(()); pid = 4:0
16:29:04.633 0 I page allocator init; free_page_count = 33554432000; block = [0v18000000000, 0v7E8000000000), size 125.000 TiB
16:29:04.643 0 I duplicate; address_space = &quot;process&quot; @ 0p7DF3000
16:29:04.649 0 I switch to; address_space = &quot;process&quot; @ 0p7DF3000
16:29:04.655 0 I switch to; address_space = &quot;4:0&quot; @ 0p7CE9000
16:29:04.661 0 I allocate; slot = Process { pid: 0:2, address_space: &quot;0:2&quot; @ 0p7DF3000, { rip: 0v1000AAE7, rsp: 0v7F7FFFFFD0A8 } }; process_count = 5
16:29:04.669 0 I syscall = &quot;exofork&quot;; process = 4:0; child = 0:2
16:29:04.675 0 I syscall::exofork() done; child = Ok(0:2); pid = 4:0
16:29:04.687 0 D leaving the user mode; pid = 4:0
16:29:04.691 0 I the process was preempted; pid = 4:0; user_context = { mode: user, cs:rip: 0x0023:0v1005EB70, ss:rsp: 0x001B:0v7F7FFFFFB690, rflags: IF AF }
16:29:04.701 0 I returned
16:29:04.707 0 I dequeue; pid = Some(7:0)
16:29:04.711 0 I switch to; address_space = &quot;7:0&quot; @ 0p7C52000
16:29:04.715 0 D entering the user mode; pid = 7:0; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v1000AAE7, ss:rsp: 0x001B:0v7F7FFFFFD0A8, rflags: IF ZF PF } }
16:29:04.731 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000AAE9, ss:rsp: 0x001B:0v7F7FFFFFD0B8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFE340, code: 0b111 = protection violation | write | user }
16:29:04.747 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10018677, ss:rsp: 0x001B:0v7F7FFFFDAD68, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFD0B0, code: 0b111 = protection violation | write | user }
16:29:04.763 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015517, ss:rsp: 0x001B:0v7F7FFFFFCF18, rflags: IF AF PF }; info = { address: 0v7F7FFFFFCF20, code: 0b111 = protection violation | write | user }
16:29:04.779 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015BD2, ss:rsp: 0x001B:0v7F7FFFFFCF98, rflags: IF }; info = { address: 0v10069BC0, code: 0b111 = protection violation | write | user }
16:29:04.793 0 D leaving the user mode; pid = 7:0
16:29:04.799 0 I the process was preempted; pid = 7:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF }
16:29:04.809 0 I returned
16:29:04.813 0 I dequeue; pid = Some(8:0)
16:29:04.817 0 I switch to; address_space = &quot;8:0&quot; @ 0p7CC4000
16:29:04.823 0 D entering the user mode; pid = 8:0; registers = { rax: 0x0, rdi: 0x7F7FFFFFE358, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF PF } }
16:29:04.839 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015BD2, ss:rsp: 0x001B:0v7F7FFFFFCF98, rflags: IF }; info = { address: 0v10069BC0, code: 0b111 = protection violation | write | user }
16:29:04.855 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10046BD1, ss:rsp: 0x001B:0v7F7FFFFFCDB0, rflags: IF }; info = { address: 0v10067DB8, code: 0b111 = protection violation | write | user }
16:29:04.871 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10020A87, ss:rsp: 0x001B:0v7F7FFFFFBF78, rflags: IF AF PF }; info = { address: 0v7F7FFFFFBF90, code: 0b111 = protection violation | write | user }
16:29:04.887 0 D leaving the user mode; pid = 8:0
16:29:04.893 0 I the process was preempted; pid = 8:0; user_context = { mode: user, cs:rip: 0x0023:0v10016490, ss:rsp: 0x001B:0v7F7FFFFFC760, rflags: IF AF }
16:29:04.903 0 I returned
16:29:04.907 0 I dequeue; pid = Some(9:0)
16:29:04.911 0 I switch to; address_space = &quot;9:0&quot; @ 0p7D16000
16:29:04.917 0 D entering the user mode; pid = 9:0; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v1000AAE7, ss:rsp: 0x001B:0v7F7FFFFFD0A8, rflags: IF } }
16:29:04.931 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000AAE9, ss:rsp: 0x001B:0v7F7FFFFFD0B8, rflags: IF }; info = { address: 0v7F7FFFFFE340, code: 0b111 = protection violation | write | user }
16:29:04.947 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10018677, ss:rsp: 0x001B:0v7F7FFFFDAD68, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFD0B0, code: 0b111 = protection violation | write | user }
16:29:04.963 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015517, ss:rsp: 0x001B:0v7F7FFFFFCF18, rflags: IF AF PF }; info = { address: 0v7F7FFFFFCF20, code: 0b111 = protection violation | write | user }
16:29:04.979 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015BD2, ss:rsp: 0x001B:0v7F7FFFFFCF98, rflags: IF }; info = { address: 0v10069BC0, code: 0b111 = protection violation | write | user }
16:29:04.993 0 D leaving the user mode; pid = 9:0
16:29:04.999 0 I the process was preempted; pid = 9:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF }
16:29:05.009 0 I returned
16:29:05.005 0 I dequeue; pid = Some(4:0)
16:29:05.009 0 I switch to; address_space = &quot;4:0&quot; @ 0p7CE9000
16:29:05.015 0 D entering the user mode; pid = 4:0; registers = { rax: 0xFFFFFF8000080028, rdi: 0x0, rsi: 0x7F7FFFFFBBD8, { mode: user, cs:rip: 0x0023:0v1005EB70, ss:rsp: 0x001B:0v7F7FFFFFB690, rflags: IF AF } }
16:29:05.159 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1001318E, ss:rsp: 0x001B:0v7F7FFFFFB598, rflags: IF }; info = { address: 0v7F7FFFFFB680, code: 0b111 = protection violation | write | user }
16:29:05.177 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000D013, ss:rsp: 0x001B:0v7F7FFFFFB7D8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFC318, code: 0b111 = protection violation | write | user }
16:29:05.193 0 D leaving the user mode; pid = 4:0
16:29:05.197 0 I the process was preempted; pid = 4:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF ZF PF }
16:29:05.207 0 I returned
16:29:05.211 0 I dequeue; pid = Some(7:0)
16:29:05.217 0 I switch to; address_space = &quot;7:0&quot; @ 0p7C52000
16:29:05.221 0 D entering the user mode; pid = 7:0; registers = { rax: 0x10069BC0, rdi: 0x10069BC0, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF } }
16:29:05.237 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10046BD1, ss:rsp: 0x001B:0v7F7FFFFFCDB0, rflags: IF }; info = { address: 0v10067DB8, code: 0b111 = protection violation | write | user }
16:29:05.255 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10020A87, ss:rsp: 0x001B:0v7F7FFFFFBF78, rflags: IF AF PF }; info = { address: 0v7F7FFFFFBF90, code: 0b111 = protection violation | write | user }
16:29:05.237 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 7:0
16:29:05.271 0 I just created; child = &lt;current&gt;; pid = 7:0; pid = 7:0
16:29:05.271 0 I name = &quot;cow_fork *02&quot;; pedigree = [0:0, 1:0, 7:0]; len = 3; capacity = 3; pid = 7:0
16:29:05.293 0 I free; slot = Process { pid: 7:0, address_space: &quot;7:0&quot; @ 0p7C52000, { rip: 0v10013820, rsp: 0v7F7FFFFDAFC8 } }; process_count = 4
16:29:05.303 0 I switch to; address_space = &quot;base&quot; @ 0p1000
16:29:05.307 0 I drop the current address space; address_space = &quot;7:0&quot; @ 0p7C52000; switch_to = &quot;base&quot; @ 0p1000
16:29:05.373 0 I syscall = &quot;exit&quot;; pid = 7:0; code = 0; reason = Some(OK)
16:29:05.379 0 D leaving the user mode; pid = 7:0
16:29:05.383 0 I dequeue; pid = Some(8:0)
16:29:05.387 0 I switch to; address_space = &quot;8:0&quot; @ 0p7CC4000
16:29:05.393 0 D entering the user mode; pid = 8:0; registers = { rax: 0x0, rdi: 0x1, rsi: 0x1, { mode: user, cs:rip: 0x0023:0v10016490, ss:rsp: 0x001B:0v7F7FFFFFC760, rflags: IF AF } }
16:29:04.845 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 8:0
16:29:04.877 0 I just created; child = &lt;current&gt;; pid = 8:0; pid = 8:0
16:29:05.407 0 I name = &quot;cow_fork *12&quot;; pedigree = [0:0, 2:0, 8:0]; len = 3; capacity = 3; pid = 8:0
16:29:05.429 0 I free; slot = Process { pid: 8:0, address_space: &quot;8:0&quot; @ 0p7CC4000, { rip: 0v10016490, rsp: 0v7F7FFFFFC760 } }; process_count = 3
16:29:05.439 0 I switch to; address_space = &quot;base&quot; @ 0p1000
16:29:05.443 0 I drop the current address space; address_space = &quot;8:0&quot; @ 0p7CC4000; switch_to = &quot;base&quot; @ 0p1000
16:29:05.509 0 I syscall = &quot;exit&quot;; pid = 8:0; code = 0; reason = Some(OK)
16:29:05.513 0 D leaving the user mode; pid = 8:0
16:29:05.519 0 I dequeue; pid = Some(9:0)
16:29:05.523 0 I switch to; address_space = &quot;9:0&quot; @ 0p7D16000
16:29:05.529 0 D entering the user mode; pid = 9:0; registers = { rax: 0x10069BC0, rdi: 0x10069BC0, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF } }
16:29:05.545 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10046BD1, ss:rsp: 0x001B:0v7F7FFFFFCDB0, rflags: IF }; info = { address: 0v10067DB8, code: 0b111 = protection violation | write | user }
16:29:05.561 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10020A87, ss:rsp: 0x001B:0v7F7FFFFFBF78, rflags: IF AF PF }; info = { address: 0v7F7FFFFFBF90, code: 0b111 = protection violation | write | user }
16:29:05.577 0 D leaving the user mode; pid = 9:0
16:29:05.583 0 I the process was preempted; pid = 9:0; user_context = { mode: user, cs:rip: 0x0023:0v10020AAD, ss:rsp: 0x001B:0v7F7FFFFFBB68, rflags: IF AF PF }
16:29:05.593 0 I returned
16:29:05.597 0 I dequeue; pid = Some(4:0)
16:29:05.601 0 I switch to; address_space = &quot;4:0&quot; @ 0p7CE9000
16:29:05.605 0 D entering the user mode; pid = 4:0; registers = { rax: 0x7F7FFFFFC318, rdi: 0x0, rsi: 0x0, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF ZF PF } }
16:29:05.621 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000D043, ss:rsp: 0x001B:0v7F7FFFFFCA38, rflags: IF SF }; info = { address: 0v7F7FFFFFD000, code: 0b111 = protection violation | write | user }
16:29:05.639 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000B86F, ss:rsp: 0x001B:0v7F7FFFFFD0B8, rflags: IF ZF AF PF CF }; info = { address: 0v7F7FFFFFE030, code: 0b111 = protection violation | write | user }
16:29:05.655 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10046BD1, ss:rsp: 0x001B:0v7F7FFFFFCDB0, rflags: IF }; info = { address: 0v10067DB8, code: 0b111 = protection violation | write | user }
16:29:05.671 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1002545E, ss:rsp: 0x001B:0v7F7FFFFFAFF8, rflags: IF AF }; info = { address: 0v7F7FFFFFAFF0, code: 0b111 = protection violation | write | user }
16:29:05.687 0 D leaving the user mode; pid = 4:0
16:29:05.691 0 I the process was preempted; pid = 4:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF }
16:29:05.701 0 I returned
16:29:05.705 0 I dequeue; pid = Some(9:0)
16:29:05.709 0 I switch to; address_space = &quot;9:0&quot; @ 0p7D16000
16:29:05.715 0 D entering the user mode; pid = 9:0; registers = { rax: 0x0, rdi: 0x7E7FFFFFB000, rsi: 0x7F7FFFFFBB88, { mode: user, cs:rip: 0x0023:0v10020AAD, ss:rsp: 0x001B:0v7F7FFFFFBB68, rflags: IF AF PF } }
16:29:05.545 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 9:0
16:29:05.729 0 I just created; child = &lt;current&gt;; pid = 9:0; pid = 9:0
16:29:05.729 0 I name = &quot;cow_fork *20&quot;; pedigree = [0:0, 4:0, 9:0]; len = 3; capacity = 3; pid = 9:0
16:29:05.751 0 I free; slot = Process { pid: 9:0, address_space: &quot;9:0&quot; @ 0p7D16000, { rip: 0v10020AAD, rsp: 0v7F7FFFFFBB68 } }; process_count = 2
16:29:05.761 0 I switch to; address_space = &quot;base&quot; @ 0p1000
16:29:05.765 0 I drop the current address space; address_space = &quot;9:0&quot; @ 0p7D16000; switch_to = &quot;base&quot; @ 0p1000
16:29:05.831 0 I syscall = &quot;exit&quot;; pid = 9:0; code = 0; reason = Some(OK)
16:29:05.837 0 D leaving the user mode; pid = 9:0
16:29:05.841 0 I dequeue; pid = Some(4:0)
16:29:05.845 0 I switch to; address_space = &quot;4:0&quot; @ 0p7CE9000
16:29:05.851 0 D entering the user mode; pid = 4:0; registers = { rax: 0x7EFFFFFFB000, rdi: 0x7F7FFFFFB040, rsi: 0x7EFFFFFFD000, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF } }
16:29:05.867 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10039862, ss:rsp: 0x001B:0v7F7FFFFF9FF8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFF9FF0, code: 0b111 = protection violation | write | user }
16:29:05.883 0 D leaving the user mode; pid = 4:0
16:29:05.887 0 I the process was preempted; pid = 4:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF ZF PF }
16:29:05.897 0 I returned
16:29:05.903 0 I dequeue; pid = Some(4:0)
16:29:05.907 0 I switch to; address_space = &quot;4:0&quot; @ 0p7CE9000
16:29:05.911 0 D entering the user mode; pid = 4:0; registers = { rax: 0x7F7FFFFFA5FE, rdi: 0x7F7FFFFFAB60, rsi: 0x3A, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF ZF PF } }
16:29:05.655 0 I copy_address_space done; child = 0:2; trap_stack = [0v7F7FFFFD7000, 0v7F7FFFFDB000), size 16.000 KiB, Page[~127.500 TiB, ~127.500 TiB); pid = 4:0
16:29:05.943 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10013B12, ss:rsp: 0x001B:0v7F7FFFFFCDD8, rflags: IF }; info = { address: 0v10069BB8, code: 0b111 = protection violation | write | user }
16:29:05.961 0 I syscall::set_state(); child = 0:2; result = Ok(()); pid = 4:0
16:29:06.063 0 I page allocator init; free_page_count = 33554432000; block = [0v18000000000, 0v7E8000000000), size 125.000 TiB
16:29:06.073 0 I duplicate; address_space = &quot;process&quot; @ 0p7BF3000
16:29:06.077 0 I switch to; address_space = &quot;process&quot; @ 0p7BF3000
16:29:06.085 0 I switch to; address_space = &quot;4:0&quot; @ 0p7CE9000
16:29:06.089 0 I allocate; slot = Process { pid: 9:1, address_space: &quot;9:1&quot; @ 0p7BF3000, { rip: 0v1000AAE7, rsp: 0v7F7FFFFFD0A8 } }; process_count = 3
16:29:06.099 0 I syscall = &quot;exofork&quot;; process = 4:0; child = 9:1
16:29:06.105 0 I syscall::exofork() done; child = Ok(9:1); pid = 4:0
16:29:06.247 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1001318E, ss:rsp: 0x001B:0v7F7FFFFFB598, rflags: IF }; info = { address: 0v7F7FFFFFB680, code: 0b111 = protection violation | write | user }
16:29:06.265 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000D013, ss:rsp: 0x001B:0v7F7FFFFFB7D8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFC318, code: 0b111 = protection violation | write | user }
16:29:06.281 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000D043, ss:rsp: 0x001B:0v7F7FFFFFCA38, rflags: IF SF }; info = { address: 0v7F7FFFFFD000, code: 0b111 = protection violation | write | user }
16:29:06.295 0 D leaving the user mode; pid = 4:0
16:29:06.301 0 I the process was preempted; pid = 4:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF SF }
16:29:06.311 0 I returned
16:29:06.315 0 I dequeue; pid = Some(0:2)
16:29:06.319 0 I switch to; address_space = &quot;0:2&quot; @ 0p7DF3000
16:29:06.325 0 D entering the user mode; pid = 0:2; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v1000AAE7, ss:rsp: 0x001B:0v7F7FFFFFD0A8, rflags: IF } }
16:29:06.339 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000AAE9, ss:rsp: 0x001B:0v7F7FFFFFD0B8, rflags: IF }; info = { address: 0v7F7FFFFFE340, code: 0b111 = protection violation | write | user }
16:29:06.355 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10018677, ss:rsp: 0x001B:0v7F7FFFFDAD68, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFD0B0, code: 0b111 = protection violation | write | user }
16:29:06.371 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015517, ss:rsp: 0x001B:0v7F7FFFFFCF18, rflags: IF AF PF }; info = { address: 0v7F7FFFFFCF20, code: 0b111 = protection violation | write | user }
16:29:06.387 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015BD2, ss:rsp: 0x001B:0v7F7FFFFFCF98, rflags: IF }; info = { address: 0v10069BC0, code: 0b111 = protection violation | write | user }
16:29:06.403 0 D leaving the user mode; pid = 0:2
16:29:06.407 0 I the process was preempted; pid = 0:2; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF }
16:29:06.417 0 I returned
16:29:06.421 0 I dequeue; pid = Some(4:0)
16:29:06.427 0 I switch to; address_space = &quot;4:0&quot; @ 0p7CE9000
16:29:06.431 0 D entering the user mode; pid = 4:0; registers = { rax: 0xFF, rdi: 0xFFFFFFFFFFFFF7F8, rsi: 0x100, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF SF } }
16:29:06.447 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000B86F, ss:rsp: 0x001B:0v7F7FFFFFD0B8, rflags: IF ZF AF PF CF }; info = { address: 0v7F7FFFFFE030, code: 0b111 = protection violation | write | user }
16:29:06.465 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10046BD1, ss:rsp: 0x001B:0v7F7FFFFFCDB0, rflags: IF }; info = { address: 0v10067DB8, code: 0b111 = protection violation | write | user }
16:29:06.481 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1002545E, ss:rsp: 0x001B:0v7F7FFFFFAFF8, rflags: IF AF }; info = { address: 0v7F7FFFFFAFF0, code: 0b111 = protection violation | write | user }
16:29:06.495 0 D leaving the user mode; pid = 4:0
16:29:06.501 0 I the process was preempted; pid = 4:0; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF }
16:29:06.511 0 I returned
16:29:06.515 0 I dequeue; pid = Some(0:2)
16:29:06.519 0 I switch to; address_space = &quot;0:2&quot; @ 0p7DF3000
16:29:06.525 0 D entering the user mode; pid = 0:2; registers = { rax: 0x10069BC0, rdi: 0x10069BC0, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF } }
16:29:06.541 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10046BD1, ss:rsp: 0x001B:0v7F7FFFFFCDB0, rflags: IF }; info = { address: 0v10067DB8, code: 0b111 = protection violation | write | user }
16:29:06.557 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10020A87, ss:rsp: 0x001B:0v7F7FFFFFBF78, rflags: IF AF PF }; info = { address: 0v7F7FFFFFBF90, code: 0b111 = protection violation | write | user }
16:29:06.541 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 0:2
16:29:06.573 0 I just created; child = &lt;current&gt;; pid = 0:2; pid = 0:2
16:29:06.575 0 I name = &quot;cow_fork *21&quot;; pedigree = [0:0, 4:0, 0:2]; len = 3; capacity = 3; pid = 0:2
16:29:06.595 0 I free; slot = Process { pid: 0:2, address_space: &quot;0:2&quot; @ 0p7DF3000, { rip: 0v10013820, rsp: 0v7F7FFFFDAFC8 } }; process_count = 2
16:29:06.605 0 I switch to; address_space = &quot;base&quot; @ 0p1000
16:29:06.609 0 I drop the current address space; address_space = &quot;0:2&quot; @ 0p7DF3000; switch_to = &quot;base&quot; @ 0p1000
16:29:06.677 0 I syscall = &quot;exit&quot;; pid = 0:2; code = 0; reason = Some(OK)
16:29:06.681 0 D leaving the user mode; pid = 0:2
16:29:06.687 0 I dequeue; pid = Some(4:0)
16:29:06.691 0 I switch to; address_space = &quot;4:0&quot; @ 0p7CE9000
16:29:06.695 0 D entering the user mode; pid = 4:0; registers = { rax: 0x7EFFFFFFB000, rdi: 0x7F7FFFFFB040, rsi: 0x7EFFFFFFD000, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF AF } }
16:29:06.711 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10039862, ss:rsp: 0x001B:0v7F7FFFFF9FF8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFF9FF0, code: 0b111 = protection violation | write | user }
16:29:06.465 0 I copy_address_space done; child = 9:1; trap_stack = [0v7F7FFFFD7000, 0v7F7FFFFDB000), size 16.000 KiB, Page[~127.500 TiB, ~127.500 TiB); pid = 4:0
16:29:06.745 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10013B12, ss:rsp: 0x001B:0v7F7FFFFFCDD8, rflags: IF }; info = { address: 0v10069BB8, code: 0b111 = protection violation | write | user }
16:29:06.763 0 I syscall::set_state(); child = 9:1; result = Ok(()); pid = 4:0
16:29:06.769 0 I free; slot = Process { pid: 4:0, address_space: &quot;4:0&quot; @ 0p7CE9000, { rip: 0v10013820, rsp: 0v7F7FFFFDAFC8 } }; process_count = 1
16:29:06.779 0 I switch to; address_space = &quot;base&quot; @ 0p1000
16:29:06.783 0 I drop the current address space; address_space = &quot;4:0&quot; @ 0p7CE9000; switch_to = &quot;base&quot; @ 0p1000
16:29:06.847 0 I syscall = &quot;exit&quot;; pid = 4:0; code = 0; reason = Some(OK)
16:29:06.851 0 D leaving the user mode; pid = 4:0
16:29:06.857 0 I dequeue; pid = Some(9:1)
16:29:06.861 0 I switch to; address_space = &quot;9:1&quot; @ 0p7BF3000
16:29:06.867 0 D entering the user mode; pid = 9:1; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v1000AAE7, ss:rsp: 0x001B:0v7F7FFFFFD0A8, rflags: IF ZF PF } }
16:29:06.881 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v1000AAE9, ss:rsp: 0x001B:0v7F7FFFFFD0B8, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFE340, code: 0b111 = protection violation | write | user }
16:29:06.895 0 D leaving the user mode; pid = 9:1
16:29:06.901 0 I the process was preempted; pid = 9:1; user_context = { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF ZF PF }
16:29:06.911 0 I returned
16:29:06.915 0 I dequeue; pid = Some(9:1)
16:29:06.919 0 I switch to; address_space = &quot;9:1&quot; @ 0p7BF3000
16:29:06.923 0 D entering the user mode; pid = 9:1; registers = { rax: 0x0, rdi: 0xFFFFFFFFFFFFFFFE, rsi: 0x7E7FFFFFB000, { mode: user, cs:rip: 0x0023:0v10013820, ss:rsp: 0x001B:0v7F7FFFFDAFC8, rflags: IF ZF PF } }
16:29:06.941 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10018677, ss:rsp: 0x001B:0v7F7FFFFDAD68, rflags: IF ZF PF }; info = { address: 0v7F7FFFFFD0B0, code: 0b111 = protection violation | write | user }
16:29:06.957 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015517, ss:rsp: 0x001B:0v7F7FFFFFCF18, rflags: IF AF PF }; info = { address: 0v7F7FFFFFCF20, code: 0b111 = protection violation | write | user }
16:29:06.973 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10015BD2, ss:rsp: 0x001B:0v7F7FFFFFCF98, rflags: IF }; info = { address: 0v10069BC0, code: 0b111 = protection violation | write | user }
16:29:06.989 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10046BD1, ss:rsp: 0x001B:0v7F7FFFFFCDB0, rflags: IF }; info = { address: 0v10067DB8, code: 0b111 = protection violation | write | user }
16:29:07.001 0 D trap = &quot;Page Fault&quot;; context = { mode: user, cs:rip: 0x0023:0v10020A87, ss:rsp: 0x001B:0v7F7FFFFFBF78, rflags: IF AF PF }; info = { address: 0v7F7FFFFFBF90, code: 0b111 = protection violation | write | user }
16:29:06.985 0 I syscall::exofork() done; child = Ok(&lt;current&gt;); pid = 9:1
16:29:07.017 0 I just created; child = &lt;current&gt;; pid = 9:1; pid = 9:1
16:29:07.019 0 I name = &quot;cow_fork *22&quot;; pedigree = [0:0, 4:0, 9:1]; len = 3; capacity = 3; pid = 9:1
16:29:07.041 0 I free; slot = Process { pid: 9:1, address_space: &quot;9:1&quot; @ 0p7BF3000, { rip: 0v10013820, rsp: 0v7F7FFFFDAFC8 } }; process_count = 0
16:29:07.049 0 I switch to; address_space = &quot;base&quot; @ 0p1000
16:29:07.055 0 I drop the current address space; address_space = &quot;9:1&quot; @ 0p7BF3000; switch_to = &quot;base&quot; @ 0p1000
16:29:07.123 0 I syscall = &quot;exit&quot;; pid = 9:1; code = 0; reason = Some(OK)
16:29:07.127 0 D leaving the user mode; pid = 9:1
16:29:07.133 0 I dequeue; pid = None
16:29:07.141 0 D parent = 0:0; process = 1:0
16:29:07.149 0 D parent = 0:0; process = 2:0
16:29:07.155 0 D parent = 0:0; process = 4:0
16:29:07.159 0 D parent = 1:0; process = 3:0
16:29:07.165 0 D parent = 1:0; process = 6:0
16:29:07.169 0 D parent = 1:0; process = 7:0
16:29:07.175 0 D parent = 2:0; process = 0:1
16:29:07.179 0 D parent = 2:0; process = 5:0
16:29:07.185 0 D parent = 2:0; process = 8:0
16:29:07.189 0 D parent = 4:0; process = 0:2
16:29:07.195 0 D parent = 4:0; process = 9:0
16:29:07.199 0 D parent = 4:0; process = 9:1
16:29:07.205 0 D graphviz = digraph process_tree { node [ style = filled; fillcolor = &quot;#CCCCCC&quot;]; &quot;0:0&quot; -&gt; &quot;1:0&quot;; &quot;0:0&quot; -&gt; &quot;2:0&quot;; &quot;0:0&quot; -&gt; &quot;4:0&quot;; &quot;1:0&quot; -&gt; &quot;3:0&quot;; &quot;1:0&quot; -&gt; &quot;6:0&quot;; &quot;1:0&quot; -&gt; &quot;7:0&quot;; &quot;2:0&quot; -&gt; &quot;0:1&quot;; &quot;2:0&quot; -&gt; &quot;5:0&quot;; &quot;2:0&quot; -&gt; &quot;8:0&quot;; &quot;4:0&quot; -&gt; &quot;0:2&quot;; &quot;4:0&quot; -&gt; &quot;9:0&quot;; &quot;4:0&quot; -&gt; &quot;9:1&quot;; }
5_um_5_cow_fork::cow_fork-------------------------- [passed]
16:29:07.227 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<pre><code class="language-console">$ grep 'pedigree' log
16:28:57 0 I name = &quot;cow_fork *&quot;; pedigree = [0:0]; len = 1; capacity = 3; pid = 0:0
16:28:58.261 0 I name = &quot;cow_fork *0&quot;; pedigree = [0:0, 1:0]; len = 2; capacity = 3; pid = 1:0
16:28:59.479 0 I name = &quot;cow_fork *1&quot;; pedigree = [0:0, 2:0]; len = 2; capacity = 3; pid = 2:0
16:29:02.385 0 I name = &quot;cow_fork *2&quot;; pedigree = [0:0, 4:0]; len = 2; capacity = 3; pid = 4:0
16:29:02.635 0 I name = &quot;cow_fork *00&quot;; pedigree = [0:0, 1:0, 3:0]; len = 3; capacity = 3; pid = 3:0
16:29:03.603 0 I name = &quot;cow_fork *01&quot;; pedigree = [0:0, 1:0, 6:0]; len = 3; capacity = 3; pid = 6:0
16:29:03.831 0 I name = &quot;cow_fork *10&quot;; pedigree = [0:0, 2:0, 5:0]; len = 3; capacity = 3; pid = 5:0
16:29:04.365 0 I name = &quot;cow_fork *11&quot;; pedigree = [0:0, 2:0, 0:1]; len = 3; capacity = 3; pid = 0:1
16:29:05.271 0 I name = &quot;cow_fork *02&quot;; pedigree = [0:0, 1:0, 7:0]; len = 3; capacity = 3; pid = 7:0
16:29:05.407 0 I name = &quot;cow_fork *12&quot;; pedigree = [0:0, 2:0, 8:0]; len = 3; capacity = 3; pid = 8:0
16:29:05.729 0 I name = &quot;cow_fork *20&quot;; pedigree = [0:0, 4:0, 9:0]; len = 3; capacity = 3; pid = 9:0
16:29:06.575 0 I name = &quot;cow_fork *21&quot;; pedigree = [0:0, 4:0, 0:2]; len = 3; capacity = 3; pid = 0:2
16:29:07.019 0 I name = &quot;cow_fork *22&quot;; pedigree = [0:0, 4:0, 9:1]; len = 3; capacity = 3; pid = 9:1
</code></pre>
<p>Получилось такое дерево процессов:
<img src="5-um-5-cow-fork.svg" alt="" /></p>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-24"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-24">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> main.rs |   74 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++------
 1 file changed, 68 insertions(+), 6 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Файловая-система"><a class="header" href="#Файловая-система">Файловая система</a></h2>
<p>В этой лабораторной работе мы реализуем файловую систему.
Она очень упрощена, и не поддерживает права доступа к файлам, линки и многое другое.
В частности, директории хранятся как файлы с массивом записей, а не как хеш-таблицы или B-деревья.
Что ведёт к неэффективному линейному поиску по ним.
Также для простоты, формат хранения структур файловой системы на диске и в памяти будет одинаковый.
Поэтому можно будет работать с отображённым в память диском.</p>
<h3 id="Структура-файловой-системы-на-диске"><a class="header" href="#Структура-файловой-системы-на-диске">Структура файловой системы на диске</a></h3>
<p><img src="6-fs-0-fs-structure.svg" alt="Структура файловой системы на диске" /></p>
<h3 id="Суперблок"><a class="header" href="#Суперблок">Суперблок</a></h3>
<p>Хранит основную информацию о файловой системе.
Она нужна, например, при монтировании.
У нас он очень простой:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Superblock {
    magic: [u8; MAGIC.len()],
    endian: u64,
    block_count: usize,
    root: Inode,
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="Дамп-диска-в-шестнадцатеричном-виде"><a class="header" href="#Дамп-диска-в-шестнадцатеричном-виде">Дамп диска в шестнадцатеричном виде</a></h3>
<p>При выполнении лабораторки вам может пригодиться команда</p>
<pre><code class="language-console">$ make fs-dump
...
00001000: 4e69 6b6b 6127 7320 7369 6d70 6c65 2066  Nikka's simple f
00001010: 696c 6520 7379 7374 656d 0000 0000 0000  ile system......
00001020: 0807 0605 0403 0201 0020 0000 0000 0000  ......... ......
00001030: 0200 0000 0000 0000 0000 0000 0000 0000  ................
...
00002000: ff3f 0000 0000 0000 0000 0000 0000 0000  .?..............
...
00003000: 0100 0000 0000 0000 3cd5 fc00 aa80 0000  ........&lt;.......
00003010: 0000 0000 0000 0000 2e16 0000 0000 0000  ................
00003020: 0400 0000 0000 0000 0500 0000 0000 0000  ................
...
00003040: 6669 6c65 2d31 0000 0000 0000 0000 0000  file-1..........
...
00003080: 0000 0000 0000 0000 3cd5 fc00 aa80 0000  ........&lt;.......
...
000030c0: 6669 6c65 2d74 6f2d 6265 2d65 7261 7365  file-to-be-erase
000030d0: 6400 0000 0000 0000 0000 0000 0000 0000  d...............
...
00003100: 0100 0000 0000 0000 3cd5 fc00 aa80 0000  ........&lt;.......
00003110: 0000 0000 0000 0000 9426 0000 0000 0000  .........&amp;......
00003120: 0700 0000 0000 0000 0800 0000 0000 0000  ................
...
00003140: 6669 6c65 2d32 0000 0000 0000 0000 0000  file-2..........
...
00003180: 0200 0000 0000 0000 3cd5 fc00 aa80 0000  ........&lt;.......
00003190: 0000 0000 0000 0000 0010 0000 0000 0000  ................
000031a0: 0a00 0000 0000 0000 0000 0000 0000 0000  ................
...
000031c0: 6469 722d 3100 0000 0000 0000 0000 0000  dir-1...........
...
00005000: 0600 0000 0000 0000 0000 0000 0000 0000  ................
...
00007f50: 0000 0000 0000 002a 2a2a 2a2a 2a2a 2a2a  .......*********
00007f60: 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a  ****************
00007f70: 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a  ****************
00007f80: 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a  ****************
00007f90: 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a  ****************
00007fa0: 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a  ****************
00007fb0: 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a  ****************
00007fc0: 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a  ****************
00007fd0: 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a  ****************
00007fe0: 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a  ****************
00007ff0: 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a  ****************
00008000: 0900 0000 0000 0000 0d00 0000 0000 0000  ................
...
0000a000: 0100 0000 0000 0000 3cd5 fc00 aa80 0000  ........&lt;.......
...
0000a040: 6669 6c65 2d34 0000 0000 0000 0000 0000  file-4..........
...
0000a080: 0100 0000 0000 0000 3cd5 fc00 aa80 0000  ........&lt;.......
...
0000a0c0: 6669 6c65 2d35 0000 0000 0000 0000 0000  file-5..........
...
0000a100: 0200 0000 0000 0000 3cd5 fc00 aa80 0000  ........&lt;.......
0000a110: 0000 0000 0000 0000 0010 0000 0000 0000  ................
0000a120: 0b00 0000 0000 0000 0000 0000 0000 0000  ................
...
0000a140: 6469 722d 3200 0000 0000 0000 0000 0000  dir-2...........
...
0000b000: 0200 0000 0000 0000 3cd5 fc00 aa80 0000  ........&lt;.......
0000b010: 0000 0000 0000 0000 0010 0000 0000 0000  ................
0000b020: 0c00 0000 0000 0000 0000 0000 0000 0000  ................
...
0000b040: 6469 722d 3300 0000 0000 0000 0000 0000  dir-3...........
...
0000c000: 0100 0000 0000 0000 3cd5 fc00 aa80 0000  ........&lt;.......
...
0000c040: 6669 6c65 2d33 0000 0000 0000 0000 0000  file-3..........
...
</code></pre>
<h3 id="Ориентировочный-объём-работ-этой-лабораторки-5"><a class="header" href="#Ориентировочный-объём-работ-этой-лабораторки-5">Ориентировочный объём работ этой лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/fs/block_bitmap.rs |   26 ++++
 kernel/src/fs/block_cache.rs  |   64 ++++++++++-
 kernel/src/fs/file_system.rs  |   21 +++
 kernel/src/fs/inode.rs        |  234 +++++++++++++++++++++++++++++++++++++++---
 4 files changed, 318 insertions(+), 27 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Блочный-кеш"><a class="header" href="#Блочный-кеш">Блочный кеш</a></h2>
<p>В Nikka диск отображается в память, чтобы удобнее было с ним работать.
Для отслеживания с какого диска, куда именно и сколько памяти отображено, служит структура
<a href="../../doc/kernel/fs/block_cache/struct.BlockCache.html"><code>kernel::fs::block_cache::BlockCache</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct BlockCache {
    cache: Block&lt;Page&gt;,
    disk: Disk,
}
<span class="boring">}
</span></code></pre></pre>
<p>Она является <a href="https://en.wikipedia.org/wiki/Singleton_pattern">синглтоном</a>
<a href="../../doc/kernel/fs/block_cache/struct.BLOCK_CACHE.html"><code>static ref BLOCK_CACHE: Mutex&lt;Option&lt;BlockCache&gt;&gt;</code></a>.</p>
<p>В память блоки зачитываются по необходимости.
Для этого, изначально все страницы помечаются недоступными.
А при возникновении ошибки обращения к памяти, страницы нужного блока считывается с диска обработчиком
<code>BlockCache::trap_handler()</code>.
Запись блока выполняется при необходимости вызовом <code>BlockCache::flush_block()</code>.
Все блоки можно записать вызовом <code>BlockCache::flush()</code>.
Для простоты, размер блока <code>BLOCK_SIZE</code> берётся равным размеру страницы <code>Page::SIZE</code>.</p>
<h3 id="Блочный-кеш-в-общем-случае"><a class="header" href="#Блочный-кеш-в-общем-случае">Блочный кеш в общем случае</a></h3>
<p>Обычно размер кеша в памяти гораздо меньше, чем размер кешируемого диска:</p>
<p><img src="6-fs-1-block-cache.svg" alt="" /></p>
<h3 id="Блочный-кеш-в-nikka"><a class="header" href="#Блочный-кеш-в-nikka">Блочный кеш в Nikka</a></h3>
<p>В Nikka сделано значительное упрощение.
Размер кеша в памяти равен размер кешируемого диска.
Поэтому размер диска ограничен размером доступной в машине памяти.</p>
<p><img src="6-fs-1-block-cache-nikka.svg" alt="" /></p>
<h3 id="Задача-1--блочный-кеш"><a class="header" href="#Задача-1--блочный-кеш">Задача 1 — блочный кеш</a></h3>
<h4 id="Инициализация-1"><a class="header" href="#Инициализация-1">Инициализация</a></h4>
<p>Реализуйте метод инициализации блочного кеша</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn BlockCache::init(disk: Disk, block_count: usize) -&gt; Result&lt;()&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/fs/block_cache.rs"><code>kernel/src/fs/block_cache.rs</code></a>.</p>
<p>Он должен зарезервировать в <code>BASE_ADDRESS_SPACE</code> блок виртуальных страниц, достаточный для хранения
<code>block_count</code> блоков файловой системы.
И записать соответствующее значение в
<a href="../../doc/kernel/fs/block_cache/struct.BLOCK_CACHE.html"><code>BLOCK_CACHE</code></a>.</p>
<h4 id="Считывание-блока-с-диска"><a class="header" href="#Считывание-блока-с-диска">Считывание блока с диска</a></h4>
<p>Реализуйте метод</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn BlockCache::trap_handler(info: &amp;Info) -&gt; Result&lt;bool&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/fs/block_cache.rs"><code>kernel/src/fs/block_cache.rs</code></a>.</p>
<p>Он должен обработать Page Fault, если адрес, который его вызвал, относится к блочному кешу.
Если это так и Page Fault обработан, верните <code>true</code>.
Если адрес, вызвавший Page Fault, не относится к блочному кешу, верните <code>false</code>.
Для чтения с диска используйте метод
<a href="../../doc/kernel/fs/disk/struct.Disk.html#method.pio_read"><code>kernel::fs::disk::Disk::pio_read()</code></a>.</p>
<h4 id="Запись-блока-на-диск"><a class="header" href="#Запись-блока-на-диск">Запись блока на диск</a></h4>
<p>Запись блока выполняется при необходимости вызовом <code>BlockCache::flush_block()</code>.</p>
<p>Реализуйте метод</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn BlockCache::flush_block(block_number: usize) -&gt; Result&lt;()&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/fs/block_cache.rs"><code>kernel/src/fs/block_cache.rs</code></a>.</p>
<p>Он записывает заданный блок на диск методом
<a href="../../doc/kernel/fs/disk/struct.Disk.html#method.pio_write"><code>kernel::fs::disk::Disk::pio_write()</code></a>.
Запись нужно делать только если:</p>
<ul>
<li>Блок отображён в память. Это означает что нему были обращения.</li>
<li>И помечен как <code>PageTableFlags::DIRTY</code>. То есть, в память были записи, а значит блок на диске потенциально содержит устаревшие данные. Если обращения к блоку были только на чтение, то данные в памяти такие же как на диске, и можно их не записывать. А процессор в этом случае не установит бит <code>PageTableFlags::DIRTY</code>.</li>
<li>После записи блока, сбросьте бит <code>PageTableFlags::DIRTY</code>. Он фактически означает одинаковость данных на диске и в памяти блочного кеша. Которая только что восстановлена. При этом нужно сбросить и соответствующую запись в <a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer">TLB</a> с помощью функции <a href="../../doc/kernel/memory/mmu/fn.flush.html"><code>kernel::memory::mmu::flush()</code></a>. Иначе процессор не узнает, что вы сбросили <code>PageTableFlags::DIRTY</code> и не проставит его в таблице страниц при следующей записи. И обновлённый блок на диск записан не будет.</li>
</ul>
<h3 id="Проверьте-себя-21"><a class="header" href="#Проверьте-себя-21">Проверьте себя</a></h3>
<p>Теперь должны заработать тесты в файлах
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/6-fs-1-block-cache-1-write.rs"><code>kernel/tests/6-fs-1-block-cache-1-write.rs</code></a> и
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/6-fs-1-block-cache-2-read.rs"><code>kernel/tests/6-fs-1-block-cache-2-read.rs</code></a>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 6-fs-1-block-cache-1-write --test 6-fs-1-block-cache-2-read)
...
6_fs_1_block_cache_1_write::write---------------------------
20:37:19 0 D block_count = 8192
6_fs_1_block_cache_1_write::write------------------ [passed]
20:37:19 0 I exit qemu; exit_code = SUCCESS
...
6_fs_1_block_cache_2_read::read_what_was_written------------
20:37:21 0 D block_count = 8192
6_fs_1_block_cache_2_read::read_what_was_written--- [passed]
20:37:21 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-25"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-25">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/fs/block_cache.rs |   64 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++--------
 1 file changed, 56 insertions(+), 8 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Битмап-занятых-блоков"><a class="header" href="#Битмап-занятых-блоков">Битмап занятых блоков</a></h2>
<p>Для отслеживания какие именно блоки файловой системы заняты,
а какие свободны, служит структура
<a href="../../doc/kernel/fs/block_bitmap/struct.BlockBitmap.html"><code>kernel::fs::block_bitmap::BlockBitmap</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct BlockBitmap {
    bitmap: &amp;'static mut [u64],
    block_count: usize,
    cursor: usize,
}
<span class="boring">}
</span></code></pre></pre>
<p>Каждый элемент среза <code>BlockBitmap::bitmap</code> отвечает за 64 блока.
Блоку с меньшим номером соответствует бит с меньшим весом в соответствующем элементе.
Блок свободен тогда и только тогда, когда соответствующий ему бит равен <code>0</code>.</p>
<h3 id="Задача-2--битмап-занятых-блоков"><a class="header" href="#Задача-2--битмап-занятых-блоков">Задача 2 — битмап занятых блоков</a></h3>
<p>Реализуйте метод</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn BlockBitmap::allocate(&amp;mut self) -&gt; Result&lt;usize&gt;
<span class="boring">}
</span></code></pre></pre>
<p>в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/fs/block_bitmap.rs"><code>kernel/src/fs/block_bitmap.rs</code></a>.</p>
<p>Функция должна найти по <code>BlockBitmap::bitmap</code> свободный блок и аллоцировать его.</p>
<ul>
<li>Верните номер выделенного блока.</li>
<li>После того как новый блок аллоцирован, сбросьте изменившийся блок самого <code>bitmap</code> на диск с помощью реализованной вами функции <code>BlockCache::flush_block()</code>. Когда меняете метаданные, лучше сразу сбрасывать их на диск, так меньше вероятность поломки файловой системы, например, при сбое питания.</li>
<li>Искать каждый раз с самого начала <code>BlockBitmap::bitmap</code> не эффективно. Лучше, например, обходить его по циклу с того места, на котором остановились в прошлый раз. Для хранения этой позиции между вызовами <code>BlockBitmap::allocate()</code> служит поле <code>BlockBitmap::cursor</code>.</li>
<li>Проверять каждый бит тоже не эффективно. Лучше сначала найти элемент <code>BlockBitmap::bitmap</code>, в котором есть хотя бы один свободный бит. Поэтому биты сгруппированы именно по <code>u64</code>, а не например по <code>u8</code>.</li>
<li>Верните ошибку <a href="../../doc/kernel/error/enum.Error.html#variant.NoDisk"><code>Error::NoDisk</code></a>, если свободных блоков не осталось.</li>
</ul>
<h3 id="Проверьте-себя-22"><a class="header" href="#Проверьте-себя-22">Проверьте себя</a></h3>
<p>Теперь должен заработать тест <code>allocation()</code> в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/6-fs-2-block-bitmap.rs"><code>kernel/tests/6-fs-2-block-bitmap.rs</code></a>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 6-fs-2-block-bitmap)
...
6_fs_2_block_bitmap::allocation-----------------------------
20:37:24 0 D block_count = 8192
6_fs_2_block_bitmap::allocation-------------------- [passed]
20:37:30.657 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-26"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-26">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/fs/block_bitmap.rs |   26 ++++++++++++++++++++++++--
 1 file changed, 24 insertions(+), 2 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="index-node-inode"><a class="header" href="#index-node-inode">Index node (inode)</a></h2>
<p>В <a href="https://en.wikipedia.org/wiki/Inode">inode</a> хранится метаинформация об объекте с данными.
Имя объекта не хранится, оно хранится в директории.
Объектом может быть как файл, так и директория.
В случае директорий, их содержимое — массив из имен объектов и их <a href="https://en.wikipedia.org/wiki/Inode">inode</a>.
<a href="https://en.wikipedia.org/wiki/Inode">Inode</a> корневой директории файловой системы хранится в суперблоке.</p>
<p>В файловых системах семейства System V, упрощённую реализацию которой пишем мы,
в директории хранится не сам
<a href="https://en.wikipedia.org/wiki/Inode">inode</a>,
а его номер.
Это позволяет иметь для одного
<a href="https://en.wikipedia.org/wiki/Inode">inode</a>
несколько имён в одной и той же или в разных директориях —
<a href="https://en.wikipedia.org/wiki/Hard_link">жёстких ссылок</a>.
В этом случае сами
<a href="https://en.wikipedia.org/wiki/Inode">inode</a>
хранятся в отдельном массиве в файловой системе (на диске).
И для ускорения их аллокации заводят отдельный битмап, как для блоков.</p>
<p>Структура <code>Inode</code> выглядит так:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Kind {
    Unused = 0,
    File = 1,
    Directory = 2,
}

struct Inode {
    kind: Kind,
    modify_time: DateTime&lt;Utc&gt;,
    size: usize,
    root_blocks: [usize; MAX_HEIGHT],
}

const MAX_HEIGHT: usize = 4;
<span class="boring">}
</span></code></pre></pre>
<h3 id="Блоки-данных-inode"><a class="header" href="#Блоки-данных-inode">Блоки данных inode</a></h3>
<p>Блоки данных
<a href="https://en.wikipedia.org/wiki/Inode">inode</a>
адресуются через массив <code>root_blocks</code> структуры <code>struct Inode</code>.</p>
<p><img src="6-fs-3-inode.svg" alt="Блоки данных файла" /></p>
<h3 id="Задача-3--index-node-inode"><a class="header" href="#Задача-3--index-node-inode">Задача 3 — index node (inode)</a></h3>
<p>Реализуйте недостающие методы структуры
<a href="../../doc/kernel/fs/inode/struct.Inode.html"><code>kernel::fs::inode::Inode</code></a>
в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/fs/inode.rs"><code>kernel/src/fs/inode.rs</code></a>.</p>
<p>Вам могут пригодиться методы <code>size::div_ceil()</code> и <code>size::next_multiple_of()</code>.</p>
<h4 id="kernelfsinodeinodeblock_entry"><a class="header" href="#kernelfsinodeinodeblock_entry"><a href="../../doc/kernel/fs/inode/struct.Inode.html#method.block_entry"><code>kernel::fs::inode::Inode::block_entry()</code></a></a></h4>
<ul>
<li>Если при обходе леса встречается не выделенный косвенный блок, то его нужно выделить из <code>block_bitmap</code>. Не выделенные блоки имеют зарезервированный номер <code>NO_BLOCK</code>.</li>
<li>А вот выделять блок для данных, на который указывает результирующая запись, не нужно.</li>
</ul>
<p>Этот метод похож на
<a href="../../doc/kernel/memory/mapping/struct.Mapping.html#method.translate"><code>kernel::memory::mapping::Mapping::translate()</code></a>,
<a href="../../lab/book/2-mm-6-address-space-2-translate.html#%D0%9E%D1%82%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D1%85-%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86-%D0%BD%D0%B0-%D1%84%D0%B8%D0%B7%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D1%84%D1%80%D0%B5%D0%B9%D0%BC%D1%8B">который вы уже реализовали</a>.
Только в <code>Inode</code> для блоков не одно дерево фиксированной высоты,
а последовательность деревьев возрастающей высоты.</p>
<h4 id="kernelfsinodeinodeset_size"><a class="header" href="#kernelfsinodeinodeset_size"><a href="../../doc/kernel/fs/inode/struct.Inode.html#method.set_size"><code>kernel::fs::inode::Inode::set_size()</code></a></a></h4>
<h4 id="kernelfsinodeinoderead"><a class="header" href="#kernelfsinodeinoderead"><a href="../../doc/kernel/fs/inode/struct.Inode.html#method.read"><code>kernel::fs::inode::Inode::read()</code></a></a></h4>
<h4 id="kernelfsinodeinodewrite"><a class="header" href="#kernelfsinodeinodewrite"><a href="../../doc/kernel/fs/inode/struct.Inode.html#method.write"><code>kernel::fs::inode::Inode::write()</code></a></a></h4>
<h3 id="Проверьте-себя-23"><a class="header" href="#Проверьте-себя-23">Проверьте себя</a></h3>
<p>Теперь должены заработать тесты в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/6-fs-3-inode.rs"><code>kernel/tests/6-fs-3-inode.rs</code></a>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 6-fs-3-inode)
...
6_fs_3_inode::block_entry-----------------------------------
20:37:33 0 D block_count = 8192
20:38:04.275 0 D block entry allocation is done, checking the entries
6_fs_3_inode::block_entry-------------------------- [passed]

6_fs_3_inode::read_write_speed------------------------------
20:38:28.769 0 D block_count = 8192
20:38:29.161 0 D disk read speed; elapsed = 360.269 ms; size = 1.000 MiB
20:38:29.219 0 D file system read speed; elapsed = 49.309 ms; timeout = 200.000 ms; size = 1.000 MiB
20:38:29.277 0 D file system write speed; elapsed = 47.858 ms; timeout = 200.000 ms; size = 1.000 MiB
6_fs_3_inode::read_write_speed--------------------- [passed]

6_fs_3_inode::write_read------------------------------------
20:38:29.299 0 D block_count = 8192
20:38:30.431 0 D actual = [0, 2, 6, 12, 20, 30, 42, 56, 72, 90]; expected = [0, 2, 6, 12, 20, 30, 42, 56, 72, 90]
6_fs_3_inode::write_read--------------------------- [passed]

6_fs_3_inode::set_size--------------------------------------
20:38:31.227 0 D block_count = 8192
6_fs_3_inode::set_size----------------------------- [passed]
20:38:39.909 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-27"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-27">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/fs/inode.rs |  125 ++++++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 119 insertions(+), 6 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Операции-с-директориями"><a class="header" href="#Операции-с-директориями">Операции с директориями</a></h2>
<p>Директории — это
<a href="https://en.wikipedia.org/wiki/Inode">inode</a>,
с фиксированным форматом данных.
А именно, размер данных для директорий должен быть кратен размеру блока.
А сами данные — это массив записей типа</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DirectoryEntry {
    inode: Inode,
    name: [u8; MAX_NAME_LEN],
}
<span class="boring">}
</span></code></pre></pre>
<p>Отсутствующие или удалённые записи при этом помечаются как <code>inode.kind == Kind::Unused</code>.</p>
<h3 id="Задача-4--операции-с-директориями"><a class="header" href="#Задача-4--операции-с-директориями">Задача 4 — операции с директориями</a></h3>
<p>Реализуйте методы <code>Inode</code>, которые работают с данными директорий.</p>
<h4 id="kernelfsinodeinodefind_entry"><a class="header" href="#kernelfsinodeinodefind_entry"><a href="../../doc/kernel/fs/inode/struct.Inode.html#method.find_entry"><code>kernel::fs::inode::Inode::find_entry()</code></a></a></h4>
<p>Это вспомогательный метод для
<a href="../../doc/kernel/fs/inode/struct.Inode.html#method.find"><code>kernel::fs::inode::Inode::find()</code></a> и
<a href="../../doc/kernel/fs/inode/struct.Inode.html#method.insert"><code>kernel::fs::inode::Inode::insert()</code></a>.</p>
<h4 id="kernelfsinodeinodeinsert"><a class="header" href="#kernelfsinodeinodeinsert"><a href="../../doc/kernel/fs/inode/struct.Inode.html#method.insert"><code>kernel::fs::inode::Inode::insert()</code></a></a></h4>
<h4 id="kernelfsinodeiternext"><a class="header" href="#kernelfsinodeiternext"><a href="../../doc/kernel/fs/inode/struct.Iter.html#method.next"><code>kernel::fs::inode::Iter::next()</code></a></a></h4>
<p>Это вспомогательный метод для
<a href="../../doc/kernel/fs/inode/struct.Inode.html#method.list"><code>kernel::fs::inode::Inode::list()</code></a>.</p>
<h3 id="Проверьте-себя-24"><a class="header" href="#Проверьте-себя-24">Проверьте себя</a></h3>
<p>Теперь должны заработать тесты в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/6-fs-4-directory.rs"><code>kernel/tests/6-fs-4-directory.rs</code></a>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 6-fs-4-directory)
...
6_fs_4_directory::basic_operations--------------------------
20:38:42 0 D block_count = 8192
6_fs_4_directory::basic_operations----------------- [passed]

6_fs_4_directory::max_name_len------------------------------
20:38:42 0 D block_count = 8192
6_fs_4_directory::max_name_len--------------------- [passed]
20:38:42 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-28"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-28">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/fs/inode.rs |   70 ++++++++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 64 insertions(+), 6 deletions(-)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Поиск-файла-по-пути"><a class="header" href="#Поиск-файла-по-пути">Поиск файла по пути</a></h2>
<h3 id="Задача-5--поиск-файла-по-пути"><a class="header" href="#Задача-5--поиск-файла-по-пути">Задача 5 — поиск файла по пути</a></h3>
<p>Реализуйте <a href="../../doc/kernel/fs/file_system/struct.FileSystem.html#method.open">метод</a></p>
<pre><code>fn FileSystem::open(&amp;mut self, path: &amp;str) -&gt; Result&lt;File&gt;
</code></pre>
<p>в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/fs/file_system.rs"><code>kernel/src/fs/file_system.rs</code></a>.</p>
<p>Он должен пройти от корня файловой системы по заданному полному пути <code>path</code>.
И вернуть соответствующий <code>File</code>.</p>
<h3 id="Проверьте-себя-25"><a class="header" href="#Проверьте-себя-25">Проверьте себя</a></h3>
<p>Теперь должен заработать тест <code>fs()</code> в файле
<a href="https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/tests/6-fs-5-open.rs"><code>kernel/tests/6-fs-5-open.rs</code></a>:</p>
<pre><code class="language-console">$ (cd kernel; cargo test --test 6-fs-5-open)
...
6_fs_5_open::fs---------------------------------------------
20:38:44 0 I formatted the file system; free_space = 31.988 MiB; disk = { id: 1, base_port: 0x1F0, disk: 1 }; block_count = 8192; reserved_block_count = 3; inode_size = 64 B; directory_entry_size = 128 B; max_file_size = 513.002 GiB
20:38:44 0 I path = /file-1; entry = file-1, File, 5678 B = 5.545 KiB, 2022-12-11 20:38:44 UTC
20:38:44 0 I path = /file-2; entry = file-2, File, 9876 B = 9.645 KiB, 2022-12-11 20:38:44 UTC
20:38:44 0 I path = /dir-1; entry = dir-1, Directory, 4096 B = 4.000 KiB, 2022-12-11 20:38:44 UTC
20:38:44 0 I path = /dir-1/file-4; entry = file-4, File, 0 B = 0 B, 2022-12-11 20:38:44 UTC
20:38:44 0 I path = /dir-1/file-5; entry = file-5, File, 0 B = 0 B, 2022-12-11 20:38:44 UTC
20:38:44 0 I path = /dir-1/dir-2; entry = dir-2, Directory, 4096 B = 4.000 KiB, 2022-12-11 20:38:44 UTC
20:38:44 0 I path = /dir-1/dir-2/dir-3; entry = dir-3, Directory, 4096 B = 4.000 KiB, 2022-12-11 20:38:44 UTC
20:38:44 0 I path = /dir-1/dir-2/dir-3/file-3; entry = file-3, File, 0 B = 0 B, 2022-12-11 20:38:44 UTC
6_fs_5_open::fs------------------------------------ [passed]
20:38:45.049 0 I exit qemu; exit_code = SUCCESS
</code></pre>
<h3 id="Ориентировочный-объём-работ-этой-части-лабораторки-29"><a class="header" href="#Ориентировочный-объём-работ-этой-части-лабораторки-29">Ориентировочный объём работ этой части лабораторки</a></h3>
<pre><code class="language-console"> kernel/src/fs/file_system.rs |   21 +++++++++++++++++++--
 1 file changed, 19 insertions(+), 2 deletions(-)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
