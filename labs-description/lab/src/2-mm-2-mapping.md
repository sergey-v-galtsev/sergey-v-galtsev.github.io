## Страничные отображения

Основную работу по преобразованию виртуальных адресов в соответствующие физические будет делать метод
[`Mapping::translate()`](../../doc/kernel/memory/mapping/struct.Mapping.html#method.translate)
структуры
[`kernel::memory::mapping::Mapping`](../../doc/kernel/memory/mapping/struct.Mapping.html).

Обратное преобразование, из физического адреса в виртуальный, вообще говоря не является функцией, так как один и тот же физический адрес может быть отображён на несколько разных виртуальных адресов в одном адресном пространстве.
Однако, очень полезно находить какой-нибудь виртуальный адрес, соответствующий данному физическому.
Это понадобится в случае, когда захочется прочитать из физической памяти или записать в неё.
В частности, при реализации самого
[`Mapping`](../../doc/kernel/memory/mapping/struct.Mapping.html)
такая задача возникнет.

Решать эту задачу можно по-разному, например:

- Можно отобразить нужный физический фрейм временно в какую-нибудь свободную виртуальную страницу и писать уже в неё.
- В частном случае работы с фреймами, содержащими собственно страничное отображение, можно сделать [рекурсивную запись](https://wiki.osdev.org/Page_Tables#Recursive_mapping), и через неё все эти физические фреймы станут доступны в виртуальном адресном пространстве. Этот приём ещё пригодится нам в последующих лабораторках.
- Можно линейно отобразить всю физическую память или её значительную часть в отдельный диапазон виртуального адресного пространства. Тогда для получения доступа к заданному физическому адресу, нужно будет взять виртуальный адрес, равный сумме из некоторой константы --- виртуального адреса начала такого отображения --- и смещения нужного физического адреса от физического нуля.

Последний вариант достаточно прост в использовании, а адресное пространство в x86-64 достаточно большое для его реализации.
Поэтому воспользуемся этим вариантом.
В коде виртуальный адрес начала этого линейного отображения называется `phys2virt`, имеет тип
[`Page`](../../doc/ku/memory/frage/type.Page.html)
и содержит адрес виртуальной страницы, в которую отображён нулевой фрейм.
А для собственно преобразования заданного физического адреса `address` служит функция
[`kernel::memory::phys2virt_map()`](../../doc/kernel/memory/fn.phys2virt_map.html):
```rust
fn phys2virt_map(phys2virt: Page, address: Phys) -> Virt
```

Обеспечивает отображение всей физической памяти в виртуальную память библиотека
[bootloader](../../doc/bootloader/index.html),
которая грузит ядро в память при старте компьютера.
Об этом мы попросили её, задав опцию `map_physical_memory` в файле `kernel/Cargo.toml`:
```toml
    bootloader = { ..., features = ["map_physical_memory"] }
```
Она же сообщает нам о выбранном ею для этого виртуальном адресе в поле
[BootInfo::physical_memory_offset](../../doc/bootloader/bootinfo/struct.BootInfo.html#structfield.physical_memory_offset)
структуры
[bootloader::bootinfo::BootInfo](../../doc/bootloader/bootinfo/struct.BootInfo.html).
