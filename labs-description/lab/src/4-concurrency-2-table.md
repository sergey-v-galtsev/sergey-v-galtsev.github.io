## Таблица процессов

Код таблицы процессов находится в файле [`kernel/src/process/table.rs`](https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/kernel/src/process/table.rs).


### Идентификаторы процессов `Pid`

В файле [`ku/src/process/pid.rs`](https://gitlab.com/sergey-v-galtsev/nikka-public/-/blob/master/ku/src/process/pid.rs) описана структура

```rust
#[derive(Clone, Copy, Eq, PartialEq)]
pub enum Pid {
    Current,
    Id {
        slot: u16,
        epoch: u32,
    },
}
```

Она позволяет отдельно указывать `Pid::Current` --- текущий процесс,
это удобно для использования тех системных вызовов, что принимают на вход `Pid`.
Либо конкретный процесс `Pid::Id`, идентификатор которого состоит из номера слота в таблице процессов `slot`
и эпохи этого слота `epoch`.
`slot` позволяет быстро находить процесс по его идентификатору в таблице процессов, ---
она может быть устроена как вектор, а не как хеш-таблица.
А `epoch` позволяет сделать идентификаторы процессов уникальными на протяжении всего времени работы системы.
Например, в Unix есть гонка, из-за того что одно и то же значение `pid_t` может в разное время ссылаться на разные процессы.
Если вы хотите что-то сделать с определённым процессом, и записали его `pid_t` себе,
то конкурентно он может прекратить своё исполнение, а ядро выдаст то же самое значение `pid_t` новому процессу.
Теперь вы что-то делаете с процессом по сохранённому у себя `pid_t`, например, посылаете ему сигнал `SIGKILL`, но это уже другой процесс.
Реализации пытаются уменьшить вероятность таких гонок за счёт выдачи `pid_t` по кругу.
В Nikka для избежания гонки, каждый раз, когда новый процесс получает тот же `slot`, он получает на 1 большее значение `epoch`, за это отвечает метод `Pid::next_epoch()`.

Другие методы `Pid`:

- `Pid::new(slot)` создаёт `pid` с начальным значением `epoch` для заданного `slot`.
- `Pid::slot()` возвращает значение `slot`.
- `Pid::into_usize()` и `Pid::from_usize()` позволяют сериализовать `Pid` в регистр для передачи в системные вызовы.


### Слоты таблицы процессов

Таблица процессов состоит из фиксированного количества слотов

```rust
enum Slot {
    Free {
        pid: Pid,
        next: Option<Pid>,
    },
    Occupied {
        process: Mutex<Process>,
    },
}
```

Каждый из которых либо свободен --- `Slot::Free`, либо занят --- `Slot::Occupied`.

Свободные слоты содержат `pid` для того, что помнить эпоху последнего процесса, занимавшего этот слот.
И выдать следующему процессу, который попадёт в тот же слот, номер эпохи на 1 больше.
Также свободные слоты провязаны в список, чтобы удобнее было за O(1) находить какой-нибудь свободный слот под новый процесс.

Занятые слоты содержат мьютекс `process`.
Когда нам понадобится обратиться к процессу, нужно будет захватить его мьютекс, чтобы избежать неконсистентного конкурентного изменения структуры `Process`.
Чтобы обратиться с самой таблице процессов
[`static ref kernel::process::table::TABLE: Mutex<Table>`](../../doc/kernel/process/table/struct.TABLE.html),
конечно тоже нужно захватить её общий мьютекс.
Но не хочется держать заблокированным мьютекс всей таблицы, пока мы работаем со структурой `Process` одного её процесса.
Поэтому, таблица будет по идентификатору процесса `Pid` фактически обменивать заблокированный мьютекс `Mutex<Table>` на заблокированный мьютекс процесса `Mutex<Process>`.
После чего вызывающий код сможет работать с процессом конкурентно другому коду, который сможет захватить уже освободившийся `Mutex<Table>`.


### Задача 2 --- инициализация таблицы

Реализуйте метод

```rust
fn Table::new(len: usize) -> Self
```

Он создаёт таблицу процессов `Table::table` размера `len` элементов, заполняя её пустыми слотами `Slot::Free` с соответствующими индексам слотов полями `Pid::slot`.
Эти пустые слоты он провязывает в односвязный список с головой в поле `Table::free`.
Чтобы избежать переаллокаций рекомендуется использовать метод
[`alloc::vec::Vec::with_capacity()`](https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.with_capacity).


### Задача 3 --- аллокация слота под процесс

Реализуйте метод

```rust
fn Table::allocate(mut process: Process) -> Result<Pid>
```

Он должен выделить новому процессу `process` свободный слот таблицы.
Слот возьмите из головы списка свободных `Table::free`.
Запишите в него `process`, а `Pid` слота запишите в структуру процесса `process` методом `Process::set_pid()`.
Если же свободного слота нет, верните ошибку `Error::NoProcessSlot`.
В этом случае при выходе из метода, `process` будет автоматически уничтожен, а все его ресурсы освобождены.
Так как по сигнатуре `Table::allocate(process: Process)` поглощает свой аргумент.
Этот и все последующие методы --- статические, они оперируют с глобальным
[синглтоном](https://en.wikipedia.org/wiki/Singleton_pattern)
[`static ref TABLE: Mutex<Table>`](../../doc/kernel/process/table/struct.TABLE.html),
захватывая его блокировку --- `TABLE.lock()`.
При реализации вам может пригодиться метод
[`Option::take()`](https://doc.rust-lang.org/nightly/core/option/enum.Option.html#method.take).


### Задача 4 --- получение процесса по его идентификатору

Реализуйте метод

```rust
fn Table::get(pid: Pid) -> Result<MutexGuard<'static, Process>>
```

Он возвращает заблокированный мьютекс `MutexGuard` со структурой `Process`, соответствующей идентификатору `pid`.
Верните ошибку `Error::NoProcess`, если процесса по указанному `pid` нет.
То есть, если либо не занят `pid.slot()`, либо в этом слоте другое значение поля `Slot::pid` (значит у него другая эпоха `Pid::epoch`, так как слот `Pid::slot` должен совпадать).
Вытащить значение `epoch` тип `Pid` не позволяет, но зато он позволяет сравнивать два своих значения на равенство за счёт реализации `#[derive(..., Eq, PartialEq)]`.

Так как размер таблицы процессов
[`static ref TABLE: Mutex<Table>`](../../doc/kernel/process/table/struct.TABLE.html)
после инициализации мы никода не меняем, и в частности не уменьшаем, время жизни каждого её слота --- практически `'static`.
Который и указан в результирующем типе метода `Table::get()`.
Но Rust не может проверить это самостоятельно.
Нам придётся пообещать ему это с помощью unsafe--функции

```rust
unsafe fn forge_static_lifetime<T>(x: &T) -> &'static T
```

Естественно, чтобы вернуть `MutexGuard` нужно заблокировать процесс в слоте методом `Mutex::lock()`.
Мьютекс же самой `TABLE` будет автоматически разблокирован аналогичным гардом при выходе из функции.
Получается, что она в начале захватывает низкогранулярную блокировку на всю таблицу `TABLE`,
а потом повышает гранулярность этой блокировки до блокировки одного слота таблицы.
И вызывающая функции в дальнейшем работает уже с высокогранулярной блокировкой.


### Задача 5 --- освобождение слота с уничтожением процесса

Реализуйте метод

``` rust
fn Table::free(process: MutexGuard<Process>)
```

Он:

- Удаляет процесс `process`.
- Инкриментирует эпоху в освободившемся слоте.
- Вставляет слот в голову списка свободных слотов `Table::free`.

Вам могут пригодиться функции `drop()` и
[`core::mem::replace()`](https://doc.rust-lang.org/nightly/core/mem/fn.replace.html).


### Ориентировочный объём работ этой части лабораторки

```console
 table.rs |  100 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 96 insertions(+), 4 deletions(-)
```
